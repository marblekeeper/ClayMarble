/*
 * marble_gen.h -- AUTO-GENERATED by marble_compile.lua v0.1
 * Source: oak_forest.marble
 * DO NOT EDIT -- regenerate from .marble source
 */

#ifndef MARBLE_GEN_H
#define MARBLE_GEN_H

#include "marble_core.h"

/* ---- World Configuration ---- */
#define MC_GEN_MAX_ENTITIES     1024
#define MC_GEN_TICK_INTERVAL_US 600000
#define MC_GEN_WORLD_SEED       42u
#define MC_GEN_MAX_LAYERS       4
#define MC_GEN_MAX_BODY_PARTS   6
#define MC_GEN_MAX_SKILLS       8

/* ---- Materials ---- */
typedef enum {
    MAT_NONE = 0,
    MAT_WOOD = 1,
    MAT_IRON = 2,
    MAT_FLESH = 3,
    MAT_BARK = 4,
    MAT_BONE = 5,
    MAT_COUNT = 6
} MaterialID;

static const char* MATERIAL_NAMES[MAT_COUNT] = {
    "None",
    "Wood",
    "Iron",
    "Flesh",
    "Bark",
    "Bone",
};

static const int32_t MATERIAL_HARDNESS[MAT_COUNT] = {
    /*NONE*/ 0,
    /*WOOD*/ 30,
    /*IRON*/ 80,
    /*FLESH*/ 10,
    /*BARK*/ 25,
    /*BONE*/ 40,
};

/* ---- Layer System ---- */
#define MAX_LAYERS 4

typedef struct { MaterialID material; int32_t integrity; int32_t max_integrity; } Layer;
typedef struct { Layer layers[MAX_LAYERS]; uint32_t layer_count; } CLayerStack;

/* ---- Layer Templates ---- */
static void layer_template_OakTree(CLayerStack* ls) {
    ls->layer_count = 2;
    ls->layers[0].material = MAT_BARK; ls->layers[0].integrity = 3; ls->layers[0].max_integrity = 3;
    ls->layers[1].material = MAT_WOOD; ls->layers[1].integrity = 10; ls->layers[1].max_integrity = 10;
}

static void layer_template_HumanHand(CLayerStack* ls) {
    ls->layer_count = 2;
    ls->layers[0].material = MAT_FLESH; ls->layers[0].integrity = 1; ls->layers[0].max_integrity = 1;
    ls->layers[1].material = MAT_BONE; ls->layers[1].integrity = 1; ls->layers[1].max_integrity = 1;
}

/* ---- Skills ---- */
typedef enum {
    SKILL_NONE = 0,
    SKILL_WOODCUTTING = 1,
    SKILL_COUNT = 2
} SkillID;

#define MAX_SKILLS 8
typedef struct { int32_t level[MAX_SKILLS]; } CSkills;

/* ---- Anatomy Flags ---- */
typedef enum {
    ANAT_ARMS = (1 << 0),
    ANAT_HANDS = (1 << 1),
    ANAT_LEGS = (1 << 2),
} AnatomyFlag;
typedef struct { uint32_t flags; } CAnatomy;

/* ---- Body Parts ---- */
typedef enum {
    BODYPART_NONE = 0,
    BODYPART_RIGHT_HAND = 1,
    BODYPART_COUNT = 2
} BodyPartID;

static const char* BODYPART_NAMES[BODYPART_COUNT] = {
    "None",
    "Right Hand",
};

#define MAX_BODY_PARTS 6
typedef struct { EntityID part_entity[MAX_BODY_PARTS]; } CBodyParts;

/* ---- Conditions ---- */
typedef enum {
    COND_NONE = 0,
    COND_TOOL_HARDER_THAN_LAYER = 1,
    COND_COUNT = 2
} ConditionID;

/* ---- Effects ---- */
typedef enum {
    EFFECT_NONE = 0,
    EFFECT_DAMAGE_LAYER = 1,
    EFFECT_COUNT = 2
} EffectID;

/* ---- Capabilities ---- */
typedef enum {
    CAP_NONE = 0,
    CAP_CHOP = 1,
    CAP_COUNT = 2
} CapabilityID;

typedef struct { uint32_t required_anatomy; SkillID required_skill; int32_t min_skill_level; BodyPartID body_part_required; } CapabilityDef;

static const CapabilityDef CAPABILITY_DEFS[CAP_COUNT] = {
    /*CAP_NONE*/ { 0, SKILL_NONE, 0, BODYPART_NONE },
    /*CAP_CHOP*/ { ANAT_ARMS | ANAT_HANDS, SKILL_WOODCUTTING, 1, BODYPART_RIGHT_HAND },
};
typedef struct { uint32_t flags; } CCapabilities;

/* ---- Affordances ---- */
typedef enum {
    AFF_NONE = 0,
    AFF_CHOPPABLE = 1,
    AFF_COUNT = 2
} AffordanceID;

typedef struct { CapabilityID required_cap; ConditionID condition; EffectID on_success; int32_t difficulty; int32_t crit_fail_threshold; BodyPartID crit_fail_bodypart; int32_t crit_fail_damage; } AffordanceDef;

static const AffordanceDef AFFORDANCE_DEFS[AFF_COUNT] = {
    /*AFF_NONE*/ { CAP_NONE, COND_NONE, EFFECT_NONE, 0, 0, BODYPART_NONE, 0 },
    /*AFF_CHOPPABLE*/ { CAP_CHOP, COND_TOOL_HARDER_THAN_LAYER, EFFECT_DAMAGE_LAYER, 40, 15, BODYPART_RIGHT_HAND, 2 },
};
typedef struct { uint32_t flags; } CAffordances;

/* ---- Tool Component ---- */
typedef struct { MaterialID material; } CTool;

/* ---- Verbs ---- */
typedef enum {
    VERB_NONE = 0,
    VERB_CHOP = 1,
    VERB_COUNT = 2
} VerbID;

typedef struct { CapabilityID actor_cap; AffordanceID target_aff; } VerbDef;

static const VerbDef VERB_DEFS[VERB_COUNT] = {
    /*VERB_NONE*/ { CAP_NONE, AFF_NONE },
    /*VERB_CHOP*/ { CAP_CHOP, AFF_CHOPPABLE },
};

/* ---- Interaction Result ---- */
typedef enum {
    INTERACT_SUCCESS = 0, INTERACT_FAIL_NO_VERB = 1, INTERACT_FAIL_NO_CAP = 2,
    INTERACT_FAIL_ANATOMY = 3, INTERACT_FAIL_BODY_PART = 4, INTERACT_FAIL_SKILL_LOW = 5,
    INTERACT_FAIL_NO_AFF = 6, INTERACT_FAIL_CONDITION = 7, INTERACT_FAIL_ROLL = 8,
    INTERACT_CRIT_FAIL = 9, INTERACT_FAIL_NO_RULE = 10, INTERACT_RESULT_COUNT
} InteractResult;

static const char* INTERACT_RESULT_NAMES[INTERACT_RESULT_COUNT] = {
    "SUCCESS","FAIL:NO_VERB","FAIL:NO_CAP","FAIL:ANATOMY","FAIL:BODY_PART",
    "FAIL:SKILL_LOW","FAIL:NO_AFF","FAIL:CONDITION","FAIL:ROLL","CRIT_FAIL","FAIL:NO_RULE"
};

/* ---- Interaction Request ---- */
#define MAX_INTERACTION_REQUESTS 64
typedef struct { EntityID actor; EntityID target; VerbID verb; } InteractionRequest;

/* ---- Systems ---- */
typedef enum {
    SYS_TICK_LOG = 0,
    SYS_INTERACTION_PROCESSOR = 1,
    SYS_WORLD_STATUS = 2,
    SYS_COUNT = 3
} SystemID;

static const uint32_t SYSTEM_FREQ[SYS_COUNT] = {
    /*SYS_TICK_LOG*/ 1,
    /*SYS_INTERACTION_PROCESSOR*/ 2,
    /*SYS_WORLD_STATUS*/ 3,
};

/* ---- Command/Rule Types ---- */
typedef enum { CMD_NONE=0, CMD_DAMAGE_LAYER=1, CMD_MODIFY_STAT=2, CMD_TRANSFORM_ENTITY=3, CMD_MOVE_ENTITY=4, CMD_REMOVE_ENTITY=5, CMD_PLAY_FEEDBACK=6, CMD_CRIT_DAMAGE=7, CMD_TYPE_COUNT } CommandType;
typedef enum { OP_ADD=0, OP_SUBTRACT=1, OP_SET=2 } StatOperation;
typedef enum { CMD_TARGET_NONE=0, CMD_TARGET_ACTOR=1, CMD_TARGET_TARGET=2, CMD_TARGET_TOOL=3, CMD_TARGET_ENV=4 } CommandTargetRole;

#define MAX_RULE_EFFECTS 8
#define MAX_RULE_CONDS   4
#define GEN_RULE_COUNT   1

typedef struct { CommandType type; CommandTargetRole target_role; uint32_t stat_id; int32_t amount; StatOperation stat_op; uint32_t new_def_id; uint32_t message_id; uint32_t bodypart_id; } RuleEffect;
typedef struct { uint32_t rule_id; uint32_t trigger_verb; uint32_t required_cap; uint32_t cond_ids[MAX_RULE_CONDS]; uint32_t cond_count; int32_t difficulty; int32_t crit_fail_threshold; uint32_t crit_fail_bodypart; int32_t crit_fail_damage; RuleEffect effects[MAX_RULE_EFFECTS]; uint32_t effect_count; } RuleDef;

static const RuleDef GEN_RULES[1] = {
    /* Rule_Chop */ {
        1, VERB_CHOP, CAP_CHOP,
        { COND_TOOL_HARDER_THAN_LAYER }, 1,
        40, 15, BODYPART_RIGHT_HAND, 2,
        {
            { CMD_DAMAGE_LAYER, CMD_TARGET_TARGET, 0, 1, OP_ADD, 0, 0, 0 },
        }, 1
    },
};

/* ---- Condition Evaluator (generated) ---- */
static int gen_evaluate_condition(ConditionID cond, EntityID actor, EntityID target, const SparseSet* pool_tool, const SparseSet* pool_layers) {
    switch (cond) {
        case COND_NONE: return 1;
        case COND_TOOL_HARDER_THAN_LAYER: {
            const CTool* tool = (const CTool*)mc_sparse_set_get_const(pool_tool, actor);
            const CLayerStack* stack = (const CLayerStack*)mc_sparse_set_get_const(pool_layers, target);
            if (!tool || !stack || stack->layer_count == 0) return 0;
            return MATERIAL_HARDNESS[tool->material] > MATERIAL_HARDNESS[stack->layers[0].material];
        }
        default: return 0;
    }
}

/* ---- Body Part Integrity Check (generated) ---- */
static int gen_check_body_part_integrity(BodyPartID bp_id, EntityID actor, const SparseSet* pool_bp, const SparseSet* pool_layers) {
    const CBodyParts* bp; const CLayerStack* ls; EntityID part;
    if (bp_id == BODYPART_NONE) return 1;
    bp = (const CBodyParts*)mc_sparse_set_get_const(pool_bp, actor);
    if (!bp) return 0;
    part = bp->part_entity[bp_id];
    if (part == MC_INVALID_INDEX) return 0;
    ls = (const CLayerStack*)mc_sparse_set_get_const(pool_layers, part);
    if (!ls || ls->layer_count == 0) return 0;
    return ls->layers[0].integrity > 0;
}

#endif /* MARBLE_GEN_H */
