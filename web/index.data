-- MindMarr.lua
-- MINDMARR: Mars Becomes Mind
-- d100 Roll-Under Survival Horror — Escape the sentient planet
-- Arrow keys move, bump-to-attack, collect supplies, reach the shuttle
-- Say "MINDMARR" and it's the last word you ever say

local root = UIElement:new({width=800, height=600})

local W, H = 800, 600
local max = math.max

-- Load modules
local state = require("state")
local K = require("constants")
local util = require("util")
local combat = require("combat")
local actions = require("actions")
local draw = require("draw")

local game = state.game
local player = state.player

-- Input
local function keyPressed(key)
    if not bridge.getKeyState then return false end
    local down = bridge.getKeyState(key) == 1
    local was = game.keyWasDown[key] or false
    game.keyWasDown[key] = down
    return down and not was
end

-- Main update
function UpdateUI(mx, my, down, w, h)
    W, H = w, h
    root.width = w
    root.height = h
    draw.setSize(w, h)
    local dt = 0.016

    game.pulseTimer = game.pulseTimer + dt

    if game.shakeTimer > 0 then
        game.shakeTimer = game.shakeTimer - dt
    end

    -- Particles
    for i = #game.particles, 1, -1 do
        local p = game.particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.life = p.life - dt
        p.vx = p.vx * 0.95
        p.vy = p.vy * 0.95
        if p.life <= 0 then table.remove(game.particles, i) end
    end

    for _, msg in ipairs(game.messages) do
        msg.age = msg.age + dt
    end

    -- Title
    if game.state == "title" then
        if keyPressed("space") then actions.resetGame() end
        return
    end

    -- Dead / mindmarr / won
    if game.state == "dead" or game.state == "mindmarr" or game.state == "won" then
        if keyPressed("space") then actions.resetGame() end
        return
    end

    -- Level up
    if game.state == "levelup" then
        for i = 1, #K.levelChoices do
            if keyPressed(tostring(i)) then
                actions.applyLevelChoice(i)
                break
            end
        end
        return
    end

    -- Playing
    game.inputCooldown = max(0, game.inputCooldown - dt)

    if game.state == "playing" then
        if keyPressed("up") or keyPressed("w") then actions.tryMove(0, -1)
        elseif keyPressed("down") or keyPressed("s") then actions.tryMove(0, 1)
        elseif keyPressed("left") or keyPressed("a") then actions.tryMove(-1, 0)
        elseif keyPressed("right") or keyPressed("d") then actions.tryMove(1, 0)
        elseif keyPressed("m") then actions.useMedkit()
        end
    end
end

function DrawUI()
    draw.drawGame()
end-- actions.lua
-- MINDMARR: Player actions - movement, items, floor transitions

local rand, floor = math.random, math.floor
local max, min = math.max, math.min

local state = require("state")
local K = require("constants")
local util = require("util")
local combat = require("combat")
local mapgen = require("mapgen")

local game = state.game
local player = state.player

local M = {}

function M.newFloor()
    player.seen = {}
    local rooms = mapgen.generateMap()
    mapgen.populateFloor(rooms)
    util.dimFOV()
    util.computeFOV()

    -- O2 cost per sector transition
    if game.sector > 1 then
        local o2cost = rand(5, 12)
        player.oxygen = max(0, player.oxygen - o2cost)
        util.addMessage("Airlock transit: -" .. o2cost .. " O2", K.C.oxygen[1], K.C.oxygen[2], K.C.oxygen[3])
        if player.oxygen <= 0 then
            game.state = "dead"
            util.addMessage("Suffocated between sectors.", 255, 50, 50)
            util.screenShake(6, 0.3)
            return
        end
    end

    if game.sector == game.maxSectors then
        util.addMessage("== SECTOR " .. game.sector .. ": SHUTTLE BAY ==", 255, 220, 80)
        util.addMessage("The shuttle is HERE. Reach it!", 255, 255, 150)
    else
        util.addMessage("-- Sector " .. game.sector .. " / " .. game.maxSectors .. " --", 255, 180, 100)
    end

    if rand(1, 100) <= game.sector * 12 then
        util.marsWhisper()
    end
end

local function endOfTurn()
    game.turn = game.turn + 1
    combat.moveEnemies()

    game.marsWhisperTimer = game.marsWhisperTimer + 1
    if game.marsWhisperTimer >= (8 - min(5, game.sector)) then
        game.marsWhisperTimer = 0
        util.marsWhisper()
    end

    util.dimFOV()
    util.computeFOV()
    combat.checkSanityDeath()
end

function M.tryMove(dx, dy)
    if game.state ~= "playing" then return end

    local nx, ny = player.x + dx, player.y + dy

    local e = util.enemyAt(nx, ny)
    if e then
        combat.resolveMelee(player, e, "You", e.name, player.str, e.def, player.dmgMin, player.dmgMax)
        combat.checkEnemyDeath(e)
        if game.state ~= "dead" and game.state ~= "mindmarr" then
            endOfTurn()
        end
        return
    end

    if util.tileAt(nx, ny) == 0 then
        player.x = nx; player.y = ny

        -- Items
        local items = state.items
        for i = #items, 1, -1 do
            local it = items[i]
            if it.x == nx and it.y == ny then
                if it.type == "supply" then
                    player.xp = player.xp + it.amount
                    util.addMessage("Scavenged supplies (+" .. it.amount .. " XP)", K.C.supply[1], K.C.supply[2], K.C.supply[3])
                    util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 6, 100, 220, 140, 40, 0.3)
                    if player.xp >= player.xpNext then
                        game.state = "levelup"
                        player.level = player.level + 1
                        player.xpNext = floor(player.xpNext * 1.6)
                        util.addMessage("*** ADAPT — Level " .. player.level .. " ***", 255, 255, 100)
                        util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 25, 60, 200, 255, 120, 0.8)
                    end
                elseif it.type == "medkit" then
                    player.medkits = player.medkits + 1
                    util.addMessage("Found a medkit!", 100, 255, 150)
                    util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 6, 100, 255, 150, 40, 0.3)
                elseif it.type == "cell" then
                    player.cells = player.cells + 1
                    util.addMessage("POWER CELL acquired! (" .. player.cells .. "/" .. player.cellsNeeded .. ")", K.C.cell[1], K.C.cell[2], K.C.cell[3])
                    util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 12, 180, 60, 200, 60, 0.5)
                    util.screenShake(2, 0.1)
                elseif it.type == "oxygen" then
                    local o2 = rand(10, 20)
                    player.oxygen = min(100, player.oxygen + o2)
                    util.addMessage("O2 canister: +" .. o2 .. " oxygen", K.C.oxygen[1], K.C.oxygen[2], K.C.oxygen[3])
                    util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 6, 80, 200, 220, 40, 0.3)
                elseif it.type == "keycard" then
                    player.keycards = player.keycards + 1
                    util.addMessage("KEYCARD found! Can skip a sector via elevator.", K.C.keycard[1], K.C.keycard[2], K.C.keycard[3])
                    util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 10, K.C.keycard[1], K.C.keycard[2], K.C.keycard[3], 50, 0.4)
                    util.screenShake(2, 0.15)
                    -- Reveal elevator on this floor
                    state.elevator.revealed = true
                end
                table.remove(items, i)
            end
        end

        -- Elevator (skip sector if player has keycard)
        if state.elevator.revealed and nx == state.elevator.x and ny == state.elevator.y then
            if player.keycards > 0 then
                local skipTo = min(game.maxSectors, game.sector + 2)
                player.keycards = player.keycards - 1
                util.addMessage("Elevator activated! Skipping to sector " .. skipTo .. "...", K.C.elevator[1], K.C.elevator[2], K.C.elevator[3])
                util.screenShake(4, 0.3)
                util.spawnParticles(nx * K.TS + K.TS/2, ny * K.TS + K.TS/2, 20, K.C.elevator[1], K.C.elevator[2], K.C.elevator[3], 80, 0.6)
                game.sector = skipTo
                M.newFloor()
                return
            else
                util.addMessage("Elevator locked. Need a keycard!", 200, 100, 100)
            end
        end

        -- Shuttle/airlock
        if nx == state.shuttle.x and ny == state.shuttle.y then
            if game.sector == game.maxSectors then
                if player.cells >= player.cellsNeeded then
                    game.state = "won"
                    game.won = true
                    util.addMessage("You ignite the shuttle engines!", 255, 255, 100)
                    util.addMessage("ESCAPED! Mars screams behind you.", 80, 255, 120)
                    util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 50, 255, 220, 80, 200, 1.5)
                    util.screenShake(6, 0.5)
                    return
                else
                    util.addMessage("Shuttle needs " .. (player.cellsNeeded - player.cells) .. " more power cells!", 255, 100, 100)
                end
            else
                game.sector = game.sector + 1
                M.newFloor()
                return
            end
        end

        endOfTurn()
    end
end

function M.useMedkit()
    if player.medkits > 0 and player.hp < player.maxHp then
        player.medkits = player.medkits - 1
        local heal = floor(player.maxHp * 0.4) + rand(1, 5)
        player.hp = min(player.maxHp, player.hp + heal)
        util.addMessage("Used medkit: +" .. heal .. " HP", 100, 255, 150)
        util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 10, 100, 255, 150, 50, 0.4)
        game.turn = game.turn + 1
        combat.moveEnemies()
        util.dimFOV(); util.computeFOV()
    end
end

-- Level up choices (apply functions need player reference)
function M.applyLevelChoice(index)
    local applies = {
        function() player.maxHp = player.maxHp + 5; player.hp = player.maxHp end,
        function() player.str = min(95, player.str + 8) end,
        function() player.def = min(85, player.def + 8) end,
        function() player.dmgMax = player.dmgMax + 2 end,
        function() player.armor = player.armor + 1 end,
        function() player.sanity = min(100, player.sanity + 15) end,
        function() player.critBonus = min(25, player.critBonus + 3) end,
    }
    if applies[index] then
        applies[index]()
        util.addMessage("Adapted: " .. K.levelChoices[index].name, 100, 230, 255)
        game.state = "playing"
    end
end

function M.resetGame()
    game.state = "playing"
    game.sector = 1
    game.turn = 0
    game.messages = {}
    game.particles = {}
    game.marsWhisperTimer = 0
    game.won = false

    player.hp = 30; player.maxHp = 30
    player.str = 55; player.def = 40
    player.dmgMin = 2; player.dmgMax = 5
    player.armor = 0
    player.xp = 0; player.xpNext = 20
    player.level = 1
    player.sanity = 100; player.oxygen = 100
    player.medkits = 1; player.cells = 0
    player.cellsNeeded = 3
    player.kills = 0; player.critBonus = 5
    player.seen = {}
    player.keycards = 0

    util.addMessage("Arrows: move/attack. M: medkit. Escape Mars alive.", 180, 180, 220)
    util.addMessage("Don't lose your mind. Don't say the word.", 200, 60, 80)
    M.newFloor()
end

return M-- assets.lua
-- MINDMARR: Optional sprite asset loading and rendering
-- Falls back to procedural rendering if assets unavailable

local K = require("constants")

local M = {}

-- Cache for loaded textures (stores {texture, width, height})
local textureCache = {}

-- Attempt to load a sprite texture
-- Returns {texture, width, height} or nil if loading fails
function M.loadSprite(key)
    if textureCache[key] ~= nil then
        return textureCache[key] -- Return cached (could be false for failed loads)
    end
    
    local path = K.assets.sprites[key]
    if not path then
        textureCache[key] = false
        return nil
    end
    
    -- Attempt to load texture via bridge
    if not bridge or not bridge.loadTexture then
        textureCache[key] = false
        return nil
    end
    
    -- loadTexture returns (textureId, width, height)
    local success, texture, w, h = pcall(bridge.loadTexture, path)
    if success and texture then
        textureCache[key] = {texture = texture, width = w or K.TS, height = h or K.TS}
        return textureCache[key]
    else
        textureCache[key] = false
        return nil
    end
end

-- Draw a sprite if available, return true if drawn
-- x, y: screen coordinates (top-left of tile)
-- w, h: width and height to draw (optional - uses sprite's natural size if nil)
-- key: sprite key from K.assets.sprites
function M.tryDrawSprite(key, x, y, w, h)
    local spriteData = M.loadSprite(key)
    if not spriteData or spriteData == false then
        return false
    end
    
    -- Use natural sprite dimensions if not specified
    local drawW = w or spriteData.width
    local drawH = h or spriteData.height
    
    -- Center the sprite in the tile if it's smaller than tile size
    local offsetX = 0
    local offsetY = 0
    if not w and drawW < K.TS then
        offsetX = (K.TS - drawW) / 2
    end
    if not h and drawH < K.TS then
        offsetY = (K.TS - drawH) / 2
    end
    
    if bridge and bridge.drawTexture then
        bridge.drawTexture(spriteData.texture, x + offsetX, y + offsetY, drawW, drawH)
        return true
    end
    
    return false
end

-- Clear texture cache (call on game reset if needed)
function M.clearCache()
    textureCache = {}
end

return M-- combat.lua
-- MINDMARR: Combat resolution, death checks, enemy AI

local rand, floor = math.random, math.floor
local abs, max, min = math.abs, math.max, math.min

local state = require("state")
local K = require("constants")
local util = require("util")

local game = state.game
local player = state.player

local M = {}

function M.resolveMelee(attacker, defender, atkName, defName, atkStr, defDef, dmgMin, dmgMax, onDone)
    local roll = util.d100()
    local hit = roll <= atkStr
    local crit = false
    if attacker == player then crit = roll <= player.critBonus end

    if not hit then
        util.addMessage(atkName .. " > " .. defName .. ": d100=" .. roll .. " vs " .. atkStr .. " MISS", K.C.miss[1], K.C.miss[2], K.C.miss[3])
        util.spawnParticles(defender.x * K.TS + K.TS/2, defender.y * K.TS + K.TS/2, 3, 100, 80, 80, 30, 0.3)
    else
        local dRoll = util.d100()
        local dodged = dRoll <= defDef

        if dodged then
            util.addMessage(defName .. " evades! d100=" .. dRoll .. " vs " .. defDef, K.C.miss[1], K.C.miss[2], K.C.miss[3])
            util.spawnParticles(defender.x * K.TS + K.TS/2, defender.y * K.TS + K.TS/2, 4, 150, 150, 255, 40, 0.3)
        else
            local dmg = rand(dmgMin, dmgMax)
            if crit then
                dmg = dmg * 2
                util.addMessage(atkName .. " CRITS " .. defName .. "! d100=" .. roll .. " DMG:" .. dmg, K.C.crit[1], K.C.crit[2], K.C.crit[3])
                util.screenShake(5, 0.2)
                util.spawnParticles(defender.x * K.TS + K.TS/2, defender.y * K.TS + K.TS/2, 15, 255, 200, 60, 80, 0.5)
            else
                util.addMessage(atkName .. " hits " .. defName .. " d100=" .. roll .. " DMG:" .. dmg, K.C.hit[1], K.C.hit[2], K.C.hit[3])
                util.screenShake(3, 0.1)
                util.spawnParticles(defender.x * K.TS + K.TS/2, defender.y * K.TS + K.TS/2, 8, 255, 80, 60, 60, 0.4)
            end

            if defender == player and player.armor > 0 then
                local reduced = max(1, dmg - player.armor)
                if reduced < dmg then
                    util.addMessage("  Suit absorbs " .. (dmg - reduced), 160, 160, 180)
                end
                dmg = reduced
            end

            defender.hp = defender.hp - dmg

            if defender == player and rand() < 0.3 then
                player.sanity = max(0, player.sanity - rand(1, 2))
                util.addMessage("  Your mind fractures...", K.C.whisper[1], K.C.whisper[2], K.C.whisper[3])
            end
        end
    end

    -- Infected scream mindmarr on attack
    if attacker ~= player then
        local say = K.MINDMARR_SAYS[rand(1, #K.MINDMARR_SAYS)]
        util.addMessage("  " .. atkName .. ": \"" .. say .. "\"", K.C.infected[1], K.C.infected[2], K.C.infected[3])
    end

    if onDone then onDone() end
end

function M.checkEnemyDeath(e)
    if e.hp <= 0 then
        e.alive = false
        util.addMessage(e.name .. " collapses: \"mind...marr...\" (+" .. e.xp .. " XP)", K.C.xp[1], K.C.xp[2], K.C.xp[3])
        util.spawnParticles(e.x * K.TS + K.TS/2, e.y * K.TS + K.TS/2, 20, e.color[1], e.color[2], e.color[3], 100, 0.6)
        util.screenShake(4, 0.15)
        player.xp = player.xp + e.xp
        player.kills = player.kills + 1

        if rand() < 0.4 then
            state.items[#state.items+1] = {x = e.x, y = e.y, type = "supply", amount = rand(1, 4) + game.sector}
        end

        if player.xp >= player.xpNext then
            game.state = "levelup"
            player.level = player.level + 1
            player.xpNext = floor(player.xpNext * 1.6)
            util.addMessage("*** ADAPT — Level " .. player.level .. " ***", 255, 255, 100)
            util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 25, 60, 200, 255, 120, 0.8)
            util.screenShake(3, 0.2)
        end
    end
end

function M.checkPlayerDeath()
    if player.hp <= 0 then
        player.hp = 0
        game.state = "dead"
        util.addMessage("Your body joins the Mindmarr.", 255, 50, 50)
        util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 40, 200, 30, 50, 150, 1.0)
        util.screenShake(8, 0.4)
    end
end

function M.checkSanityDeath()
    if player.sanity <= 0 and game.state == "playing" then
        game.state = "mindmarr"
        util.addMessage("Your lips move: \"mindmarr\"", 255, 20, 40)
        util.addMessage("The last word you ever say.", 255, 0, 0)
        util.screenShake(10, 0.6)
        util.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 50, 200, 30, 60, 150, 1.2)
    end
end

function M.moveEnemies()
    for _, e in ipairs(state.enemies) do
        if not e.alive then goto continue end

        local dx = player.x - e.x
        local dy = player.y - e.y
        local adist = abs(dx) + abs(dy)

        if adist > 10 then goto continue end

        -- Nearby enemies mumble
        if adist <= 6 and rand() < 0.08 then
            local say = K.MINDMARR_SAYS[rand(1, #K.MINDMARR_SAYS)]
            util.addMessage(e.name .. ": \"" .. say .. "\"", K.C.infected[1], K.C.infected[2], K.C.infected[3])
            if rand() < 0.3 then
                player.sanity = max(0, player.sanity - 1)
            end
        end

        if adist == 1 then
            M.resolveMelee(e, player, e.name, "You", e.str, player.def, e.dmgMin, e.dmgMax)
            M.checkPlayerDeath()
            M.checkSanityDeath()
            goto continue
        end

        local mx, my = 0, 0
        if abs(dx) >= abs(dy) then
            mx = dx > 0 and 1 or -1
        else
            my = dy > 0 and 1 or -1
        end

        local nx, ny = e.x + mx, e.y + my
        if util.tileAt(nx, ny) == 0 and not util.enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
            e.x = nx; e.y = ny
        else
            if mx ~= 0 then
                my = dy > 0 and 1 or (dy < 0 and -1 or 0); mx = 0
            else
                mx = dx > 0 and 1 or (dx < 0 and -1 or 0); my = 0
            end
            nx, ny = e.x + mx, e.y + my
            if util.tileAt(nx, ny) == 0 and not util.enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
                e.x = nx; e.y = ny
            end
        end

        ::continue::
    end
end

return M-- constants.lua
-- MINDMARR: Shared constants, palette, config

local TS = 24
local MW, MH = 30, 22

local C = {
    void      = {4, 2, 6},
    wall      = {90, 40, 25},
    wallHi    = {120, 55, 35},
    floor     = {35, 18, 14},
    floorLit  = {55, 28, 22},
    player    = {60, 200, 255},
    infected  = {180, 40, 60},
    infGlow   = {220, 60, 80},
    supply    = {100, 220, 140},
    cell      = {180, 60, 200},
    shuttle   = {255, 220, 80},
    fog       = {6, 3, 8},
    blood     = {140, 30, 40},
    xp        = {200, 120, 255},
    crit      = {255, 200, 60},
    miss      = {100, 80, 80},
    hit       = {255, 80, 60},
    hud_bg    = {12, 6, 10},
    hud_border= {80, 35, 50},
    mars      = {200, 60, 40},
    whisper   = {160, 50, 70},
    sanity    = {120, 180, 255},
    oxygen    = {80, 200, 220},
    keycard   = {255, 200, 50},
    elevator  = {100, 220, 255},
}

local MINDMARR_SAYS = {
    "mindmarr...", "MINDMARR!", "mind...marr...", "mindmarr", "MiNdMaRr",
    "m i n d m a r r", "MINDMARR MINDMARR", "...mindmarr...",
    "mindmarr?", "MINDMARR.", "mind...m a r r...", "mindmarrMINDMARR",
}

local marsWhispers = {
    "The ground pulses beneath you...",
    "You hear your name spoken from below...",
    "The walls are breathing...",
    "Something remembers you were born...",
    "Mars knows your mother's name...",
    "The red dust rearranges into a face...",
    "You feel the planet thinking...",
    "Your shadow moved on its own...",
    "The air tastes like someone else's memory...",
    "mind...marr... NO. Focus.",
    "A voice in the static: 'Join us.'",
    "Your reflection blinked before you did...",
}

local levelChoices = {
    {name = "+5 Max HP & heal"},
    {name = "+8 STR (hit chance)"},
    {name = "+8 DEF (dodge)"},
    {name = "+2 Max Damage"},
    {name = "+1 Suit Armor"},
    {name = "+15 Sanity restored"},
    {name = "+3 Crit Range"},
}

-- Optional sprite assets (if nil/missing, falls back to procedural rendering)
local assets = {
    sprites = {
        player = "assets/Content/textures/scientist.png",
        enemy_scientist = "assets/Content/textures/scientist_mindmarr.png",
        -- Future: add more sprites here
        -- medkit = "assets/Content/textures/medkit.png",
    }
}

return {
    TS = TS,
    MW = MW,
    MH = MH,
    C = C,
    MINDMARR_SAYS = MINDMARR_SAYS,
    marsWhispers = marsWhispers,
    levelChoices = levelChoices,
    assets = assets,
}-- draw.lua
-- MINDMARR: All rendering

local sin, cos, rand, floor = math.sin, math.cos, math.random, math.floor
local abs, max, min = math.abs, math.max, math.min

local state = require("state")
local K = require("constants")
local util = require("util")
local assets = require("assets")

local game = state.game
local player = state.player

local W, H = 800, 600

local M = {}

function M.setSize(w, h)
    W, H = w, h
end

local function drawTile(sx, sy, tx, ty)
    local camOX = floor(W/2 - player.x * K.TS - K.TS/2)
    local camOY = floor(H * 0.4 - player.y * K.TS - K.TS/2)
    local px = camOX + tx * K.TS + sx
    local py = camOY + ty * K.TS + sy
    local mapAreaH = floor(H * 0.65)

    if px < -K.TS or px > W + K.TS or py < -K.TS or py > mapAreaH + K.TS then return end

    local vis = util.isVisible(tx, ty)
    local seen = util.isSeen(tx, ty)
    local tile = util.tileAt(tx, ty)

    if not seen then
        bridge.drawRect(px, py, K.TS, K.TS, K.C.void[1], K.C.void[2], K.C.void[3], 255)
        return
    end

    local dim = vis and 1.0 or 0.3

    local marsPulse = 0
    if vis and game.sector > 2 then
        marsPulse = sin(game.pulseTimer * 2 + tx * 0.3 + ty * 0.5) * 8 * (game.sector / game.maxSectors)
    end

    if tile == 1 then
        local cr, cg, cb = K.C.wall[1], K.C.wall[2], K.C.wall[3]
        if (tx + ty) % 3 == 0 then cr, cg, cb = K.C.wallHi[1], K.C.wallHi[2], K.C.wallHi[3] end
        cr = min(255, cr + marsPulse)
        bridge.drawRect(px, py, K.TS, K.TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        if vis and ty > 1 and util.tileAt(tx, ty-1) == 0 then
            bridge.drawRect(px, py, K.TS, 2, floor(100*dim), floor(50*dim), floor(40*dim), 255)
        end
    else
        local cr, cg, cb = K.C.floor[1], K.C.floor[2], K.C.floor[3]
        if vis then cr, cg, cb = K.C.floorLit[1], K.C.floorLit[2], K.C.floorLit[3] end
        cr = min(255, cr + marsPulse * 0.5)
        bridge.drawRect(px, py, K.TS, K.TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        if (tx * 7 + ty * 13) % 11 == 0 then
            bridge.drawRect(px + 4, py + 4, 2, 2, floor(cr*dim*0.6), floor(cg*dim*0.6), floor(cb*dim*0.6), 255)
        end
        if vis and game.sector >= 3 and (tx * 3 + ty * 7) % 17 == 0 then
            bridge.drawRect(px + rand(2, K.TS-4), py + rand(2, K.TS-4), 1, 1, 140, 50, 30, 60)
        end
    end
end

local function drawTitle()
    bridge.drawRect(0, 0, W, H, 8, 3, 6, 255)
    for x = 0, W, 4 do
        local yy = H * 0.55 + sin(x * 0.02 + game.pulseTimer) * 8
        bridge.drawRect(x, yy, 4, H - yy, 50, 15, 10, 80)
    end

    bridge.drawText("M I N D M A R R", W/2 - 70, H/4 - 10, 255, 40, 50, 255)
    bridge.drawText("Mars is alive. Mars remembers.", W/2 - 105, H/4 + 18, 180, 60, 70, 255)

    bridge.drawText("You are a survivor. The colony is lost.", W/2 - 130, H/2 - 20, 160, 140, 150, 255)
    bridge.drawText("Everyone speaks only one word now.", W/2 - 120, H/2, 160, 140, 150, 255)
    bridge.drawText("If you say it, you join them.", W/2 - 100, H/2 + 20, 200, 60, 70, 255)

    bridge.drawText("Arrow Keys: Move & Fight", W/2 - 85, H/2 + 55, 140, 140, 160, 255)
    bridge.drawText("M: Medkit    Reach the shuttle.", W/2 - 100, H/2 + 75, 140, 140, 160, 255)

    local flicker = sin(game.pulseTimer * 3) > 0 and 255 or 180
    bridge.drawText("PRESS SPACE", W/2 - 40, H * 0.82, flicker, flicker, min(255, flicker + 20), 255)
end

local function drawWon()
    bridge.drawRect(0, 0, W, H, 4, 8, 15, 255)
    for i = 1, 60 do
        local sx2 = (i * 137 + floor(game.pulseTimer * 10)) % W
        local sy2 = (i * 211) % H
        bridge.drawRect(sx2, sy2, 1, 1, 255, 255, 255, rand(100, 255))
    end

    bridge.drawText("E S C A P E D", W/2 - 55, H/4, 80, 255, 120, 255)
    bridge.drawText("Mars screams behind you, but you don't look back.", W/2 - 170, H/4 + 30, 160, 200, 180, 255)

    bridge.drawText("Level: " .. player.level .. "  Kills: " .. player.kills, W/2 - 70, H/2, 200, 200, 220, 255)
    bridge.drawText("Sanity: " .. player.sanity .. "%  O2: " .. player.oxygen .. "%", W/2 - 80, H/2 + 20, K.C.sanity[1], K.C.sanity[2], K.C.sanity[3], 255)
    bridge.drawText("Cells: " .. player.cells .. "  Sectors cleared: " .. game.maxSectors, W/2 - 100, H/2 + 40, K.C.cell[1], K.C.cell[2], K.C.cell[3], 255)

    local score = player.kills * 10 + player.sanity * 5 + player.oxygen * 2 + game.maxSectors * 100
    bridge.drawText("Score: " .. score, W/2 - 35, H/2 + 70, 255, 220, 80, 255)

    bridge.drawText("PRESS SPACE TO PLAY AGAIN", W/2 - 90, H * 0.8, 180, 180, 200, 255)
end

local function drawMindmarr()
    local pulse = sin(game.pulseTimer * 4) * 0.3 + 0.7
    bridge.drawRect(0, 0, W, H, floor(30 * pulse), floor(5 * pulse), floor(8 * pulse), 255)

    bridge.drawText("m i n d m a r r", W/2 - 60, H/4, 255, floor(40 * pulse), floor(50 * pulse), 255)
    bridge.drawText("You are one of them now.", W/2 - 80, H/4 + 30, 200, 60, 70, 255)
    bridge.drawText("Your mouth only forms one word.", W/2 - 110, H/4 + 55, 180, 50, 60, 255)

    for i = 0, 12 do
        local yy = H/2 + 10 + i * 16
        local off = floor(game.pulseTimer * 40 + i * 50) % W
        local alpha = max(40, 200 - i * 15)
        bridge.drawText("mindmarr mindmarr mindmarr mindmarr mindmarr", -off + W/2, yy,
            floor(200 * pulse), 30, 40, alpha)
    end

    bridge.drawText("Floor: " .. game.sector .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4, H * 0.82, 200, 200, 200, 200)
    bridge.drawText("PRESS SPACE", W/2 - 40, H * 0.9, 180, 100, 110, 255)
end

local function drawHUD(mapAreaH)
    local hudY = mapAreaH + 2
    local hudH = H - hudY
    bridge.drawRect(0, hudY, W, hudH, K.C.hud_bg[1], K.C.hud_bg[2], K.C.hud_bg[3], 255)
    bridge.drawRect(0, hudY, W, 2, K.C.hud_border[1], K.C.hud_border[2], K.C.hud_border[3], 255)

    local col1 = 10
    local ly = hudY + 6

    -- Row 1: Level, Sector
    bridge.drawText("LVL:" .. player.level, col1, ly, 255, 255, 150, 255)
    bridge.drawText("SECTOR:" .. game.sector .. "/" .. game.maxSectors, col1 + 55, ly, 255, 180, 100, 255)

    ly = ly + 14

    -- Row 2: HP bar
    bridge.drawText("HP:", col1, ly, 200, 200, 200, 255)
    local barX = col1 + 28
    local barW = 80
    local barH = 10
    bridge.drawRect(barX, ly, barW, barH, 40, 10, 15, 255)
    local hpW = floor(barW * (player.hp / player.maxHp))
    local hpR = player.hp <= player.maxHp * 0.3 and 255 or 50
    local hpG = player.hp <= player.maxHp * 0.3 and 50 or 200
    bridge.drawRect(barX, ly, hpW, barH, hpR, hpG, 50, 255)
    bridge.drawText(player.hp .. "/" .. player.maxHp, barX + barW + 4, ly, 200, 200, 200, 255)

    -- Sanity bar
    local sanX = barX + barW + 55
    bridge.drawText("SAN:", sanX, ly, K.C.sanity[1], K.C.sanity[2], K.C.sanity[3], 255)
    local sanBarX = sanX + 32
    bridge.drawRect(sanBarX, ly, 60, barH, 20, 20, 40, 255)
    local sanW = floor(60 * (player.sanity / 100))
    local sanR = player.sanity <= 25 and 200 or K.C.sanity[1]
    local sanG = player.sanity <= 25 and 50 or K.C.sanity[2]
    bridge.drawRect(sanBarX, ly, sanW, barH, sanR, sanG, K.C.sanity[3], 255)
    bridge.drawText(player.sanity .. "%", sanBarX + 63, ly, K.C.sanity[1], K.C.sanity[2], K.C.sanity[3], 255)

    ly = ly + 14

    -- Row 3: Stats
    bridge.drawText("STR:" .. player.str .. " DEF:" .. player.def .. " DMG:" .. player.dmgMin .. "-" .. player.dmgMax, col1, ly, 180, 160, 170, 255)

    local o2X = 260
    bridge.drawText("O2:", o2X, ly, K.C.oxygen[1], K.C.oxygen[2], K.C.oxygen[3], 255)
    bridge.drawText(player.oxygen .. "%", o2X + 24, ly, K.C.oxygen[1], K.C.oxygen[2], K.C.oxygen[3], 255)

    ly = ly + 14

    -- Row 4: Items
    bridge.drawText("ARM:" .. player.armor .. " CRIT:<=" .. player.critBonus, col1, ly, 160, 150, 170, 255)
    bridge.drawText("XP:" .. player.xp .. "/" .. player.xpNext, col1 + 160, ly, K.C.xp[1], K.C.xp[2], K.C.xp[3], 255)

    ly = ly + 14

    -- Row 5
    bridge.drawText("Medkits:" .. player.medkits, col1, ly, 255, 100, 100, 255)
    bridge.drawText("Keys:" .. player.keycards, col1 + 80, ly, K.C.keycard[1], K.C.keycard[2], K.C.keycard[3], 255)
    bridge.drawText("Cells:" .. player.cells .. "/" .. player.cellsNeeded, col1 + 140, ly, K.C.cell[1], K.C.cell[2], K.C.cell[3], 255)
    bridge.drawText("Kills:" .. player.kills, col1 + 260, ly, 200, 140, 140, 255)

    -- Message log
    local msgX = W/2 + 20
    local msgY = hudY + 8
    bridge.drawText("-- Transmission Log --", msgX, msgY, 100, 70, 90, 255)
    for i, msg in ipairs(game.messages) do
        local alpha = max(80, 255 - i * 25)
        bridge.drawText(msg.text, msgX, msgY + i * 13, msg.r, msg.g, msg.b, alpha)
        if msgY + i * 13 > H - 5 then break end
    end
end

function M.drawGame()
    local sx, sy = 0, 0
    if game.shakeTimer > 0 then
        sx = floor((rand() - 0.5) * game.shakeIntensity * 2)
        sy = floor((rand() - 0.5) * game.shakeIntensity * 2)
    end

    bridge.drawRect(0, 0, W, H, K.C.void[1], K.C.void[2], K.C.void[3], 255)

    if game.state == "title" then drawTitle(); return end
    if game.state == "won" then drawWon(); return end
    if game.state == "mindmarr" then drawMindmarr(); return end

    local camOX = floor(W/2 - player.x * K.TS - K.TS/2)
    local camOY = floor(H * 0.4 - player.y * K.TS - K.TS/2)
    local mapAreaH = floor(H * 0.65)

    -- Map tiles
    local startTX = max(1, floor(-camOX / K.TS) - 1)
    local endTX = min(K.MW, floor((-camOX + W) / K.TS) + 2)
    local startTY = max(1, floor(-camOY / K.TS) - 1)
    local endTY = min(K.MH, floor((-camOY + mapAreaH) / K.TS) + 2)

    for ty = startTY, endTY do
        for tx = startTX, endTX do
            drawTile(sx, sy, tx, ty)
        end
    end

    -- Shuttle/airlock
    if util.isVisible(state.shuttle.x, state.shuttle.y) then
        local stX = camOX + state.shuttle.x * K.TS + sx
        local stY = camOY + state.shuttle.y * K.TS + sy
        if game.sector == game.maxSectors then
            local glow = sin(game.pulseTimer * 3) * 20 + 220
            bridge.drawRect(stX + 2, stY + 2, K.TS - 4, K.TS - 4, floor(glow), floor(glow * 0.85), 40, 255)
            bridge.drawRect(stX + 5, stY + 5, K.TS - 10, K.TS - 10, 200, 180, 60, 255)
            bridge.drawText("^", stX + 8, stY + 4, 255, 255, 200, 255)
        else
            bridge.drawRect(stX + 4, stY + 4, K.TS - 8, K.TS - 8, K.C.shuttle[1], K.C.shuttle[2], K.C.shuttle[3], 255)
            bridge.drawText(">", stX + 8, stY + 5, 255, 240, 180, 255)
        end
    elseif util.isSeen(state.shuttle.x, state.shuttle.y) then
        local stX = camOX + state.shuttle.x * K.TS + sx
        local stY = camOY + state.shuttle.y * K.TS + sy
        bridge.drawRect(stX + 4, stY + 4, K.TS - 8, K.TS - 8, 60, 50, 25, 255)
    end

    -- Elevator (revealed state)
    if state.elevator.revealed and util.isVisible(state.elevator.x, state.elevator.y) then
        local ex = camOX + state.elevator.x * K.TS + sx
        local ey = camOY + state.elevator.y * K.TS + sy
        local pulse = sin(game.pulseTimer * 3) * 15 + 100
        bridge.drawRect(ex + 3, ey + 3, K.TS - 6, K.TS - 6, floor(pulse), floor(pulse * 2.2), 255, 255)
        bridge.drawRect(ex + 6, ey + 6, K.TS - 12, K.TS - 12, K.C.elevator[1], K.C.elevator[2], K.C.elevator[3], 255)
        bridge.drawText("E", ex + 8, ey + 6, 255, 255, 255, 255)
    elseif state.elevator.revealed and util.isSeen(state.elevator.x, state.elevator.y) then
        local ex = camOX + state.elevator.x * K.TS + sx
        local ey = camOY + state.elevator.y * K.TS + sy
        bridge.drawRect(ex + 6, ey + 6, K.TS - 12, K.TS - 12, 40, 80, 100, 255)
    end

    -- Items
    for _, it in ipairs(state.items) do
        if util.isVisible(it.x, it.y) then
            local ix = camOX + it.x * K.TS + sx
            local iy = camOY + it.y * K.TS + sy
            if it.type == "supply" then
                bridge.drawRect(ix + 7, iy + 7, 10, 10, K.C.supply[1], K.C.supply[2], K.C.supply[3], 255)
                bridge.drawRect(ix + 9, iy + 9, 5, 5, 140, 255, 180, 255)
            elseif it.type == "medkit" then
                bridge.drawRect(ix + 6, iy + 6, 12, 12, 255, 80, 80, 255)
                bridge.drawRect(ix + 10, iy + 7, 4, 10, 255, 255, 255, 255)
                bridge.drawRect(ix + 7, iy + 10, 10, 4, 255, 255, 255, 255)
            elseif it.type == "cell" then
                local cg = sin(game.pulseTimer * 4) * 40 + 180
                bridge.drawRect(ix + 5, iy + 4, 14, 16, floor(cg), 50, floor(cg * 1.1), 255)
                bridge.drawRect(ix + 8, iy + 7, 8, 10, 220, 80, 240, 255)
            elseif it.type == "oxygen" then
                bridge.drawRect(ix + 7, iy + 5, 10, 14, K.C.oxygen[1], K.C.oxygen[2], K.C.oxygen[3], 255)
                bridge.drawRect(ix + 9, iy + 3, 6, 4, 60, 160, 180, 255)
            elseif it.type == "keycard" then
                local glow = sin(game.pulseTimer * 4) * 20 + 220
                bridge.drawRect(ix + 4, iy + 5, 16, 14, floor(glow), floor(glow * 0.8), 50, 255)
                bridge.drawRect(ix + 6, iy + 7, 12, 10, K.C.keycard[1], K.C.keycard[2], K.C.keycard[3], 255)
                bridge.drawRect(ix + 8, iy + 11, 3, 3, 80, 60, 20, 255)
            end
        end
    end

    -- Enemies
    for _, e in ipairs(state.enemies) do
        if e.alive and util.isVisible(e.x, e.y) then
            local ex = camOX + e.x * K.TS + sx
            local ey = camOY + e.y * K.TS + sy
            
            -- Try to draw enemy sprite (if spriteKey exists and sprite loads)
            local drewSprite = false
            if e.spriteKey then
                drewSprite = assets.tryDrawSprite(e.spriteKey, ex, ey)
            end
            
            if not drewSprite then
                -- Fallback: procedural enemy rendering
                local aura = sin(game.pulseTimer * 5 + e.x) * 15
                bridge.drawRect(ex + 2, ey + 2, K.TS - 4, K.TS - 4,
                    min(255, e.color[1] + floor(aura)), min(255, e.color[2]), min(255, e.color[3]), 255)
                bridge.drawRect(ex + 5, ey + 5, K.TS - 10, K.TS - 10,
                    min(255, e.color[1]+30), min(255, e.color[2]+20), min(255, e.color[3]+20), 255)
            end
            
            -- HP bar (always show if damaged)
            if e.hp < e.maxHp then
                local bW = K.TS - 4
                local hpFrac = e.hp / e.maxHp
                bridge.drawRect(ex + 2, ey - 3, bW, 3, 40, 10, 15, 200)
                bridge.drawRect(ex + 2, ey - 3, floor(bW * hpFrac), 3, 255, 40, 50, 255)
            end
        end
    end

    -- Player
    if game.state ~= "dead" then
        local px_draw = camOX + player.x * K.TS + sx
        local py_draw = camOY + player.y * K.TS + sy
        
        -- Try to draw sprite at natural size (16x16), auto-centered in 24x24 tile
        local drewSprite = assets.tryDrawSprite("player", px_draw, py_draw)
        
        if not drewSprite then
            -- Fallback: procedural player rendering
            bridge.drawRect(px_draw + 2, py_draw + 2, K.TS - 4, K.TS - 4, K.C.player[1], K.C.player[2], K.C.player[3], 255)
            bridge.drawRect(px_draw + 5, py_draw + 5, K.TS - 10, K.TS - 10, 100, 220, 255, 255)
            bridge.drawRect(px_draw + 7, py_draw + 6, 10, 5, 20, 60, 80, 255)
            bridge.drawRect(px_draw + 8, py_draw + 7, 8, 3, 40, 140, 180, 255)
        end
    end

    -- Particles
    for _, p in ipairs(game.particles) do
        local alpha = floor(255 * (p.life / p.maxLife))
        if alpha > 0 then
            local ppx = camOX + p.x + sx
            local ppy = camOY + p.y + sy
            if ppx > -10 and ppx < W + 10 and ppy > -10 and ppy < mapAreaH + 10 then
                bridge.drawRect(ppx - p.size/2, ppy - p.size/2, p.size, p.size, p.r, p.g, p.b, alpha)
            end
        end
    end

    -- HUD
    drawHUD(mapAreaH)

    -- Level up overlay
    if game.state == "levelup" then
        bridge.drawRect(W/4, H/4, W/2, H/2, 10, 8, 20, 240)
        bridge.drawRect(W/4, H/4, W/2, 2, 60, 200, 255, 255)
        bridge.drawText("ADAPT — Choose an upgrade:", W/4 + 20, H/4 + 12, 100, 230, 255, 255)
        for i, choice in ipairs(K.levelChoices) do
            local y = H/4 + 30 + (i-1) * 22
            bridge.drawRect(W/4 + 15, y, W/2 - 30, 18, 25, 18, 40, 200)
            bridge.drawText(i .. ") " .. choice.name, W/4 + 22, y + 2, 200, 220, 240, 255)
        end
    end

    -- Death overlay
    if game.state == "dead" then
        bridge.drawRect(W/4, H/3, W/2, H/4, 25, 5, 8, 230)
        bridge.drawRect(W/4, H/3, W/2, 2, 255, 40, 50, 255)
        bridge.drawText("SIGNAL LOST", W/4 + 55, H/3 + 15, 255, 50, 60, 255)
        bridge.drawText("Sector: " .. game.sector .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4 + 15, H/3 + 35, 200, 200, 200, 255)
        local score = player.kills * 10 + game.sector * 50
        bridge.drawText("Score: " .. score, W/4 + 60, H/3 + 52, 255, 200, 80, 255)
        bridge.drawText("PRESS SPACE TO TRY AGAIN", W/4 + 25, H/3 + 75, 180, 180, 180, 255)
    end
end

return M-- mapgen.lua
-- MINDMARR: Map generation

local rand, floor = math.random, math.floor
local max, min = math.max, math.min

local state = require("state")
local K = require("constants")
local util = require("util")

local game = state.game
local player = state.player

local M = {}

local function carveRoom(rx, ry, rw, rh)
    for y = ry, ry + rh - 1 do
        for x = rx, rx + rw - 1 do
            util.setTile(x, y, 0)
        end
    end
    return {x = rx, y = ry, w = rw, h = rh,
            cx = floor(rx + rw/2), cy = floor(ry + rh/2)}
end

local function carveCorridor(x1, y1, x2, y2)
    local x, y = x1, y1
    while x ~= x2 do
        util.setTile(x, y, 0)
        x = x + (x2 > x and 1 or -1)
    end
    while y ~= y2 do
        util.setTile(x, y, 0)
        y = y + (y2 > y and 1 or -1)
    end
end

function M.generateMap()
    -- Reset map table in-place
    local map = state.map
    for k in pairs(map) do map[k] = nil end

    for y = 1, K.MH do
        map[y] = {}
        for x = 1, K.MW do
            map[y][x] = 1
        end
    end

    local rooms = {}
    local attempts = 0
    local numRooms = rand(6, 9) + floor(game.sector / 2)

    while #rooms < numRooms and attempts < 200 do
        attempts = attempts + 1
        local rw = rand(3, 7)
        local rh = rand(3, 5)
        local rx = rand(2, K.MW - rw - 1)
        local ry = rand(2, K.MH - rh - 1)

        local ok = true
        for _, r in ipairs(rooms) do
            if rx < r.x + r.w + 1 and rx + rw + 1 > r.x and
               ry < r.y + r.h + 1 and ry + rh + 1 > r.y then
                ok = false; break
            end
        end

        if ok then
            local room = carveRoom(rx, ry, rw, rh)
            if #rooms > 0 then
                local prev = rooms[#rooms]
                if rand() < 0.5 then
                    carveCorridor(prev.cx, prev.cy, room.cx, prev.cy)
                    carveCorridor(room.cx, prev.cy, room.cx, room.cy)
                else
                    carveCorridor(prev.cx, prev.cy, prev.cx, room.cy)
                    carveCorridor(prev.cx, room.cy, room.cx, room.cy)
                end
            end
            rooms[#rooms+1] = room
        end
    end

    for i = 1, floor(#rooms / 3) do
        local a = rooms[rand(1, #rooms)]
        local b = rooms[rand(1, #rooms)]
        if a ~= b then carveCorridor(a.cx, a.cy, b.cx, b.cy) end
    end

    return rooms
end

-- Infected templates
function M.infectedTemplate(sector)
    local templates = {
        {name="Scientist",    glyph="S", spriteKey="enemy_scientist", hp=7,  str=30, def=15, dmgMin=1, dmgMax=3, xp=5,  color={180,100,120}},
        {name="Technician",   glyph="T", spriteKey="enemy_scientist", hp=10, str=40, def=20, dmgMin=2, dmgMax=4, xp=8,  color={160,80,100}},
        {name="Security",     glyph="G", spriteKey="enemy_scientist", hp=14, str=50, def=25, dmgMin=2, dmgMax=5, xp=12, color={200,70,90}},
        {name="Commander",    glyph="C", spriteKey="enemy_scientist", hp=20, str=55, def=30, dmgMin=3, dmgMax=7, xp=20, color={220,50,70}},
        {name="MarsSpawn",    glyph="M", hp=16, str=60, def=45, dmgMin=3, dmgMax=6, xp=25, color={200,40,60}},
        {name="Hivemind",     glyph="H", hp=35, str=65, def=30, dmgMin=5, dmgMax=10,xp=40, color={180,30,80}},
        {name="MINDMARR",     glyph="@", hp=50, str=75, def=40, dmgMin=6, dmgMax=12,xp=60, color={255,20,50}},
    }

    local maxIdx = min(#templates, 2 + floor(sector / 2))
    local minIdx = max(1, maxIdx - 3)
    local t = templates[rand(minIdx, maxIdx)]

    local scale = 1.0 + (sector - 1) * 0.12
    return {
        name = t.name,
        glyph = t.glyph,
        spriteKey = t.spriteKey,
        hp = floor(t.hp * scale),
        maxHp = floor(t.hp * scale),
        str = min(90, floor(t.str + sector * 2)),
        def = min(80, floor(t.def + sector)),
        dmgMin = t.dmgMin + floor(sector / 3),
        dmgMax = t.dmgMax + floor(sector / 3),
        xp = floor(t.xp * scale),
        color = t.color,
        alive = true,
        sayTimer = 0,
        lastSaid = "",
    }
end

function M.populateFloor(rooms)
    -- Clear enemies/items in-place
    local enemies = state.enemies
    for k in pairs(enemies) do enemies[k] = nil end
    local items = state.items
    for k in pairs(items) do items[k] = nil end

    player.x = rooms[1].cx
    player.y = rooms[1].cy

    state.shuttle.x = rooms[#rooms].cx
    state.shuttle.y = rooms[#rooms].cy

    -- Place elevator in a random room (not start or end)
    if #rooms >= 3 then
        local elevRoom = rooms[rand(2, #rooms - 1)]
        state.elevator.x = elevRoom.cx
        state.elevator.y = elevRoom.cy
        state.elevator.revealed = false
    end

    -- Enemies
    local numEnemies = 3 + game.sector * 2 + rand(0, 2)
    for i = 1, numEnemies do
        local room = rooms[rand(2, #rooms)]
        local ex = rand(room.x, room.x + room.w - 1)
        local ey = rand(room.y, room.y + room.h - 1)
        if not (ex == player.x and ey == player.y) and util.tileAt(ex, ey) == 0 then
            local e = M.infectedTemplate(game.sector)
            e.x = ex
            e.y = ey
            enemies[#enemies+1] = e
        end
    end

    -- Items
    for i = 2, #rooms do
        local room = rooms[i]
        if rand() < 0.35 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "supply",
                amount = rand(2, 6) + game.sector,
            }
        end
        if rand() < 0.2 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "medkit",
            }
        end
        if rand() < 0.15 and player.cells < player.cellsNeeded then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "cell",
            }
        end
        if rand() < 0.2 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "oxygen",
            }
        end
        -- Keycard spawn (rare, starts appearing sector 2+)
        if game.sector >= 2 and rand() < 0.12 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "keycard",
            }
        end
    end
end

return M-- state.lua
-- MINDMARR: Shared mutable game state

local game = {
    state = "title",
    sector = 1,
    maxSectors = 7,
    turn = 0,
    messages = {},
    maxMessages = 6,
    shakeTimer = 0,
    shakeIntensity = 0,
    particles = {},
    camX = 0, camY = 0,
    inputCooldown = 0,
    keyWasDown = {},
    marsWhisperTimer = 0,
    pulseTimer = 0,
    won = false,
}

local player = {
    x = 0, y = 0,
    hp = 30, maxHp = 30,
    str = 55,
    def = 40,
    dmgMin = 2, dmgMax = 5,
    armor = 0,
    xp = 0,
    xpNext = 20,
    level = 1,
    sanity = 100,
    oxygen = 100,
    medkits = 1,
    cells = 0,
    cellsNeeded = 3,
    kills = 0,
    critBonus = 5,
    seen = {},
    keycards = 0,
}

local map = {}
local enemies = {}
local items = {}
local shuttle = {x = 0, y = 0}
local elevator = {x = 0, y = 0, revealed = false}

return {
    game = game,
    player = player,
    map = map,
    enemies = enemies,
    items = items,
    shuttle = shuttle,
    elevator = elevator,
}-- util.lua
-- MINDMARR: Utility functions

local sin, cos, rand, floor = math.sin, math.cos, math.random, math.floor
local abs, sqrt, max, min = math.abs, math.sqrt, math.max, math.min

local state = require("state")
local K = require("constants")

local game = state.game
local player = state.player

local M = {}

function M.spawnParticles(x, y, count, r, g, b, speed, life)
    for i = 1, count do
        local a = rand() * math.pi * 2
        local s = rand() * speed + speed * 0.2
        game.particles[#game.particles+1] = {
            x = x, y = y,
            vx = cos(a) * s, vy = sin(a) * s,
            life = life * (0.4 + rand() * 0.6),
            maxLife = life,
            r = r, g = g, b = b,
            size = rand() < 0.3 and 3 or 2,
        }
    end
end

function M.screenShake(intensity, duration)
    game.shakeTimer = duration
    game.shakeIntensity = intensity
end

function M.addMessage(text, r, g, b)
    table.insert(game.messages, 1, {text = text, r = r or 200, g = g or 200, b = b or 200, age = 0})
    if #game.messages > game.maxMessages then
        table.remove(game.messages)
    end
end

function M.d100()
    return rand(1, 100)
end

-- FOV
function M.computeFOV()
    local radius = 6
    for a = 0, 359, 2 do
        local rad = a * math.pi / 180
        local dx = cos(rad)
        local dy = sin(rad)
        local fx, fy = player.x + 0.5, player.y + 0.5
        for d = 0, radius do
            local tx, ty = floor(fx), floor(fy)
            if tx < 1 or tx > K.MW or ty < 1 or ty > K.MH then break end
            player.seen[ty * 1000 + tx] = 2
            if M.tileAt(tx, ty) == 1 then break end
            fx = fx + dx * 0.5
            fy = fy + dy * 0.5
        end
    end
end

function M.dimFOV()
    for k, v in pairs(player.seen) do
        if v == 2 then player.seen[k] = 1 end
    end
end

function M.isVisible(x, y)
    return (player.seen[y * 1000 + x] or 0) == 2
end

function M.isSeen(x, y)
    return (player.seen[y * 1000 + x] or 0) >= 1
end

-- Tile helpers (need map access)
function M.tileAt(x, y)
    if x < 1 or x > K.MW or y < 1 or y > K.MH then return 1 end
    return state.map[y][x]
end

function M.setTile(x, y, v)
    if x >= 1 and x <= K.MW and y >= 1 and y <= K.MH then
        state.map[y][x] = v
    end
end

function M.enemyAt(x, y)
    for _, e in ipairs(state.enemies) do
        if e.alive and e.x == x and e.y == y then return e end
    end
    return nil
end

-- Mars whisper
function M.marsWhisper()
    if player.sanity > 0 then
        local drain = rand(1, 3)
        player.sanity = max(0, player.sanity - drain)
        local w = K.marsWhispers[rand(1, #K.marsWhispers)]
        M.addMessage(w, K.C.whisper[1], K.C.whisper[2], K.C.whisper[3])
        if player.sanity <= 0 then
            game.state = "mindmarr"
            M.addMessage("Your lips move on their own...", 255, 40, 60)
            M.addMessage("You whisper: \"mindmarr\"", 255, 20, 40)
            M.addMessage("It's the last word you ever say.", 255, 0, 0)
            M.screenShake(10, 0.6)
            M.spawnParticles(player.x * K.TS + K.TS/2, player.y * K.TS + K.TS/2, 50, 200, 30, 60, 150, 1.2)
        end
    end
end

return M#version 100
precision mediump float;
varying vec2 v_uv;
varying vec4 v_color;
uniform sampler2D u_texture;
uniform float u_vertexColorMix;
uniform float u_colorQuantization;
void main() {
    vec4 texColor = texture2D(u_texture, v_uv);
    // u_vertexColorMix = 0.0 -> full vertex color modulation (original behavior)
    // u_vertexColorMix = 0.0 -> 10% vertex color, 90% white (baked lighting use case)
    vec4 modulation = mix(v_color, vec4(1.0, 1.0, 1.0, v_color.a), u_vertexColorMix * 10.0);
    vec4 baseColor = texColor * modulation;
    
    // Apply color quantization (banding effect for retro look)
    if (u_colorQuantization > 0.0) {
        float levels = pow(2.0, u_colorQuantization);
        baseColor.rgb = floor(baseColor.rgb * levels) / levels;
    }
    
    gl_FragColor = baseColor;
}#version 100
precision mediump float;
attribute vec3 a_position;
attribute vec2 a_uv;
attribute vec4 a_color;
uniform mat4 u_projection;
varying vec2 v_uv;
varying vec4 v_color;
void main() {
    gl_Position = u_projection * vec4(a_position, 1.0);
    v_uv = a_uv;
    v_color = a_color;
}#version 100
precision mediump float;

varying vec2 v_uv;
varying vec4 v_color;

uniform sampler2D u_texture;
uniform float u_vertexColorMix;
uniform float u_colorQuantization;

// RGB to HSL conversion logic
vec3 rgb2hsl(vec3 c) {
    float maxC = max(max(c.r, c.g), c.b);
    float minC = min(min(c.r, c.g), c.b);
    float l = (maxC + minC) * 0.5;
    float s = 0.0;
    float h = 0.0;
    
    if (maxC != minC) {
        float d = maxC - minC;
        s = l > 0.5 ? d / (2.0 - maxC - minC) : d / (maxC + minC);
        
        if (maxC == c.r) {
            h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
        } else if (maxC == c.g) {
            h = (c.b - c.r) / d + 2.0;
        } else {
            h = (c.r - c.g) / d + 4.0;
        }
        h /= 6.0;
    }
    
    return vec3(h, s, l);
}

// Helper for HSL to RGB
float hue2rgb(float p, float q, float t) {
    if (t < 0.0) t += 1.0;
    if (t > 1.0) t -= 1.0;
    if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;
    if (t < 0.5) return q;
    if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
    return p;
}

// HSL to RGB conversion logic
vec3 hsl2rgb(vec3 hsl) {
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;
    
    if (s == 0.0) {
        return vec3(l);
    }
    
    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
    float p = 2.0 * l - q;
    
    return vec3(
        hue2rgb(p, q, h + 1.0 / 3.0),
        hue2rgb(p, q, h),
        hue2rgb(p, q, h - 1.0 / 3.0)
    );
}

// RS2-Style: Quantize to 16-bit HSL
// 6-bit hue (0-63), 3-bit sat (0-7), 7-bit lightness (0-127)
vec3 quantizeHSL16(vec3 rgb) {
    vec3 hsl = rgb2hsl(rgb);
    
    float h = floor(hsl.x * 63.0 + 0.5) / 63.0; 
    float s = floor(hsl.y * 7.0 + 0.5) / 7.0;   
    float l = floor(hsl.z * 127.0 + 0.5) / 127.0; 
    
    return hsl2rgb(vec3(h, s, l));
}

void main() {
    vec4 texColor = texture2D(u_texture, v_uv);
    
    // VECTORIZED OVERLAY BLEND
    // Calculates both possible outcomes for the overlay blend simultaneously
    vec3 low = 2.0 * texColor.rgb * v_color.rgb;
    vec3 high = 1.0 - 2.0 * (1.0 - texColor.rgb) * (1.0 - v_color.rgb);
    
    // Uses step() to choose between 'low' and 'high' per-channel, mimicking RS2 software rasterizer
    vec3 overlay = mix(low, high, step(0.5, v_color.rgb));
    
    vec3 finalRGB;
    
    // VERTEX COLOR MIXING LOGIC
    if (u_vertexColorMix < 0.5) {
        float factor = u_vertexColorMix * 2.0;
        finalRGB = mix(texColor.rgb, overlay, factor);
    } else {
        float factor = (u_vertexColorMix - 0.5) * 2.0;
        finalRGB = mix(overlay, v_color.rgb, factor);
    }
    
    float finalAlpha = texColor.a * v_color.a;

    // PASS 1: 16-bit HSL palette simulation
    finalRGB = quantizeHSL16(finalRGB);

    // PASS 2: Optional RGB banding (Posterization)
    if (u_colorQuantization > 0.0) {
        float levels = exp2(u_colorQuantization); 
        finalRGB = floor(finalRGB * levels + 0.5) / levels;
    }
    
    gl_FragColor = vec4(finalRGB, finalAlpha);
}#version 100
precision mediump float;
attribute vec3 a_position;
attribute vec2 a_uv;
attribute vec4 a_color;
uniform mat4 u_projection;
varying vec2 v_uv;
varying vec4 v_color;
void main() {
    gl_Position = u_projection * vec4(a_position, 1.0);
    v_uv = a_uv;
    v_color = a_color;
}info face="CustomFont" size=12 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1
common lineHeight=12 base=12 scaleW=160 scaleH=192 pages=1 packed=0
page id=0 file="Content/mbf_big_00.png"
chars count=38
char id=65   x=10     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=66   x=20     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=67   x=30     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=68   x=40     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=69   x=50     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=70   x=60     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=71   x=70     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=72   x=80     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=73   x=90     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=74   x=100     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=75   x=110     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=76   x=100     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=77   x=130     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=78   x=140     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=79   x=150     y=48     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=80   x=0     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=81   x=10     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=82   x=20     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=84   x=30     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=85   x=40     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=86   x=50     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=87   x=60     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=88   x=70     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=89   x=90     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=90   x=100     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=91   x=110     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=92   x=120     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=93   x=130     y=60     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=48   x=0     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=49   x=10     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=50   x=20     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=51   x=30     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=52   x=40     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=53   x=50     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=54   x=60     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=55   x=70     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=56   x=80     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
char id=57   x=90     y=36     width=10     height=12     xoffset=0     yoffset=0    xadvance=10     page=0  chnl=0
kernings count=0
info face="Droid Sans" size=17 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1
common lineHeight=20 base=18 scaleW=256 scaleH=128 pages=1 packed=0
page id=0 file="default.png"
chars count=96
char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=16    xadvance=4     page=0  chnl=0 
char id=124   x=0     y=0     width=6     height=20     xoffset=1     yoffset=3    xadvance=9     page=0  chnl=0 
char id=106   x=6     y=0     width=9     height=20     xoffset=-4     yoffset=3    xadvance=4     page=0  chnl=0 
char id=81   x=15     y=0     width=15     height=19     xoffset=-2     yoffset=3    xadvance=12     page=0  chnl=0 
char id=74   x=30     y=0     width=11     height=19     xoffset=-5     yoffset=3    xadvance=4     page=0  chnl=0 
char id=125   x=41     y=0     width=10     height=18     xoffset=-3     yoffset=3    xadvance=6     page=0  chnl=0 
char id=123   x=51     y=0     width=10     height=18     xoffset=-3     yoffset=3    xadvance=6     page=0  chnl=0 
char id=93   x=61     y=0     width=8     height=18     xoffset=-3     yoffset=3    xadvance=5     page=0  chnl=0 
char id=91   x=69     y=0     width=8     height=18     xoffset=-2     yoffset=3    xadvance=5     page=0  chnl=0 
char id=41   x=77     y=0     width=9     height=18     xoffset=-3     yoffset=3    xadvance=5     page=0  chnl=0 
char id=40   x=86     y=0     width=9     height=18     xoffset=-3     yoffset=3    xadvance=5     page=0  chnl=0 
char id=64   x=95     y=0     width=18     height=17     xoffset=-3     yoffset=3    xadvance=14     page=0  chnl=0 
char id=121   x=113     y=0     width=13     height=17     xoffset=-3     yoffset=6    xadvance=8     page=0  chnl=0 
char id=113   x=126     y=0     width=13     height=17     xoffset=-3     yoffset=6    xadvance=9     page=0  chnl=0 
char id=112   x=139     y=0     width=13     height=17     xoffset=-2     yoffset=6    xadvance=9     page=0  chnl=0 
char id=103   x=152     y=0     width=13     height=17     xoffset=-3     yoffset=6    xadvance=8     page=0  chnl=0 
char id=38   x=165     y=0     width=16     height=16     xoffset=-3     yoffset=3    xadvance=11     page=0  chnl=0 
char id=37   x=181     y=0     width=18     height=16     xoffset=-3     yoffset=3    xadvance=14     page=0  chnl=0 
char id=36   x=199     y=0     width=12     height=16     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=63   x=211     y=0     width=11     height=16     xoffset=-3     yoffset=3    xadvance=7     page=0  chnl=0 
char id=33   x=222     y=0     width=7     height=16     xoffset=-2     yoffset=3    xadvance=4     page=0  chnl=0 
char id=48   x=229     y=0     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=57   x=242     y=0     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=56   x=0     y=20     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=54   x=13     y=20     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=53   x=26     y=20     width=12     height=16     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=51   x=38     y=20     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=100   x=51     y=20     width=13     height=16     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=98   x=64     y=20     width=13     height=16     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=85   x=77     y=20     width=14     height=16     xoffset=-2     yoffset=3    xadvance=11     page=0  chnl=0 
char id=83   x=91     y=20     width=13     height=16     xoffset=-3     yoffset=3    xadvance=8     page=0  chnl=0 
char id=79   x=104     y=20     width=15     height=16     xoffset=-2     yoffset=3    xadvance=12     page=0  chnl=0 
char id=71   x=119     y=20     width=14     height=16     xoffset=-2     yoffset=3    xadvance=11     page=0  chnl=0 
char id=67   x=133     y=20     width=13     height=16     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0 
char id=127   x=146     y=20     width=12     height=15     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0 
char id=35   x=158     y=20     width=15     height=15     xoffset=-3     yoffset=3    xadvance=10     page=0  chnl=0 
char id=92   x=173     y=20     width=11     height=15     xoffset=-3     yoffset=3    xadvance=6     page=0  chnl=0 
char id=47   x=184     y=20     width=11     height=15     xoffset=-3     yoffset=3    xadvance=6     page=0  chnl=0 
char id=59   x=195     y=20     width=8     height=15     xoffset=-3     yoffset=6    xadvance=4     page=0  chnl=0 
char id=55   x=203     y=20     width=13     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=52   x=216     y=20     width=14     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=50   x=230     y=20     width=13     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=49   x=243     y=20     width=9     height=15     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=116   x=0     y=36     width=10     height=15     xoffset=-3     yoffset=4    xadvance=5     page=0  chnl=0 
char id=108   x=10     y=36     width=6     height=15     xoffset=-2     yoffset=3    xadvance=4     page=0  chnl=0 
char id=107   x=16     y=36     width=12     height=15     xoffset=-2     yoffset=3    xadvance=8     page=0  chnl=0 
char id=105   x=28     y=36     width=7     height=15     xoffset=-2     yoffset=3    xadvance=4     page=0  chnl=0 
char id=104   x=35     y=36     width=12     height=15     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0 
char id=102   x=47     y=36     width=11     height=15     xoffset=-3     yoffset=3    xadvance=5     page=0  chnl=0 
char id=90   x=58     y=36     width=13     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=89   x=71     y=36     width=13     height=15     xoffset=-3     yoffset=3    xadvance=8     page=0  chnl=0 
char id=88   x=84     y=36     width=14     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=87   x=98     y=36     width=19     height=15     xoffset=-3     yoffset=3    xadvance=15     page=0  chnl=0 
char id=86   x=117     y=36     width=14     height=15     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=84   x=131     y=36     width=13     height=15     xoffset=-3     yoffset=3    xadvance=8     page=0  chnl=0 
char id=82   x=144     y=36     width=13     height=15     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0 
char id=80   x=157     y=36     width=12     height=15     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=78   x=169     y=36     width=14     height=15     xoffset=-2     yoffset=3    xadvance=12     page=0  chnl=0 
char id=77   x=183     y=36     width=17     height=15     xoffset=-2     yoffset=3    xadvance=14     page=0  chnl=0 
char id=76   x=200     y=36     width=11     height=15     xoffset=-2     yoffset=3    xadvance=8     page=0  chnl=0 
char id=75   x=211     y=36     width=13     height=15     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0 
char id=73   x=224     y=36     width=10     height=15     xoffset=-3     yoffset=3    xadvance=5     page=0  chnl=0 
char id=72   x=234     y=36     width=14     height=15     xoffset=-2     yoffset=3    xadvance=11     page=0  chnl=0 
char id=70   x=0     y=51     width=11     height=15     xoffset=-2     yoffset=3    xadvance=8     page=0  chnl=0 
char id=69   x=11     y=51     width=11     height=15     xoffset=-2     yoffset=3    xadvance=8     page=0  chnl=0 
char id=68   x=22     y=51     width=14     height=15     xoffset=-2     yoffset=3    xadvance=11     page=0  chnl=0 
char id=66   x=36     y=51     width=13     height=15     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0 
char id=65   x=49     y=51     width=15     height=15     xoffset=-3     yoffset=3    xadvance=10     page=0  chnl=0 
char id=58   x=64     y=51     width=7     height=13     xoffset=-2     yoffset=6    xadvance=4     page=0  chnl=0 
char id=117   x=71     y=51     width=12     height=13     xoffset=-2     yoffset=6    xadvance=10     page=0  chnl=0 
char id=115   x=83     y=51     width=11     height=13     xoffset=-3     yoffset=6    xadvance=7     page=0  chnl=0 
char id=111   x=94     y=51     width=13     height=13     xoffset=-3     yoffset=6    xadvance=9     page=0  chnl=0 
char id=101   x=107     y=51     width=13     height=13     xoffset=-3     yoffset=6    xadvance=9     page=0  chnl=0 
char id=99   x=120     y=51     width=12     height=13     xoffset=-3     yoffset=6    xadvance=7     page=0  chnl=0 
char id=97   x=132     y=51     width=12     height=13     xoffset=-3     yoffset=6    xadvance=9     page=0  chnl=0 
char id=60   x=144     y=51     width=13     height=12     xoffset=-3     yoffset=5    xadvance=9     page=0  chnl=0 
char id=122   x=157     y=51     width=11     height=12     xoffset=-3     yoffset=6    xadvance=7     page=0  chnl=0 
char id=120   x=168     y=51     width=13     height=12     xoffset=-3     yoffset=6    xadvance=8     page=0  chnl=0 
char id=119   x=181     y=51     width=17     height=12     xoffset=-3     yoffset=6    xadvance=12     page=0  chnl=0 
char id=118   x=198     y=51     width=13     height=12     xoffset=-3     yoffset=6    xadvance=8     page=0  chnl=0 
char id=114   x=211     y=51     width=10     height=12     xoffset=-2     yoffset=6    xadvance=6     page=0  chnl=0 
char id=110   x=221     y=51     width=12     height=12     xoffset=-2     yoffset=6    xadvance=10     page=0  chnl=0 
char id=109   x=233     y=51     width=17     height=12     xoffset=-2     yoffset=6    xadvance=15     page=0  chnl=0 
char id=94   x=0     y=66     width=13     height=11     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=62   x=13     y=66     width=13     height=11     xoffset=-3     yoffset=5    xadvance=9     page=0  chnl=0 
char id=42   x=26     y=66     width=13     height=10     xoffset=-3     yoffset=3    xadvance=9     page=0  chnl=0 
char id=43   x=39     y=66     width=13     height=10     xoffset=-3     yoffset=6    xadvance=9     page=0  chnl=0 
char id=61   x=52     y=66     width=13     height=8     xoffset=-3     yoffset=7    xadvance=9     page=0  chnl=0 
char id=39   x=65     y=66     width=6     height=8     xoffset=-2     yoffset=3    xadvance=3     page=0  chnl=0 
char id=34   x=71     y=66     width=9     height=8     xoffset=-2     yoffset=3    xadvance=6     page=0  chnl=0 
char id=44   x=80     y=66     width=8     height=7     xoffset=-3     yoffset=14    xadvance=4     page=0  chnl=0 
char id=126   x=88     y=66     width=13     height=6     xoffset=-3     yoffset=8    xadvance=9     page=0  chnl=0 
char id=46   x=101     y=66     width=7     height=6     xoffset=-2     yoffset=13    xadvance=4     page=0  chnl=0 
char id=96   x=108     y=66     width=8     height=6     xoffset=0     yoffset=2    xadvance=9     page=0  chnl=0 
char id=45   x=116     y=66     width=9     height=5     xoffset=-3     yoffset=10    xadvance=5     page=0  chnl=0 
char id=95   x=125     y=66     width=13     height=4     xoffset=-4     yoffset=17    xadvance=6     page=0  chnl=0 
kernings count=-1PNG

   IHDR         kG8  PLTE                                                                              TTT^^^PPP###%%%eeeZZZ<<<(((:::쭭CCCVVVGGG䁁VVVϋjjjwwwӈlllطeee""";;;֎KKKHHH999mmmKKKkkk❝666___vvvyyy555>>>///BBB@@@\\\rrr<HZ   tRNS 	_ >p6N;3/)$&hnA,l&|ux"ѦGKaY\D@WÙQKdUɴd9ګʾ4*Ú!_ߊ0ǱMzvYҷ=ȪlC{TD0ξZɳq`ED6Ĺzso͸tkcRîoL*}^%˩YXBɷ3ձ[@r]Մ*  %QIDATx[wxG׮%Ydɒ-Y,˶$#؀`L{-Ah	I /]jwӴ/WnΛۙ7JӁ	",ρi(CoAni@ۿO֧O
i#XrLqJq`>xSۍ<0yL`(;T| _<>:I|C2.3O8 @E6k#U,3EZ%X$^VL$>2f=~ I{PB^2
Gަ&.K &P%PnK ܽ"I0憺}pۡȩG:ŗ;`YU  p/@uo1[a"I	P.S/D¹sT"a1	qyg~꟎ni"dQ,v!)s_E>9|dƹ|kY$n#VPЬfC;[@<Vç7H֧=*?FK8$^3!`דבcU 2<LTb_c%'brg	fv,kpSwGl&GRdv:?G]%:TihF~g
 3 0x=";RNJ XCLr=B7`NewB/LRiq @Am6X:R  &3M3I3! ⸻R1zsу!K̷77yHV
{>,C5=qe >Q(6}?YkOnFjo	tY|b$̌#DM&% >fk w[e֎ cZr]b$ <$ Yj<7-,FR[׀0`aԸMe  E2 k%ںeI?:p;rv<PuKq^E4%Ò&WSz-yhjPrz j#Ȃ	&\:3C^Mɺ}?M&alp70`Q`=u8@شk-;$5T)Y3ktuLHC3T"dzVݹ0w(F؏1. zKS<Lf2	 [jX; G-7umi1]M)P#j^  ^&oGj
X,0b?Ypc0jQ`yy7#+ ZTx	<ZmgG 7`  @l>?N̅\痽a 4a
`hK_3X?	p^}h]tgr7Lz"@Sd[ZYRǾ!k瞙t4çc/rIJϓpx_ ܏ ɳ]VG]P?Lf+>2e9Wעa"YEh&ôdC{^9R3 w H;mhD|3,q3=eAVg&/
"*qv~⢟b4I^DsVz~Zo $ife ~$FW6lJzMy67`XRRq,ҕf*u^ص 9Vύ'TaUxM<7JbsU+>즢5tɨ욹l
pOȶ(=D4*<䞝~dՙ9v6÷wt@PLsjםJt@|Wp uژK e#JW,HNmvzԃ#5NaK4\qb:ƿzk+õѤ*>b zpR~Ҳ]BIo 0jW<l?IȺ)p3?HS?8h@T0Vi%ek$Sk3XS4YN	˿X맘12,D&+ʕj,(dւh<P+ĸ|N' b8BZb ( + P8j
F@ђ
SuOjL\5 z}y2!zީ3Tch"bc73cVKK5Ÿ#lYT͛eJO(8~
F<0Hp?FϠ ܳxj$ɠZp}vQy~q}atZ{ O_0B<:qn^.Y+֢D3(	 Fh$"++$疒BR8U?CY&+9 ޑ}G!?b|x-ot9ޣM^BGVtgyjd"`4)lhb}Qz"{El+XX̊s*M0$JLdɻe  k*υűMl;ݧ'P]meP)LZHw06שuHD0Y2,+B5IZ1%)3h֥KHR0dIVXL[6 gDIQ bseLYrNb(84cMbG}2fi9Ŋn J	уGҝV/AJLy<1!+EG/H )$،hݵ㻑ѹ0o#?ji% rR0\ J-
^ e(Ʀ&XLi=5Md_@%Sʏ]VT2(++Xy| !+` KbJ8	#,&yQm1.47=ӱH&~.l=s[Ql5Z+G[l*%9	`;ek>׭:܆(7Z8nlGY̔JWYE?rmGI,wRd"VC'Pwk4?{=>QHe}J7.MSd'ڊ[cEhPnge^oAo)-)\%ΰض	yR:&:qncMYORPJ	mB Wv&coR'DRl8^kerq)1r*|U c\P<ɩ>ydr|#I˥j
0,* ~
feSo$y$\jCegr<ҭ2B^X{YlWיt-.F»7\Nlw82%o NoU4&`#s^+Q V7lGX&k;zyǥ}GwŚy;@?bT#.;zfet3h٪uy7}%4 mָ@5'TZ#&ɑVj䚟uX1T@Z`ovTtUħqoTszb<5;_ {ͧ [N
B-5-ÆCΝ< ,Fi@kpkVpDMƋ& 4wPRN7X1T?ZOtH;}̐r1d6~i~DB>ϰYao0b2{*z2UGrAݭ@TmP ``w XcLsVK=#TvƝ.G6ujw ?`}IZhHAgG{nG՚¼Vl$=8e	T{#.zvQKX[*XL)@լQ(ׄQdqLTLhƙI"{6\P`:ZgjmC}VbeI6wLŌg`""	  #{I/gG!bI@B0:Y2! g23ٖ$rOH'-g",4-wN' PfH!>ɍ45J˔:lM \6`vސLheR*@ ?>"FPưE!2{@Z>qڕEpaӀ%{d1U͂sk^2]hս;O&r2tkɆ/qQoÎ:}/_&)Nt6`Ǜ\6"m}&θ|oO/NNԖ_Hya?S|<kdU`ݓjoXDZnQ/%4u'd:#/wSbAMa& rOcSk0] |q0CS pA಍Y̰o1|߀Z~d5e'QLdh%>''>hrׄ18LNH!e4}ʤ'G; |V&R:s&V;.m9V%#+o>_>m	]#Q	E2wBO}a8)ýe]N9e"Us*5Jd"8NL`P @ZE.L^&Pٙ@̰SUlGJ3$&DTvTƄS:Jeb2󝥶XDAbc1M	R2Fc\C,7b(մc)QVơ(-lE3:5Qb,9-Q&L(NBcPʕS4_JɬpKRD.hB&%bgŌrٔPa$r"Rml
%idM?O®4=\S>Qǽo{LKQLkG+P(!#<8R\r@Ҹ@@Њ{YBLYM(7NKzڱolK?IЇ3%c7_@
ye`f 
 i4@73lIB扃H9bJWOK,$8 c ЊzvmFH[:-pF2irOd=^5NZg>5'B8;k	V&3}ò`-MQ'[2̧/z/EE&<)iV;騇TFoO/.pC tط7a4>fE?zi +ES!t}oxV+f`-{'9Ir kh2K<RX[赜Qnm5pj?CªLY⑱y
!C{f
;u6%8ȥ 2@g Ch_ɿ  + 0LF,Rl@	>AsfnKKǳYr<ILFad+36'M5T`L!& fawUp<F	SI	4KǸ? h`H-UOifwR!.=&̲I{ `ߎ/`6k`/%<mPUkEi,ȷ`!pU(鴏;^s
0\]p0 :d*}ᔗǓ!`~x") _<gf~ L\%az ^w$@/${kXe"6G)NpgPbX;"yn$ .[ ~wEj1R ` է 3t  4zCE) (t܁=.`[n iU5"IIWR(fv-L/  LOj4>6 >Q ,`Hdq+8 D
\!C 9f	 Md%2L{qdp0&D>uZ}CO/S' &RO_/% lwp"\ub ԣ^ HMM՞ ?y̏ҋ ?{/X};^&پ^3=ZI/ d8VTx5N ֮6,D8V-\=l |+@{EJ
 K5 `t/#~Fnoq#^i3lc\vG(=gYty422hS R mTS gr(K%H ݷӖO# p-K4xB^E;^()Q`/])_(A( 9 +%p,TWO 5X} CzH Hh^yC+rV+ކZ^ `NJ  !>+ (@)Hcs|v| 9e8I'O#fr٘ȍc,KV.*,5*zpavQr#9;SGKRS;ϝ \n#jA;Cy7_<METZ36_J\vLx<8PCB~<"U(cҘ6	ZL/7=|lIʱqܦD(Evs,j	Q3Wc$!&4|"Rr#&%Rw\[PYVQKl4$-<gvP(s[u,i]LQUE14݈n;O.чc`RWV#Ec&#'G?}zi֮"tLq
?MhLyB,C֒gEdA%}%uTy凑(x#̏Xڧq4HBԆx{3ھ3h}8K<nD+
7oH8vP	;.t:Ԋx0x Ũ_T!Yǁ=H,C_;LT0eZ C/S+'fQm>z2-hup͵?~&u$vU[ٖc~Ep¯/\g8_vwbpt`Ks2np|6"/`B2~^e[n*\2^Y*	vQB͞QS*0{J5LwV#;_\igjz[lrCR`=t:H<
ݞhsɍITO#~|_(珯CZ#<L؆<P6Wa=½K
~Wf<?pZVy@H	0V'akCʤKlx\"Դtr%@vzXQZ)5C"<^JL"ߓU4t˦a4VrCˎ&e{ݥz	Uб_q3:JZG )
7Q7ɫQԒiX2 )MǬ[_w #K`tGENi&q59Y$| ݇^aMsQ;?斖zr9ul[<^͍WX}7K9͓VP<W5_ei܍5ψl0zx3Ha \L\n~g̥s* `eY\"ǨOáCvWrWLrntj!".)2;gbtY%Ghu:_TSꙙy2PmװP,<mI)y41>rx KOfr::q9FbFW[|$&UL@of 4HeŒo*uNყ}`Av[n.<6[Ӷ3CMzKGH}0VzcYMMuY 
" :Tf|ȩWU+#%xl|<ܷ'bO89>'7~$x0c҉I88({Drμ'<	gR{q@q%Mty]\Y/WN`BB$}-Ũuk[5$'<sKX	DCql_6@7Xf>CU~)Jcԇ#ImZ[r~&@nSm`!/0 OJоR݈?7ySwq18 62}0/7G[.nϵo%Aw7g^u*<wD!U|n>]p+PzXM!
\:*֞B`	'z?&t7`İ%Uy1`T7w||+%935rחlZKSM!#. ĨY!rX`b)ih 03&nMuĎgaaPHcu]j	' q\WDSvPO~gm3b&$5hZB^b$U"pf808hp@w"+e;rԌX0-0$L|ܜpGi- Jp@"7I0A[~̭7, ԝ,4$Na!S0tN!02\ Y03ʒ3ODvD8U'a8;ge'&l ,2,BH~.[><B:Z
A6@kiPtF,䛵ˊ䡝`ٲD؄(zuA@YY* 3Wy&w!%NW}v8}d*x1 `[;z"g?@E*Y11	'p6kp#/x>m/,ţ!1	Xl:^cm
]"4N@p$k{^clva/j]Ytb2D`v0g^;mF9	I	73v [@r쬃eh+̴
_0rUdNZmRA2ЌY )H?7՜)1G9,0ͮ7&)7(A6P9xXRBF>'"*dIW	EDDDD KK&2)rB6JXZA6Wzd&v4iI 63\bީڏ1M'G8oxYaE6$ACrྛ'#}  $)94@c'jNfHpO(` ؃     FPUUU=8    u;       
+-	    IENDB`PNG

   IHDR         ;hw  	wIDATx[6Cg@~'sq )ȂikJ)Ͽ}̙@gܜ|js	'h6'ڜ|js	'h633,[ڜKڜ|js	'h6'ڜ|js	'h633,˲Bmƺ Xh?m@=".)Q"{6$eKjEW^nYQY"0nTMB_"]5SzҊZӀg\1h#ֺjl=ݓ!ռt{SoM#C[T}gjb
'm
馧;֍XHP<~-˲)U>0~nh/4xQzFˮ;czyE9:H<U͌ x[8H|6tݮfK!Fb93mNFgrfc]6v9@& jlԿǢqzײSq,LcٸuG\ĀhNk'ʡCvHbuh(ZIY,apߐeYe}UKyS_sxhuWδ5ήΣ|k_};FV)}ŀpeUFHu33w3jfXxnyKXWxeN4"щ*0ErzĀɑV5+3܊!wlَwkYeYe}L4c~+\y)g_ζGde=q<a2#jHL	sg~;xgu݊ϰN:Ǹw1XV:a@A+e"ܮeC}V]s7[ʀ.;tHڀLKS.lʊy2E:JY+2|8$ZXho]ÊƌkYl@Qe޹wt\BwoڎGēiW|c411~2as*G&(Wjʬjh1H՘xh}O!^"j]ݗBb@b09I8]l0%6ڀdH=ysfF,^̊FPEծZDZ]w3Z~&}X'M`YeY"ho&Oq6F21+?~Au+n0& ?5<uue䨠I0}GaršE&E#uL(d}y[נal@vWcF7#՝f?Y30r#&{1+ree216+2q`" 0eY*͙r1g.'h6'ڜ|js	'h6'ڜ|js?9s;9˲KEɿ'h6'ڜ|js	'h6'ڜ|js?9s;9˲+*mtƲZs19:VGoUff0=c6n늎ձȝ1ݬH4:!5t5f# aL=NG0qg8C{E;n@HBPSG43G5P2hEF+&,ߋ{]05H]ydM5 2##;cvYfhlcԭV
޹Y,1޿],z1C5'5O=GkeL.?{^x)ojH~7cdf,q]5J~xh+DZ+νՀѵwc6%1}Vϭp߳:VԀU4Hlֿ#邽x<fk=i@V~x][':63,VXE'o3`|W126iS3N?xJ7OyezW3 dǛgYeGh{h{z|'f)ա'xޯ\P:'ifTPks	6u
us	4̐oCOtIug*Juβ,Ro:9SJ|6`mN>A^:'If)ա'XOP9:9mڜ|
Iug*Juβ,Rojs/js	'h6'ڜ|js	'h6'@cNβ,Rojs/js	'h6'ڜ|js	'h6'@cNβ`W}"    IENDB`PNG

   IHDR         a  IDATx1n@E,]"RtTR# QI"gI:*@]fK	zGcuo;>^wM>=jd|@ܾ'McjZ@iEasW;6#rXc./#Rʟ)# Ba܇'D@koßO?YWĈ,)( TA[RxCDQLqQnC\IRyY% Ww:      IDAT J!    IENDB`PNG

   IHDR         a   IDATxO1@/뮢@_T&)xF6Mp<3og@TL9y7
lN\)Sd3k}!s0Z)p|4 5-DIs{4M8ZikX棙AGdH|
Og< s3,@YVRU;[2dө|{d8"k{  "i|   IDAT !B!+    IENDB`  -- ============================================================
-- oak_forest.marble -- MarbleScript v0.1
--
-- The first .marble file. This is the source-of-truth for the
-- Oak Forest demo scenario. Currently hand-compiled to C
-- (see main.c). Phase 1+ will parse this and codegen the
-- equivalent C structs, enums, and lookup tables automatically.
--
-- To verify: the C runtime output with WORLD_SEED=42 must
-- produce identical results on all platforms (deterministic
-- SplitMix32 PRNG).
-- ============================================================

world "Oak Forest Demo" {
    max_entities     1024
    tick_interval_ms 600
    seed             42
    max_layers       4
    max_body_parts   6
    max_skills       8
}

-- ============================================================
-- MATERIALS
-- Physical constants. Hardness is on a 0-100 scale.
-- ============================================================

material Wood  { hardness 30 }
material Iron  { hardness 80 }
material Flesh { hardness 10 }
material Bark  { hardness 25 }
material Bone  { hardness 40 }

-- ============================================================
-- LAYER TEMPLATES
-- Ordered outside-in. Index 0 = outermost layer.
-- ============================================================

layer OakTree {
    Bark  integrity 3
    Wood  integrity 10
}

layer HumanHand {
    Flesh integrity 1
    Bone  integrity 1
}

-- ============================================================
-- SKILLS
-- Named identifiers for the d100 roll system.
-- ============================================================

skill Woodcutting

-- ============================================================
-- ANATOMY & BODY PARTS
-- Anatomy = flags for gross body structure.
-- Body parts = named slots referencing sub-entities.
-- ============================================================

anatomy Arms
anatomy Hands
anatomy Legs

bodypart RightHand

-- ============================================================
-- CONDITIONS
-- Reusable predicate atoms. These are NOT executable code --
-- they compile to cases in the C evaluate_condition() switch.
-- ============================================================

condition tool_harder_than_layer {
    check Actor.Tool.Material.Hardness > Target.Layer[0].Material.Hardness
}

-- ============================================================
-- EFFECTS
-- State mutations applied on interaction success or crit fail.
-- Compile to cases in the C apply_effect() switch.
-- ============================================================

effect damage_layer {
    apply Target.Layer[0].integrity -= 1
}

-- ============================================================
-- CAPABILITIES (Actor-side)
-- "What can this entity DO?"
--
-- The BodyPart.RightHand.integrity requirement is the
-- fine motor gate: if the hand is destroyed, this condition
-- fails declaratively and the capability is effectively lost
-- without any imperative flag mutation.
-- ============================================================

capability Chop {
    require   Anatomy.Arms
    require   Anatomy.Hands
    require   BodyPart.RightHand.integrity > 0
    skill     Woodcutting
    min_skill 1
}

-- ============================================================
-- AFFORDANCES (Object-side)
-- "What can be DONE TO this entity?"
--
-- crit_fail fields define what happens when the d100 roll
-- falls below the crit threshold: the actor damages their
-- own body part. This is how the lumberjack hurts their hand.
-- ============================================================

affordance Choppable {
    require_cap         Chop
    condition           tool_harder_than_layer
    on_success          damage_layer
    difficulty          40
    crit_fail_threshold 15
    crit_fail_bodypart  RightHand
    crit_fail_damage    2
}

-- ============================================================
-- VERBS
-- The bridge between capability and affordance.
-- An actor submits (actor, target, verb) to the processor.
-- ============================================================

verb Chop {
    actor_cap  Chop
    target_aff Choppable
}

-- ============================================================
-- SYSTEMS
-- Tick-driven processors. Frequency = run every N ticks.
-- ============================================================

system TickLog {
    frequency 1
}

system InteractionProcessor {
    frequency 2
    requires  Capabilities, Affordances, Anatomy, Skills, Tool, BodyParts, Layers
}

system WorldStatus {
    frequency 3
}

-- ============================================================
-- RULES
-- Multi-effect interaction definitions using the command buffer.
-- TRIGGER = which verb activates this rule
-- REQ = which capability the actor needs
-- COND = conditions that must pass (can have multiple)
-- DIFFICULTY = d100 threshold
-- CRIT_FAIL = what happens on critical failure
-- EFFECT = commands emitted on success (ordered)
-- ============================================================

rule Rule_Chop {
    trigger         Chop
    require_cap     Chop
    condition       tool_harder_than_layer
    difficulty      40
    crit_fail_threshold 15
    crit_fail_bodypart  RightHand
    crit_fail_damage    2
    effect DAMAGE_LAYER target:target amount:1
}

-- ============================================================
-- ENTITIES
-- World population. Each entity is a bag of components.
-- @references resolve to other entity IDs at init time.
-- ============================================================

entity Lumberjack {
    Health       { hp 100, max_hp 100 }
    Position     { x 5.0, y 3.0 }
    Anatomy      { Arms, Hands, Legs }
    Skills       { Woodcutting 60 }
    Capabilities { Chop }
    Tool         { material Iron }
    BodyParts    { RightHand -> @LumberjackHand }
}

entity LumberjackHand {
    Layers template HumanHand
}

entity OakTree {
    Position     { x 6.0, y 3.0 }
    Layers       template OakTree
    Affordances  { Choppable }
}
-- framework.lua
-- Complete port of ProjectBridge.UI.Primitives to Lua
-- Matches C# structure 1:1

-- ==========================================
-- Simple Class System
-- ==========================================
Object = {}
Object.__index = Object
function Object:new(o)
    o = o or {}
    setmetatable(o, self)
    return o
end
function Object:extend()
    local cls = {}
    for k, v in pairs(self) do
        if k:find("__") == 1 then
            cls[k] = v
        end
    end
    cls.__index = cls
    cls.super = self
    setmetatable(cls, self)
    return cls
end

-- ==========================================
-- UIElement.cs
-- ==========================================
UIElement = Object:extend()

function UIElement:new(o)
    o = o or {}
    setmetatable(o, self)
    o.x = o.x or 0
    o.y = o.y or 0
    o.width = o.width or 0
    o.height = o.height or 0
    o.visible = true
    o.isEnabled = true
    o.children = {}
    o.parent = nil
    
    -- Modder hooks
    o.onUpdate = nil
    o.onDraw = nil
    
    return o
end

function UIElement:getGlobalPosition()
    if not self.parent then return self.x, self.y end
    local px, py = self.parent:getGlobalPosition()
    return px + self.x, py + self.y
end

function UIElement:getBounds()
    return self.x, self.y, self.width, self.height
end

function UIElement:getGlobalBounds()
    local gx, gy = self:getGlobalPosition()
    return gx, gy, self.width, self.height
end

function UIElement:addChild(child)
    if child.parent then child.parent:removeChild(child) end
    child.parent = self
    table.insert(self.children, child)
end

function UIElement:removeChild(child)
    for i, c in ipairs(self.children) do
        if c == child then
            table.remove(self.children, i)
            child.parent = nil
            break
        end
    end
end

function UIElement:clearChildren()
    for _, child in ipairs(self.children) do
        child.parent = nil
    end
    self.children = {}
end

function UIElement:containsPoint(px, py)
    local gx, gy = self:getGlobalPosition()
    return px >= gx and px <= gx + self.width and
           py >= gy and py <= gy + self.height
end

function UIElement:update(mx, my, mouseDown, screenW, screenH)
    if not self.visible or not self.isEnabled then return end
    
    if self.onUpdate then self.onUpdate() end
    
    if self.updateSelf then self:updateSelf(mx, my, mouseDown, screenW, screenH) end
    
    for _, child in ipairs(self.children) do
        child:update(mx, my, mouseDown, screenW, screenH)
    end
end

function UIElement:draw()
    if not self.visible then return end
    
    if self.onDraw then self.onDraw(self) end
    
    if self.drawSelf then self:drawSelf() end
    
    for _, child in ipairs(self.children) do
        child:draw()
    end
end

-- ==========================================
-- Panel.cs
-- ==========================================
Panel = UIElement:extend()

function Panel:new(o)
    o = UIElement.new(self, o)
    o.bgColor = o.bgColor or {0,0,0,0}
    o.borderColor = o.borderColor or {0,0,0,0}
    o.borderThickness = o.borderThickness or 0
    o.paddingLeft = o.paddingLeft or 0
    o.paddingTop = o.paddingTop or 0
    o.paddingRight = o.paddingRight or 0
    o.paddingBottom = o.paddingBottom or 0
    return o
end

function Panel:setPadding(l, t, r, b)
    if not t then
        -- Uniform
        self.paddingLeft = l
        self.paddingTop = l
        self.paddingRight = l
        self.paddingBottom = l
    elseif not r then
        -- Horizontal, Vertical
        self.paddingLeft = l
        self.paddingRight = l
        self.paddingTop = t
        self.paddingBottom = t
    else
        -- All four
        self.paddingLeft = l
        self.paddingTop = t
        self.paddingRight = r
        self.paddingBottom = b
    end
end

function Panel:getContentBounds()
    return self.x + self.paddingLeft,
           self.y + self.paddingTop,
           self.width - self.paddingLeft - self.paddingRight,
           self.height - self.paddingTop - self.paddingBottom
end

function Panel:drawSelf()
    local gx, gy = self:getGlobalPosition()
    
    -- Draw Background
    if self.bgColor[4] > 0 then
        bridge.drawRect(gx, gy, self.width, self.height, 
            self.bgColor[1], self.bgColor[2], self.bgColor[3], self.bgColor[4])
    end
    
    -- Draw Border
    if self.borderColor[4] > 0 and self.borderThickness > 0 then
        if bridge.drawBorder then
            bridge.drawBorder(gx, gy, self.width, self.height,
                self.borderColor[1], self.borderColor[2], self.borderColor[3], self.borderColor[4],
                self.borderThickness)
        else
            -- Fallback to 1px border
            local c = self.borderColor
            bridge.drawRect(gx, gy, self.width, 1, c[1], c[2], c[3], c[4])
            bridge.drawRect(gx, gy + self.height - 1, self.width, 1, c[1], c[2], c[3], c[4])
            bridge.drawRect(gx, gy, 1, self.height, c[1], c[2], c[3], c[4])
            bridge.drawRect(gx + self.width - 1, gy, 1, self.height, c[1], c[2], c[3], c[4])
        end
    end
end

-- ==========================================
-- Button.cs
-- ==========================================
Button = Panel:extend()

function Button:new(o)
    o = Panel.new(self, o)
    o.normalColor = o.normalColor or {60, 60, 60, 255}
    o.hoverColor = o.hoverColor or {80, 80, 80, 255}
    o.pressedColor = o.pressedColor or {40, 40, 40, 255}
    o.disabledColor = o.disabledColor or {30, 30, 30, 255}
    o.bgColor = o.normalColor
    o.isHovered = false
    o.isPressed = false
    o.wasMouseDown = false
    
    -- Events
    o.onClick = nil
    o.onHover = nil
    o.onPress = nil
    o.onRelease = nil
    
    return o
end

function Button:updateSelf(mx, my, mouseDown, sw, sh)
    local wasHovered = self.isHovered
    self.isHovered = self.isEnabled and self:containsPoint(mx, my)
    
    -- Hover event
    if self.isHovered and not wasHovered then
        if self.onHover then self.onHover() end
    end
    
    -- Disabled state
    if not self.isEnabled then
        self.bgColor = self.disabledColor
        self.isPressed = false
        self.wasMouseDown = mouseDown
        return
    end
    
    if self.isHovered then
        -- Press
        if mouseDown and not self.wasMouseDown then
            self.isPressed = true
            if self.onPress then self.onPress() end
        end
        
        -- Release (click)
        if not mouseDown and self.wasMouseDown and self.isPressed then
            if self.onClick then self.onClick() end
            if self.onRelease then self.onRelease() end
            self.isPressed = false
        end
        
        -- Visual feedback
        if self.isPressed then
            self.bgColor = self.pressedColor
        else
            self.bgColor = self.hoverColor
        end
    else
        self.bgColor = self.normalColor
        
        -- Cancel press if mouse leaves
        if self.isPressed then
            self.isPressed = false
            if self.onRelease then self.onRelease() end
        end
    end
    
    self.wasMouseDown = mouseDown
end

-- ==========================================
-- Label.cs
-- ==========================================
Label = UIElement:extend()

function Label:new(o)
    o = UIElement.new(self, o)
    o.text = o.text or ""
    o.textColor = o.textColor or {255, 255, 255, 255}
    o.alignment = o.alignment or "left" -- "left", "center", "right", "topleft"
    o.width = o.width or 100
    o.height = o.height or 20
    
    -- Drop shadow
    o.dropShadow = o.dropShadow or false
    o.shadowColor = o.shadowColor or {0, 0, 0, 255}
    o.shadowOffsetX = o.shadowOffsetX or 1
    o.shadowOffsetY = o.shadowOffsetY or 1
    
    return o
end

function Label:drawSelf()
    if not self.text or self.text == "" then return end
    
    local gx, gy = self:getGlobalPosition()
    
    -- Measure text if available
    local textWidth, textHeight = 0, 14
    if bridge.measureText then
        textWidth, textHeight = bridge.measureText(self.text)
    end
    
    local drawX = gx
    local drawY = gy
    
    -- Apply alignment
    if self.alignment == "center" then
        drawX = gx + (self.width - textWidth) / 2
        drawY = gy + (self.height - textHeight) / 2
    elseif self.alignment == "right" then
        drawX = gx + (self.width - textWidth)
        drawY = gy + (self.height - textHeight) / 2
    elseif self.alignment == "topleft" then
        -- No adjustment
    else -- "left"
        drawY = gy + (self.height - textHeight) / 2
    end
    
    -- Snap to pixel boundaries
    drawX = math.floor(drawX + 0.5)
    drawY = math.floor(drawY + 0.5)
    
    -- Draw shadow
    if self.dropShadow then
        bridge.drawText(self.text, drawX + self.shadowOffsetX, drawY + self.shadowOffsetY, 
            self.shadowColor[1], self.shadowColor[2], self.shadowColor[3], self.shadowColor[4])
    end
    
    -- Draw text
    bridge.drawText(self.text, drawX, drawY, 
        self.textColor[1], self.textColor[2], self.textColor[3], self.textColor[4])
end

-- ==========================================
-- LayoutGroup.cs (Abstract Base)
-- ==========================================
LayoutGroup = Panel:extend()

function LayoutGroup:new(o)
    o = Panel.new(self, o)
    o.spacing = o.spacing or 0
    o.alignment = o.alignment or "start" -- "start", "center", "end"
    o.expandChildren = o.expandChildren or false
    o.needsLayout = true
    return o
end

function LayoutGroup:addChild(child)
    Panel.addChild(self, child)
    self.needsLayout = true
end

function LayoutGroup:removeChild(child)
    Panel.removeChild(self, child)
    self.needsLayout = true
end

function LayoutGroup:invalidateLayout()
    self.needsLayout = true
end

function LayoutGroup:updateSelf(mx, my, mouseDown, sw, sh)
    if self.needsLayout then
        if self.performLayout then
            self:performLayout()
        end
        self.needsLayout = false
    end
end

-- ==========================================
-- VBox (Vertical Box)
-- ==========================================
VBox = LayoutGroup:extend()

function VBox:performLayout()
    local totalChildHeight = 0
    local visibleCount = 0
    
    -- Calculate total height needed
    for _, child in ipairs(self.children) do
        if child.visible then
            totalChildHeight = totalChildHeight + child.height
            visibleCount = visibleCount + 1
        end
    end
    
    local totalSpacing = self.spacing * math.max(0, visibleCount - 1)
    local contentHeight = self.height - self.paddingTop - self.paddingBottom
    local availableSpace = contentHeight - totalChildHeight - totalSpacing
    
    local currentY = self.paddingTop
    
    -- Apply alignment offset
    if self.alignment == "center" then
        currentY = currentY + availableSpace / 2
    elseif self.alignment == "end" then
        currentY = currentY + availableSpace
    end
    
    -- Position children
    for _, child in ipairs(self.children) do
        if not child.visible then goto continue end
        
        child.x = self.paddingLeft
        child.y = currentY
        
        -- Optionally expand width to fill container
        if self.expandChildren then
            child.width = self.width - self.paddingLeft - self.paddingRight
        end
        
        currentY = currentY + child.height + self.spacing
        
        ::continue::
    end
end

function VBox:autoSize()
    local totalHeight = self.paddingTop + self.paddingBottom
    local maxWidth = 0
    local visibleCount = 0
    
    for _, child in ipairs(self.children) do
        if child.visible then
            totalHeight = totalHeight + child.height
            maxWidth = math.max(maxWidth, child.width)
            visibleCount = visibleCount + 1
        end
    end
    
    totalHeight = totalHeight + self.spacing * math.max(0, visibleCount - 1)
    
    self.height = totalHeight
    self.width = math.max(self.width, maxWidth + self.paddingLeft + self.paddingRight)
end

-- ==========================================
-- HBox (Horizontal Box)
-- ==========================================
HBox = LayoutGroup:extend()

function HBox:performLayout()
    local totalChildWidth = 0
    local visibleCount = 0
    
    -- Calculate total width needed
    for _, child in ipairs(self.children) do
        if child.visible then
            totalChildWidth = totalChildWidth + child.width
            visibleCount = visibleCount + 1
        end
    end
    
    local totalSpacing = self.spacing * math.max(0, visibleCount - 1)
    local contentWidth = self.width - self.paddingLeft - self.paddingRight
    local availableSpace = contentWidth - totalChildWidth - totalSpacing
    
    local currentX = self.paddingLeft
    
    -- Apply alignment offset
    if self.alignment == "center" then
        currentX = currentX + availableSpace / 2
    elseif self.alignment == "end" then
        currentX = currentX + availableSpace
    end
    
    -- Position children
    for _, child in ipairs(self.children) do
        if not child.visible then goto continue end
        
        child.x = currentX
        child.y = self.paddingTop
        
        -- Optionally expand height to fill container
        if self.expandChildren then
            child.height = self.height - self.paddingTop - self.paddingBottom
        end
        
        currentX = currentX + child.width + self.spacing
        
        ::continue::
    end
end

function HBox:autoSize()
    local totalWidth = self.paddingLeft + self.paddingRight
    local maxHeight = 0
    local visibleCount = 0
    
    for _, child in ipairs(self.children) do
        if child.visible then
            totalWidth = totalWidth + child.width
            maxHeight = math.max(maxHeight, child.height)
            visibleCount = visibleCount + 1
        end
    end
    
    totalWidth = totalWidth + self.spacing * math.max(0, visibleCount - 1)
    
    self.width = totalWidth
    self.height = math.max(self.height, maxHeight + self.paddingTop + self.paddingBottom)
end

-- ==========================================
-- GridLayout
-- ==========================================
GridLayout = LayoutGroup:extend()

function GridLayout:new(o)
    o = LayoutGroup.new(self, o)
    o.columns = o.columns or 3
    o.rows = o.rows or 0 -- 0 = auto-calculate
    return o
end

function GridLayout:performLayout()
    if #self.children == 0 then return end
    
    local cols = math.max(1, self.columns)
    local rows = self.rows > 0 and self.rows or math.ceil(#self.children / cols)
    
    local contentX, contentY, contentWidth, contentHeight = self:getContentBounds()
    
    local cellWidth = (contentWidth - self.spacing * (cols - 1)) / cols
    local cellHeight = (contentHeight - self.spacing * (rows - 1)) / rows
    
    local index = 0
    for _, child in ipairs(self.children) do
        if not child.visible then goto continue end
        
        local col = index % cols
        local row = math.floor(index / cols)
        
        child.x = self.paddingLeft + col * (cellWidth + self.spacing)
        child.y = self.paddingTop + row * (cellHeight + self.spacing)
        
        if self.expandChildren then
            child.width = cellWidth
            child.height = cellHeight
        end
        
        index = index + 1
        
        ::continue::
    end
end

-- ==========================================
-- Slider.cs
-- ==========================================
Slider = Panel:extend()

function Slider:new(o)
    o = Panel.new(self, o)
    o.value = o.value or 0.5
    o.height = o.height or 20
    o.isDragging = false
    o.onValueChanged = nil
    o.trackColor = {60, 60, 60, 255}
    o.handleColor = {100, 100, 100, 255}
    o.handleHoverColor = {120, 120, 120, 255}
    return o
end

function Slider:setValue(v)
    self.value = math.max(0, math.min(1, v))
    if self.onValueChanged then 
        self.onValueChanged(self.value) 
    end
end

function Slider:updateSelf(mx, my, mouseDown, sw, sh)
    local gx, gy = self:getGlobalPosition()
    
    local handleX = gx + (self.width - 16) * self.value
    local mouseInHandle = mx >= handleX and mx <= handleX + 16 and 
                          my >= gy and my <= gy + 20
                          
    if mouseDown and mouseInHandle and not self.isDragging then
        self.isDragging = true
    end
    
    if not mouseDown then 
        self.isDragging = false 
    end
    
    if self.isDragging then
        local relX = mx - gx
        self:setValue(relX / self.width)
    end
    
    -- Hover effect
    if mouseInHandle or self.isDragging then
        self.handleColor = self.handleHoverColor
    else
        self.handleColor = {100, 100, 100, 255}
    end
end

function Slider:drawSelf()
    local gx, gy = self:getGlobalPosition()
    
    -- Draw Track
    local c = self.trackColor
    bridge.drawRect(gx, gy + 8, self.width, 4, c[1], c[2], c[3], c[4])
    
    if self.borderColor[4] > 0 then
        bridge.drawRect(gx, gy + 8, self.width, 1, 
            self.borderColor[1], self.borderColor[2], self.borderColor[3], self.borderColor[4])
        bridge.drawRect(gx, gy + 11, self.width, 1,
            self.borderColor[1], self.borderColor[2], self.borderColor[3], self.borderColor[4])
    end
    
    -- Draw Handle
    local hx = (self.width - 16) * self.value
    local h = self.handleColor
    bridge.drawRect(gx + hx, gy, 16, 20, h[1], h[2], h[3], h[4])
    
    -- Handle border
    if self.borderColor[4] > 0 then
        local b = self.borderColor
        bridge.drawRect(gx + hx, gy, 16, 2, b[1], b[2], b[3], b[4])
        bridge.drawRect(gx + hx, gy + 18, 16, 2, b[1], b[2], b[3], b[4])
        bridge.drawRect(gx + hx, gy, 2, 20, b[1], b[2], b[3], b[4])
        bridge.drawRect(gx + hx + 14, gy, 2, 20, b[1], b[2], b[3], b[4])
    end
end

-- ==========================================
-- ProgressBar.cs
-- ==========================================
ProgressBar = Panel:extend()

function ProgressBar:new(o)
    o = Panel.new(self, o)
    o.value = o.value or 0
    o.fillColor = o.fillColor or {60, 180, 60, 255}
    o.emptyColor = o.emptyColor or {40, 40, 40, 255}
    o.bgColor = o.emptyColor
    o.borderColor = o.borderColor or {100, 100, 100, 255}
    o.borderThickness = o.borderThickness or 1
    return o
end

function ProgressBar:setValue(v)
    self.value = math.max(0, math.min(1, v))
end

function ProgressBar:drawSelf()
    local gx, gy = self:getGlobalPosition()
    
    -- Draw background (empty state)
    Panel.drawSelf(self)
    
    -- Draw fill
    local fillWidth = (self.width - 4) * self.value
    if fillWidth > 0 then
        local c = self.fillColor
        bridge.drawRect(gx + 2, gy + 2, fillWidth, self.height - 4,
            c[1], c[2], c[3], c[4])
    end
end

-- ==========================================
-- Toggle.cs
-- ==========================================
Toggle = Button:extend()

function Toggle:new(o)
    o = Button.new(self, o)
    local size = o.size or 24
    o.width = size
    o.height = size
    o.isToggled = o.isToggled or false
    o.toggledColor = o.toggledColor or {60, 180, 60, 255}
    o.untoggledColor = o.untoggledColor or {60, 60, 60, 255}
    o.indicatorColor = o.indicatorColor or {255, 255, 255, 255}
    o.borderColor = o.borderColor or {100, 100, 100, 255}
    o.borderThickness = 2
    o.onToggleChanged = nil
    
    -- Override button onClick
    local oldOnClick = o.onClick
    o.onClick = function()
        o:setToggled(not o.isToggled)
        if oldOnClick then oldOnClick() end
    end
    
    return o
end

function Toggle:setToggled(state)
    self.isToggled = state
    self.normalColor = state and self.toggledColor or self.untoggledColor
    self.bgColor = self.normalColor
    if self.onToggleChanged then
        self.onToggleChanged(state)
    end
end

function Toggle:drawSelf()
    -- Draw base (border + background)
    Panel.drawSelf(self)
    
    -- Draw indicator if toggled
    if self.isToggled then
        local gx, gy = self:getGlobalPosition()
        local c = self.indicatorColor
        bridge.drawRect(gx + 4, gy + 4, self.width - 8, self.height - 8,
            c[1], c[2], c[3], c[4])
    end
end

-- ==========================================
-- ColorIndicator.cs
-- ==========================================
ColorIndicator = Panel:extend()

function ColorIndicator:new(o)
    o = Panel.new(self, o)
    o.baseColor = o.baseColor or o.bgColor or {100, 100, 100, 255}
    o.bgColor = o.baseColor
    o.pulsing = o.pulsing or false
    o.pulseTimer = 0
    o.borderColor = o.borderColor or {
        math.min(255, math.floor(o.baseColor[1] * 1.5)),
        math.min(255, math.floor(o.baseColor[2] * 1.5)),
        math.min(255, math.floor(o.baseColor[3] * 1.5)),
        255
    }
    o.borderThickness = o.borderThickness or 1
    return o
end

function ColorIndicator:updateSelf(mx, my, mouseDown, sw, sh)
    if self.pulsing then
        self.pulseTimer = self.pulseTimer + 0.05
        local pulse = math.sin(self.pulseTimer) * 0.5 + 0.5
        
        local b = self.baseColor
        self.bgColor = {
            math.floor(b[1] + (255 - b[1]) * pulse * 0.5),
            math.floor(b[2] + (255 - b[2]) * pulse * 0.5),
            math.floor(b[3] + (255 - b[3]) * pulse * 0.5),
            b[4]
        }
    end
end

-- ==========================================
-- Window.cs
-- ==========================================
Window = Panel:extend()

function Window:new(o)
    o = Panel.new(self, o)
    o.titleBarHeight = o.titleBarHeight or 30
    o.titleBarColor = o.titleBarColor or {60, 120, 180, 255}
    o.bgColor = o.bgColor or {40, 40, 40, 255}
    o.borderColor = o.borderColor or {80, 80, 80, 255}
    o.borderThickness = o.borderThickness or 2
    
    o.isDragging = false
    o.dragOffsetX = 0
    o.dragOffsetY = 0
    
    o.titleBar = {
        color = o.titleBarColor,
        height = o.titleBarHeight
    }
    
    o.contentY = o.titleBarHeight
    
    return o
end

function Window:addContent(element)
    element.y = element.y + self.contentY
    self:addChild(element)
end

function Window:updateSelf(mx, my, mouseDown, sw, sh)
    local gx, gy = self:getGlobalPosition()
    local inTitleBar = mx >= gx and mx <= gx + self.width and
                       my >= gy and my <= gy + self.titleBarHeight
    
    if inTitleBar and mouseDown and not self.isDragging then
        self.isDragging = true
        self.dragOffsetX = mx - self.x
        self.dragOffsetY = my - self.y
    end
    
    if not mouseDown then
        self.isDragging = false
    end
    
    if self.isDragging then
        self.x = mx - self.dragOffsetX
        self.y = my - self.dragOffsetY
    end
    
    -- Hover effect
    if inTitleBar or self.isDragging then
        local c = self.titleBarColor
        self.titleBar.color = {
            math.min(255, math.floor(c[1] * 1.2)),
            math.min(255, math.floor(c[2] * 1.2)),
            math.min(255, math.floor(c[3] * 1.2)),
            c[4]
        }
    else
        self.titleBar.color = self.titleBarColor
    end
end

function Window:drawSelf()
    local gx, gy = self:getGlobalPosition()
    
    -- Draw window background
    Panel.drawSelf(self)
    
    -- Draw title bar
    local c = self.titleBar.color
    bridge.drawRect(gx, gy, self.width, self.titleBarHeight,
        c[1], c[2], c[3], c[4])
end#!/usr/bin/env lua
-- ============================================================
-- marble_compile.lua -- MarbleScript Compiler v0.1
--
-- Parses .marble files and emits a C header (marble_gen.h)
-- containing all enums, lookup tables, and struct definitions
-- that the runtime needs.
--
-- Usage:
--   lua marble_compile.lua oak_forest.marble
--   lua marble_compile.lua oak_forest.marble -o marble_gen.h
--
-- Compatible with Lua 5.3+ (also works under texlua/luatex)
--
-- WHAT IT GENERATES:
--   - MaterialID enum + MATERIAL_HARDNESS[] + MATERIAL_NAMES[]
--   - SkillID enum
--   - AnatomyFlag enum (bitfield)
--   - BodyPartID enum + BODYPART_NAMES[]
--   - ConditionID enum
--   - EffectID enum
--   - CapabilityID enum + CAPABILITY_DEFS[]
--   - AffordanceID enum + AFFORDANCE_DEFS[]
--   - VerbID enum + VERB_DEFS[]
--   - SystemID enum + SYSTEM_FREQ[]
--   - Layer template initializer functions
--   - World config #defines
--
-- WHAT IT DOES NOT GENERATE (yet):
--   - component struct definitions (Phase 2)
--   - entity initialization code (Phase 2)
-- ============================================================

local VERSION = "0.1"

-- ============================================================
-- LEXER: line-by-line, token-by-token
-- ============================================================

local function read_file(path)
    local f = io.open(path, "r")
    if not f then
        io.stderr:write("ERROR: cannot open file: " .. path .. "\n")
        os.exit(1)
    end
    local content = f:read("*a")
    f:close()
    return content
end

-- Strip comments (-- to end of line) and return lines
local function strip_comments(source)
    local lines = {}
    for line in source:gmatch("[^\r\n]+") do
        -- Remove comment portion
        local stripped = line:gsub("%-%-.*$", "")
        lines[#lines + 1] = stripped
    end
    return lines
end

-- Tokenize a single line into words/symbols
local function tokenize_line(line)
    local tokens = {}
    -- Match: quoted strings, words, numbers, symbols
    for tok in line:gmatch('[%w_%.@]+[%w_%.@]*|"[^"]*"|[{}>,<=%+%-]') do
        tokens[#tokens + 1] = tok
    end
    -- Fallback: simpler pattern if above misses
    if #tokens == 0 then
        for tok in line:gmatch('%S+') do
            -- Strip trailing commas
            tok = tok:gsub(",+$", "")
            if tok ~= "" and tok ~= "," then
                tokens[#tokens + 1] = tok
            end
        end
    end
    return tokens
end

-- ============================================================
-- PARSER: block-level
-- Reads tokens and builds an AST (table of typed blocks)
-- ============================================================

local function parse(source)
    local lines = strip_comments(source)
    local ast = {
        world = nil,
        materials = {},
        skills = {},
        anatomy = {},
        bodyparts = {},
        conditions = {},
        effects = {},
        capabilities = {},
        affordances = {},
        verbs = {},
        systems = {},
        layers = {},
        rules = {},
    }

    local i = 1
    while i <= #lines do
        local tokens = tokenize_line(lines[i])

        if #tokens >= 1 then
            local keyword = tokens[1]

            if keyword == "world" then
                -- world "Name" { ... }
                local name = (tokens[2] or ""):gsub('"', '')
                local block = { name = name }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        block[t[1]] = tonumber(t[2]) or t[2]
                    end
                    i = i + 1
                end
                ast.world = block

            elseif keyword == "material" then
                -- material Name { hardness N }
                -- Can be single-line or multi-line
                local name = tokens[2]
                local block = { name = name }
                -- Check if entire block is on one line
                local full_line = lines[i]
                local inline_fields = full_line:match("{(.-)}")
                if inline_fields then
                    -- Single-line block: parse fields from inline content
                    for k, v in inline_fields:gmatch("(%w+)%s+(%S+)") do
                        block[k] = tonumber(v) or v
                    end
                elseif tokens[3] == "{" then
                    -- Multi-line block
                    i = i + 1
                    while i <= #lines do
                        local t = tokenize_line(lines[i])
                        if #t >= 1 and t[1] == "}" then break end
                        if #t >= 2 then
                            block[t[1]] = tonumber(t[2]) or t[2]
                        end
                        i = i + 1
                    end
                end
                ast.materials[#ast.materials + 1] = block

            elseif keyword == "skill" then
                ast.skills[#ast.skills + 1] = { name = tokens[2] }

            elseif keyword == "anatomy" then
                ast.anatomy[#ast.anatomy + 1] = { name = tokens[2] }

            elseif keyword == "bodypart" then
                ast.bodyparts[#ast.bodyparts + 1] = { name = tokens[2] }

            elseif keyword == "condition" then
                local name = tokens[2]
                local block = { name = name, check = "" }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 and t[1] == "check" then
                        -- Capture the entire rest of the line as the check expression
                        local check_line = lines[i]:match("check%s+(.+)")
                        if check_line then
                            block.check = check_line:gsub("%s+$", "")
                        end
                    end
                    i = i + 1
                end
                ast.conditions[#ast.conditions + 1] = block

            elseif keyword == "effect" then
                local name = tokens[2]
                local block = { name = name, apply = "" }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 and t[1] == "apply" then
                        local apply_line = lines[i]:match("apply%s+(.+)")
                        if apply_line then
                            block.apply = apply_line:gsub("%s+$", "")
                        end
                    end
                    i = i + 1
                end
                ast.effects[#ast.effects + 1] = block

            elseif keyword == "capability" then
                local name = tokens[2]
                local block = { name = name, require_anatomy = {}, skill = nil,
                                min_skill = 0, body_part = nil }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        if t[1] == "require" then
                            -- require Anatomy.X or require BodyPart.X.integrity > 0
                            local ref = t[2]
                            if ref:match("^Anatomy%.") then
                                local anat_name = ref:match("^Anatomy%.(.+)")
                                block.require_anatomy[#block.require_anatomy + 1] = anat_name
                            elseif ref:match("^BodyPart%.") then
                                local bp_name = ref:match("^BodyPart%.(.-)%.")
                                block.body_part = bp_name
                            end
                        elseif t[1] == "skill" then
                            block.skill = t[2]
                        elseif t[1] == "min_skill" then
                            block.min_skill = tonumber(t[2]) or 0
                        end
                    end
                    i = i + 1
                end
                ast.capabilities[#ast.capabilities + 1] = block

            elseif keyword == "affordance" then
                local name = tokens[2]
                local block = { name = name, require_cap = nil, condition = nil,
                                on_success = nil, difficulty = 0,
                                crit_fail_threshold = 0, crit_fail_bodypart = nil,
                                crit_fail_damage = 0 }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        if t[1] == "require_cap" then
                            block.require_cap = t[2]
                        elseif t[1] == "condition" then
                            block.condition = t[2]
                        elseif t[1] == "on_success" then
                            block.on_success = t[2]
                        elseif t[1] == "difficulty" then
                            block.difficulty = tonumber(t[2]) or 0
                        elseif t[1] == "crit_fail_threshold" then
                            block.crit_fail_threshold = tonumber(t[2]) or 0
                        elseif t[1] == "crit_fail_bodypart" then
                            block.crit_fail_bodypart = t[2]
                        elseif t[1] == "crit_fail_damage" then
                            block.crit_fail_damage = tonumber(t[2]) or 0
                        end
                    end
                    i = i + 1
                end
                ast.affordances[#ast.affordances + 1] = block

            elseif keyword == "verb" then
                local name = tokens[2]
                local block = { name = name, actor_cap = nil, target_aff = nil }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        if t[1] == "actor_cap" then
                            block.actor_cap = t[2]
                        elseif t[1] == "target_aff" then
                            block.target_aff = t[2]
                        end
                    end
                    i = i + 1
                end
                ast.verbs[#ast.verbs + 1] = block

            elseif keyword == "system" then
                local name = tokens[2]
                local block = { name = name, frequency = 1, requires = {} }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        if t[1] == "frequency" then
                            block.frequency = tonumber(t[2]) or 1
                        elseif t[1] == "requires" then
                            for j = 2, #t do
                                block.requires[#block.requires + 1] = t[j]
                            end
                        end
                    end
                    i = i + 1
                end
                ast.systems[#ast.systems + 1] = block

            elseif keyword == "layer" then
                local name = tokens[2]
                local block = { name = name, entries = {} }
                local full_line = lines[i]
                local inline = full_line:match("{(.-)}")
                if inline then
                    -- Single-line: "Bark integrity 3, Wood integrity 10"
                    for mat, integ in inline:gmatch("(%w+)%s+integrity%s+(%d+)") do
                        block.entries[#block.entries + 1] = {
                            material = mat,
                            integrity = tonumber(integ)
                        }
                    end
                else
                    i = i + 1
                    while i <= #lines do
                        local t = tokenize_line(lines[i])
                        if #t >= 1 and t[1] == "}" then break end
                        if #t >= 3 and t[2] == "integrity" then
                            block.entries[#block.entries + 1] = {
                                material = t[1],
                                integrity = tonumber(t[3]) or 1
                            }
                        end
                        i = i + 1
                    end
                end
                ast.layers[#ast.layers + 1] = block

            elseif keyword == "rule" then
                local name = tokens[2]
                local block = {
                    name = name,
                    trigger_verb = nil,
                    require_cap = nil,
                    conditions = {},
                    difficulty = 0,
                    crit_fail_threshold = 0,
                    crit_fail_bodypart = nil,
                    crit_fail_damage = 0,
                    effects = {},
                }
                i = i + 1
                while i <= #lines do
                    local t = tokenize_line(lines[i])
                    if #t >= 1 and t[1] == "}" then break end
                    if #t >= 2 then
                        if t[1] == "trigger" then
                            block.trigger_verb = t[2]
                        elseif t[1] == "require_cap" then
                            block.require_cap = t[2]
                        elseif t[1] == "condition" then
                            block.conditions[#block.conditions + 1] = t[2]
                        elseif t[1] == "difficulty" then
                            block.difficulty = tonumber(t[2]) or 0
                        elseif t[1] == "crit_fail_threshold" then
                            block.crit_fail_threshold = tonumber(t[2]) or 0
                        elseif t[1] == "crit_fail_bodypart" then
                            block.crit_fail_bodypart = t[2]
                        elseif t[1] == "crit_fail_damage" then
                            block.crit_fail_damage = tonumber(t[2]) or 0
                        elseif t[1] == "effect" then
                            -- effect CMD_TYPE key:val key:val ...
                            local eff = { cmd_type = t[2], params = {} }
                            for j = 3, #t do
                                local k, v = t[j]:match("^(%w+):(.+)$")
                                if k and v then
                                    eff.params[k] = tonumber(v) or v
                                end
                            end
                            block.effects[#block.effects + 1] = eff
                        end
                    end
                    i = i + 1
                end
                ast.rules[#ast.rules + 1] = block

            end
            -- entity blocks: skip for now (Phase 2)
        end

        i = i + 1
    end

    return ast
end

-- ============================================================
-- NAME CONVERSION UTILITIES
-- ============================================================

-- PascalCase -> UPPER_SNAKE_CASE
local function to_upper_snake(name)
    -- Insert underscore before uppercase letters (except first)
    local result = name:gsub("(%u)", function(c) return "_" .. c end)
    result = result:gsub("^_", "") -- remove leading underscore
    return result:upper()
end

-- Lookup helper: find index of name in ordered list
local function find_index(list, name)
    for idx, item in ipairs(list) do
        if item.name == name then return idx end
    end
    return nil
end

-- ============================================================
-- CODE GENERATOR v0.2
--
-- Emits marble_gen.h: self-contained header with enums, struct
-- typedefs, const lookup tables, layer templates, rule defs,
-- condition evaluator, and body part integrity checker.
-- ============================================================

local function generate(ast)
    local out = {}
    local function emit(...)
        for _, s in ipairs({...}) do
            out[#out + 1] = s
        end
    end
    local function emitf(fmt, ...)
        out[#out + 1] = string.format(fmt, ...)
    end

    emit("/*")
    emit(" * marble_gen.h -- AUTO-GENERATED by marble_compile.lua v" .. VERSION)
    emit(" * Source: " .. (ast._source_file or "unknown"))
    emit(" * DO NOT EDIT -- regenerate from .marble source")
    emit(" */")
    emit("")
    emit("#ifndef MARBLE_GEN_H")
    emit("#define MARBLE_GEN_H")
    emit("")
    emit('#include "marble_core.h"')
    emit("")

    -- WORLD CONFIG
    if ast.world then
        emit("/* ---- World Configuration ---- */")
        local w = ast.world
        if w.max_entities then emitf("#define MC_GEN_MAX_ENTITIES     %d", w.max_entities) end
        if w.tick_interval_ms then emitf("#define MC_GEN_TICK_INTERVAL_US %d", w.tick_interval_ms * 1000) end
        if w.seed then emitf("#define MC_GEN_WORLD_SEED       %du", w.seed) end
        if w.max_layers then emitf("#define MC_GEN_MAX_LAYERS       %d", w.max_layers) end
        if w.max_body_parts then emitf("#define MC_GEN_MAX_BODY_PARTS   %d", w.max_body_parts) end
        if w.max_skills then emitf("#define MC_GEN_MAX_SKILLS       %d", w.max_skills) end
        emit("")
    end

    -- MATERIALS
    if #ast.materials > 0 then
        emit("/* ---- Materials ---- */")
        emit("typedef enum {")
        emit("    MAT_NONE = 0,")
        for idx, mat in ipairs(ast.materials) do
            emitf("    MAT_%s = %d,", to_upper_snake(mat.name), idx)
        end
        emitf("    MAT_COUNT = %d", #ast.materials + 1)
        emit("} MaterialID;")
        emit("")
        emit("static const char* MATERIAL_NAMES[MAT_COUNT] = {")
        emit('    "None",')
        for _, mat in ipairs(ast.materials) do emitf('    "%s",', mat.name) end
        emit("};")
        emit("")
        emit("static const int32_t MATERIAL_HARDNESS[MAT_COUNT] = {")
        emit("    /*NONE*/ 0,")
        for _, mat in ipairs(ast.materials) do
            emitf("    /*%s*/ %d,", to_upper_snake(mat.name), mat.hardness or 0)
        end
        emit("};")
        emit("")
    end

    -- LAYER SYSTEM
    emit("/* ---- Layer System ---- */")
    emitf("#define MAX_LAYERS %d", (ast.world and ast.world.max_layers) or 4)
    emit("")
    emit("typedef struct { MaterialID material; int32_t integrity; int32_t max_integrity; } Layer;")
    emit("typedef struct { Layer layers[MAX_LAYERS]; uint32_t layer_count; } CLayerStack;")
    emit("")

    -- LAYER TEMPLATES
    if #ast.layers > 0 then
        emit("/* ---- Layer Templates ---- */")
        for _, tmpl in ipairs(ast.layers) do
            emitf("static void layer_template_%s(CLayerStack* ls) {", tmpl.name)
            emitf("    ls->layer_count = %d;", #tmpl.entries)
            for idx, entry in ipairs(tmpl.entries) do
                emitf("    ls->layers[%d].material = MAT_%s; ls->layers[%d].integrity = %d; ls->layers[%d].max_integrity = %d;",
                    idx-1, to_upper_snake(entry.material), idx-1, entry.integrity, idx-1, entry.integrity)
            end
            emit("}")
            emit("")
        end
    end

    -- SKILLS
    if #ast.skills > 0 then
        emit("/* ---- Skills ---- */")
        emit("typedef enum {")
        emit("    SKILL_NONE = 0,")
        for idx, sk in ipairs(ast.skills) do emitf("    SKILL_%s = %d,", to_upper_snake(sk.name), idx) end
        emitf("    SKILL_COUNT = %d", #ast.skills + 1)
        emit("} SkillID;")
        emit("")
        emitf("#define MAX_SKILLS %d", (ast.world and ast.world.max_skills) or 8)
        emit("typedef struct { int32_t level[MAX_SKILLS]; } CSkills;")
        emit("")
    end

    -- ANATOMY
    if #ast.anatomy > 0 then
        emit("/* ---- Anatomy Flags ---- */")
        emit("typedef enum {")
        for idx, an in ipairs(ast.anatomy) do emitf("    ANAT_%s = (1 << %d),", to_upper_snake(an.name), idx-1) end
        emit("} AnatomyFlag;")
        emit("typedef struct { uint32_t flags; } CAnatomy;")
        emit("")
    end

    -- BODY PARTS
    if #ast.bodyparts > 0 then
        emit("/* ---- Body Parts ---- */")
        emit("typedef enum {")
        emit("    BODYPART_NONE = 0,")
        for idx, bp in ipairs(ast.bodyparts) do emitf("    BODYPART_%s = %d,", to_upper_snake(bp.name), idx) end
        emitf("    BODYPART_COUNT = %d", #ast.bodyparts + 1)
        emit("} BodyPartID;")
        emit("")
        emit("static const char* BODYPART_NAMES[BODYPART_COUNT] = {")
        emit('    "None",')
        for _, bp in ipairs(ast.bodyparts) do
            emitf('    "%s",', bp.name:gsub("(%u)", " %1"):gsub("^ ", ""))
        end
        emit("};")
        emit("")
        emitf("#define MAX_BODY_PARTS %d", (ast.world and ast.world.max_body_parts) or 6)
        emit("typedef struct { EntityID part_entity[MAX_BODY_PARTS]; } CBodyParts;")
        emit("")
    end

    -- CONDITIONS
    emit("/* ---- Conditions ---- */")
    emit("typedef enum {")
    emit("    COND_NONE = 0,")
    for idx, cond in ipairs(ast.conditions) do emitf("    COND_%s = %d,", to_upper_snake(cond.name), idx) end
    emitf("    COND_COUNT = %d", #ast.conditions + 1)
    emit("} ConditionID;")
    emit("")

    -- EFFECTS
    emit("/* ---- Effects ---- */")
    emit("typedef enum {")
    emit("    EFFECT_NONE = 0,")
    for idx, eff in ipairs(ast.effects) do emitf("    EFFECT_%s = %d,", to_upper_snake(eff.name), idx) end
    emitf("    EFFECT_COUNT = %d", #ast.effects + 1)
    emit("} EffectID;")
    emit("")

    -- CAPABILITIES
    if #ast.capabilities > 0 then
        emit("/* ---- Capabilities ---- */")
        emit("typedef enum {")
        emit("    CAP_NONE = 0,")
        for idx, cap in ipairs(ast.capabilities) do emitf("    CAP_%s = %d,", to_upper_snake(cap.name), idx) end
        emitf("    CAP_COUNT = %d", #ast.capabilities + 1)
        emit("} CapabilityID;")
        emit("")
        emit("typedef struct { uint32_t required_anatomy; SkillID required_skill; int32_t min_skill_level; BodyPartID body_part_required; } CapabilityDef;")
        emit("")
        emit("static const CapabilityDef CAPABILITY_DEFS[CAP_COUNT] = {")
        emit("    /*CAP_NONE*/ { 0, SKILL_NONE, 0, BODYPART_NONE },")
        for _, cap in ipairs(ast.capabilities) do
            local anat_parts = {}
            for _, a in ipairs(cap.require_anatomy) do anat_parts[#anat_parts+1] = "ANAT_" .. to_upper_snake(a) end
            local anat_str = #anat_parts > 0 and table.concat(anat_parts, " | ") or "0"
            local skill_str = cap.skill and ("SKILL_" .. to_upper_snake(cap.skill)) or "SKILL_NONE"
            local bp_str = cap.body_part and ("BODYPART_" .. to_upper_snake(cap.body_part)) or "BODYPART_NONE"
            emitf("    /*CAP_%s*/ { %s, %s, %d, %s },", to_upper_snake(cap.name), anat_str, skill_str, cap.min_skill, bp_str)
        end
        emit("};")
        emit("typedef struct { uint32_t flags; } CCapabilities;")
        emit("")
    end

    -- AFFORDANCES
    if #ast.affordances > 0 then
        emit("/* ---- Affordances ---- */")
        emit("typedef enum {")
        emit("    AFF_NONE = 0,")
        for idx, aff in ipairs(ast.affordances) do emitf("    AFF_%s = %d,", to_upper_snake(aff.name), idx) end
        emitf("    AFF_COUNT = %d", #ast.affordances + 1)
        emit("} AffordanceID;")
        emit("")
        emit("typedef struct { CapabilityID required_cap; ConditionID condition; EffectID on_success; int32_t difficulty; int32_t crit_fail_threshold; BodyPartID crit_fail_bodypart; int32_t crit_fail_damage; } AffordanceDef;")
        emit("")
        emit("static const AffordanceDef AFFORDANCE_DEFS[AFF_COUNT] = {")
        emit("    /*AFF_NONE*/ { CAP_NONE, COND_NONE, EFFECT_NONE, 0, 0, BODYPART_NONE, 0 },")
        for _, aff in ipairs(ast.affordances) do
            local cap_str = aff.require_cap and ("CAP_" .. to_upper_snake(aff.require_cap)) or "CAP_NONE"
            local cond_str = aff.condition and ("COND_" .. to_upper_snake(aff.condition)) or "COND_NONE"
            local eff_str = aff.on_success and ("EFFECT_" .. to_upper_snake(aff.on_success)) or "EFFECT_NONE"
            local bp_str = aff.crit_fail_bodypart and ("BODYPART_" .. to_upper_snake(aff.crit_fail_bodypart)) or "BODYPART_NONE"
            emitf("    /*AFF_%s*/ { %s, %s, %s, %d, %d, %s, %d },",
                to_upper_snake(aff.name), cap_str, cond_str, eff_str, aff.difficulty, aff.crit_fail_threshold, bp_str, aff.crit_fail_damage)
        end
        emit("};")
        emit("typedef struct { uint32_t flags; } CAffordances;")
        emit("")
    end

    -- TOOL COMPONENT
    emit("/* ---- Tool Component ---- */")
    emit("typedef struct { MaterialID material; } CTool;")
    emit("")

    -- VERBS
    if #ast.verbs > 0 then
        emit("/* ---- Verbs ---- */")
        emit("typedef enum {")
        emit("    VERB_NONE = 0,")
        for idx, verb in ipairs(ast.verbs) do emitf("    VERB_%s = %d,", to_upper_snake(verb.name), idx) end
        emitf("    VERB_COUNT = %d", #ast.verbs + 1)
        emit("} VerbID;")
        emit("")
        emit("typedef struct { CapabilityID actor_cap; AffordanceID target_aff; } VerbDef;")
        emit("")
        emit("static const VerbDef VERB_DEFS[VERB_COUNT] = {")
        emit("    /*VERB_NONE*/ { CAP_NONE, AFF_NONE },")
        for _, verb in ipairs(ast.verbs) do
            local cap_str = verb.actor_cap and ("CAP_" .. to_upper_snake(verb.actor_cap)) or "CAP_NONE"
            local aff_str = verb.target_aff and ("AFF_" .. to_upper_snake(verb.target_aff)) or "AFF_NONE"
            emitf("    /*VERB_%s*/ { %s, %s },", to_upper_snake(verb.name), cap_str, aff_str)
        end
        emit("};")
        emit("")
    end

    -- INTERACTION RESULT
    emit("/* ---- Interaction Result ---- */")
    emit("typedef enum {")
    emit("    INTERACT_SUCCESS = 0, INTERACT_FAIL_NO_VERB = 1, INTERACT_FAIL_NO_CAP = 2,")
    emit("    INTERACT_FAIL_ANATOMY = 3, INTERACT_FAIL_BODY_PART = 4, INTERACT_FAIL_SKILL_LOW = 5,")
    emit("    INTERACT_FAIL_NO_AFF = 6, INTERACT_FAIL_CONDITION = 7, INTERACT_FAIL_ROLL = 8,")
    emit("    INTERACT_CRIT_FAIL = 9, INTERACT_FAIL_NO_RULE = 10, INTERACT_RESULT_COUNT")
    emit("} InteractResult;")
    emit("")
    emit("static const char* INTERACT_RESULT_NAMES[INTERACT_RESULT_COUNT] = {")
    emit('    "SUCCESS","FAIL:NO_VERB","FAIL:NO_CAP","FAIL:ANATOMY","FAIL:BODY_PART",')
    emit('    "FAIL:SKILL_LOW","FAIL:NO_AFF","FAIL:CONDITION","FAIL:ROLL","CRIT_FAIL","FAIL:NO_RULE"')
    emit("};")
    emit("")

    -- INTERACTION REQUEST
    emit("/* ---- Interaction Request ---- */")
    emit("#define MAX_INTERACTION_REQUESTS 64")
    emit("typedef struct { EntityID actor; EntityID target; VerbID verb; } InteractionRequest;")
    emit("")

    -- SYSTEMS
    if #ast.systems > 0 then
        emit("/* ---- Systems ---- */")
        emit("typedef enum {")
        for idx, sys in ipairs(ast.systems) do emitf("    SYS_%s = %d,", to_upper_snake(sys.name), idx-1) end
        emitf("    SYS_COUNT = %d", #ast.systems)
        emit("} SystemID;")
        emit("")
        emit("static const uint32_t SYSTEM_FREQ[SYS_COUNT] = {")
        for _, sys in ipairs(ast.systems) do emitf("    /*SYS_%s*/ %d,", to_upper_snake(sys.name), sys.frequency) end
        emit("};")
        emit("")
    end

    -- COMMAND TYPES (needed by RuleDef)
    emit("/* ---- Command/Rule Types ---- */")
    emit("typedef enum { CMD_NONE=0, CMD_DAMAGE_LAYER=1, CMD_MODIFY_STAT=2, CMD_TRANSFORM_ENTITY=3, CMD_MOVE_ENTITY=4, CMD_REMOVE_ENTITY=5, CMD_PLAY_FEEDBACK=6, CMD_CRIT_DAMAGE=7, CMD_TYPE_COUNT } CommandType;")
    emit("typedef enum { OP_ADD=0, OP_SUBTRACT=1, OP_SET=2 } StatOperation;")
    emit("typedef enum { CMD_TARGET_NONE=0, CMD_TARGET_ACTOR=1, CMD_TARGET_TARGET=2, CMD_TARGET_TOOL=3, CMD_TARGET_ENV=4 } CommandTargetRole;")
    emit("")
    emit("#define MAX_RULE_EFFECTS 8")
    emit("#define MAX_RULE_CONDS   4")
    emitf("#define GEN_RULE_COUNT   %d", #ast.rules)
    emit("")
    emit("typedef struct { CommandType type; CommandTargetRole target_role; uint32_t stat_id; int32_t amount; StatOperation stat_op; uint32_t new_def_id; uint32_t message_id; uint32_t bodypart_id; } RuleEffect;")
    emit("typedef struct { uint32_t rule_id; uint32_t trigger_verb; uint32_t required_cap; uint32_t cond_ids[MAX_RULE_CONDS]; uint32_t cond_count; int32_t difficulty; int32_t crit_fail_threshold; uint32_t crit_fail_bodypart; int32_t crit_fail_damage; RuleEffect effects[MAX_RULE_EFFECTS]; uint32_t effect_count; } RuleDef;")
    emit("")

    -- RULE DATA
    if #ast.rules > 0 then
        emitf("static const RuleDef GEN_RULES[%d] = {", #ast.rules)
        for idx, rule in ipairs(ast.rules) do
            local verb_str = rule.trigger_verb and ("VERB_" .. to_upper_snake(rule.trigger_verb)) or "VERB_NONE"
            local cap_str = rule.require_cap and ("CAP_" .. to_upper_snake(rule.require_cap)) or "CAP_NONE"
            local bp_str = rule.crit_fail_bodypart and ("BODYPART_" .. to_upper_snake(rule.crit_fail_bodypart)) or "BODYPART_NONE"
            emitf("    /* %s */ {", rule.name)
            emitf("        %d, %s, %s,", idx, verb_str, cap_str)
            -- conditions
            if #rule.conditions > 0 then
                local cs = {}
                for _, c in ipairs(rule.conditions) do cs[#cs+1] = "COND_" .. to_upper_snake(c) end
                emitf("        { %s }, %d,", table.concat(cs, ", "), #rule.conditions)
            else
                emit("        { 0 }, 0,")
            end
            emitf("        %d, %d, %s, %d,", rule.difficulty, rule.crit_fail_threshold, bp_str, rule.crit_fail_damage)
            -- effects
            if #rule.effects > 0 then
                emit("        {")
                for _, eff in ipairs(rule.effects) do
                    local cmd_str = "CMD_" .. eff.cmd_type
                    local tgt = "CMD_TARGET_NONE"
                    if eff.params.target then tgt = "CMD_TARGET_" .. eff.params.target:upper() end
                    local amt = eff.params.amount or 0
                    local sid = eff.params.stat_id or 0
                    local sop = "OP_ADD"
                    if eff.params.op == "subtract" then sop = "OP_SUBTRACT"
                    elseif eff.params.op == "set" then sop = "OP_SET" end
                    local ndf = eff.params.new_def_id or 0
                    local mid = eff.params.message_id or 0
                    emitf("            { %s, %s, %d, %d, %s, %d, %d, 0 },", cmd_str, tgt, sid, amt, sop, ndf, mid)
                end
                emitf("        }, %d", #rule.effects)
            else
                emit("        { { 0 } }, 0")
            end
            emit("    },")
        end
        emit("};")
        emit("")
    end

    -- CONDITION EVALUATOR
    emit("/* ---- Condition Evaluator (generated) ---- */")
    emit("static int gen_evaluate_condition(ConditionID cond, EntityID actor, EntityID target, const SparseSet* pool_tool, const SparseSet* pool_layers) {")
    emit("    switch (cond) {")
    emit("        case COND_NONE: return 1;")
    emit("        case COND_TOOL_HARDER_THAN_LAYER: {")
    emit("            const CTool* tool = (const CTool*)mc_sparse_set_get_const(pool_tool, actor);")
    emit("            const CLayerStack* stack = (const CLayerStack*)mc_sparse_set_get_const(pool_layers, target);")
    emit("            if (!tool || !stack || stack->layer_count == 0) return 0;")
    emit("            return MATERIAL_HARDNESS[tool->material] > MATERIAL_HARDNESS[stack->layers[0].material];")
    emit("        }")
    emit("        default: return 0;")
    emit("    }")
    emit("}")
    emit("")

    -- BODY PART INTEGRITY CHECK
    emit("/* ---- Body Part Integrity Check (generated) ---- */")
    emit("static int gen_check_body_part_integrity(BodyPartID bp_id, EntityID actor, const SparseSet* pool_bp, const SparseSet* pool_layers) {")
    emit("    const CBodyParts* bp; const CLayerStack* ls; EntityID part;")
    emit("    if (bp_id == BODYPART_NONE) return 1;")
    emit("    bp = (const CBodyParts*)mc_sparse_set_get_const(pool_bp, actor);")
    emit("    if (!bp) return 0;")
    emit("    part = bp->part_entity[bp_id];")
    emit("    if (part == MC_INVALID_INDEX) return 0;")
    emit("    ls = (const CLayerStack*)mc_sparse_set_get_const(pool_layers, part);")
    emit("    if (!ls || ls->layer_count == 0) return 0;")
    emit("    return ls->layers[0].integrity > 0;")
    emit("}")
    emit("")

    emit("#endif /* MARBLE_GEN_H */")
    return table.concat(out, "\n") .. "\n"
end

-- ============================================================
-- MAIN
-- ============================================================

local function main()
    local input_file = arg[1]
    local output_file = "marble_gen.h"
    if not input_file then
        io.stderr:write("Usage: lua marble_compile.lua <input.marble> [-o output.h]\n")
        os.exit(1)
    end
    if arg[2] == "-o" and arg[3] then output_file = arg[3] end

    io.write("marble_compile v" .. VERSION .. "\n")
    io.write("  Input:  " .. input_file .. "\n")
    io.write("  Output: " .. output_file .. "\n")

    local source = read_file(input_file)
    local ast = parse(source)
    ast._source_file = input_file

    io.write("  Parsed:\n")
    io.write("    materials:    " .. #ast.materials .. "\n")
    io.write("    skills:       " .. #ast.skills .. "\n")
    io.write("    anatomy:      " .. #ast.anatomy .. "\n")
    io.write("    bodyparts:    " .. #ast.bodyparts .. "\n")
    io.write("    conditions:   " .. #ast.conditions .. "\n")
    io.write("    effects:      " .. #ast.effects .. "\n")
    io.write("    capabilities: " .. #ast.capabilities .. "\n")
    io.write("    affordances:  " .. #ast.affordances .. "\n")
    io.write("    verbs:        " .. #ast.verbs .. "\n")
    io.write("    systems:      " .. #ast.systems .. "\n")
    io.write("    layers:       " .. #ast.layers .. "\n")
    io.write("    rules:        " .. #ast.rules .. "\n")

    local code = generate(ast)
    local f = io.open(output_file, "w")
    if not f then
        io.stderr:write("ERROR: cannot write to " .. output_file .. "\n")
        os.exit(1)
    end
    f:write(code)
    f:close()

    io.write("  Generated: " .. output_file .. " (" .. #code .. " bytes)\n")
    io.write("  Done.\n")
end

main()-- MindMarr.lua
-- MINDMARR: Mars Becomes Mind
-- d100 Roll-Under Survival Horror — Escape the sentient planet
-- Arrow keys move, bump-to-attack, collect supplies, reach the shuttle
-- Say "MINDMARR" and it's the last word you ever say

local root = UIElement:new({width=800, height=600})

local W, H = 800, 600
local sin, cos, rand, floor = math.sin, math.cos, math.random, math.floor
local abs, sqrt, max, min = math.abs, math.sqrt, math.max, math.min

local TS = 24
local MW, MH = 30, 22

-- Mars palette
local C = {
    void      = {4, 2, 6},
    wall      = {90, 40, 25},
    wallHi    = {120, 55, 35},
    floor     = {35, 18, 14},
    floorLit  = {55, 28, 22},
    player    = {60, 200, 255},
    infected  = {180, 40, 60},
    infGlow   = {220, 60, 80},
    supply    = {100, 220, 140},
    cell      = {180, 60, 200},
    shuttle   = {255, 220, 80},
    fog       = {6, 3, 8},
    blood     = {140, 30, 40},
    xp        = {200, 120, 255},
    crit      = {255, 200, 60},
    miss      = {100, 80, 80},
    hit       = {255, 80, 60},
    hud_bg    = {12, 6, 10},
    hud_border= {80, 35, 50},
    mars      = {200, 60, 40},
    whisper   = {160, 50, 70},
    sanity    = {120, 180, 255},
    oxygen    = {80, 200, 220},
}

-- Infected speech fragments — they only say one word
local MINDMARR_SAYS = {
    "mindmarr...", "MINDMARR!", "mind...marr...", "mindmarr", "MiNdMaRr",
    "m i n d m a r r", "MINDMARR MINDMARR", "...mindmarr...",
    "mindmarr?", "MINDMARR.", "mind...m a r r...", "mindmarrMINDMARR",
}

-- Game state
local game = {
    state = "title",
    sector = 1,         -- floor equivalent
    maxSectors = 7,     -- reach sector 7 shuttle bay to win
    turn = 0,
    messages = {},
    maxMessages = 6,
    shakeTimer = 0,
    shakeIntensity = 0,
    particles = {},
    camX = 0, camY = 0,
    inputCooldown = 0,
    keyWasDown = {},
    marsWhisperTimer = 0,
    pulseTimer = 0,
    won = false,
}

-- Player (survivor)
local player = {
    x = 0, y = 0,
    hp = 30, maxHp = 30,
    str = 55,       -- melee hit
    def = 40,       -- dodge
    dmgMin = 2, dmgMax = 5,
    armor = 0,
    xp = 0,
    xpNext = 20,
    level = 1,
    sanity = 100,   -- max 100, mars drains it
    oxygen = 100,   -- each sector costs O2
    medkits = 1,
    cells = 0,      -- power cells for shuttle
    cellsNeeded = 3,
    kills = 0,
    critBonus = 5,
    seen = {},
}

local map = {}
local enemies = {}
local items = {}
local shuttle = {x = 0, y = 0}

-- Particles
local function spawnParticles(x, y, count, r, g, b, speed, life)
    for i = 1, count do
        local a = rand() * math.pi * 2
        local s = rand() * speed + speed * 0.2
        game.particles[#game.particles+1] = {
            x = x, y = y,
            vx = cos(a) * s, vy = sin(a) * s,
            life = life * (0.4 + rand() * 0.6),
            maxLife = life,
            r = r, g = g, b = b,
            size = rand() < 0.3 and 3 or 2,
        }
    end
end

local function screenShake(intensity, duration)
    game.shakeTimer = duration
    game.shakeIntensity = intensity
end

local function addMessage(text, r, g, b)
    table.insert(game.messages, 1, {text = text, r = r or 200, g = g or 200, b = b or 200, age = 0})
    if #game.messages > game.maxMessages then
        table.remove(game.messages)
    end
end

local function d100()
    return rand(1, 100)
end

-- Map gen
local function tileAt(x, y)
    if x < 1 or x > MW or y < 1 or y > MH then return 1 end
    return map[y][x]
end

local function setTile(x, y, v)
    if x >= 1 and x <= MW and y >= 1 and y <= MH then
        map[y][x] = v
    end
end

local function carveRoom(rx, ry, rw, rh)
    for y = ry, ry + rh - 1 do
        for x = rx, rx + rw - 1 do
            setTile(x, y, 0)
        end
    end
    return {x = rx, y = ry, w = rw, h = rh,
            cx = floor(rx + rw/2), cy = floor(ry + rh/2)}
end

local function carveCorridor(x1, y1, x2, y2)
    local x, y = x1, y1
    while x ~= x2 do
        setTile(x, y, 0)
        x = x + (x2 > x and 1 or -1)
    end
    while y ~= y2 do
        setTile(x, y, 0)
        y = y + (y2 > y and 1 or -1)
    end
end

local function generateMap()
    map = {}
    for y = 1, MH do
        map[y] = {}
        for x = 1, MW do
            map[y][x] = 1
        end
    end

    local rooms = {}
    local attempts = 0
    local numRooms = rand(6, 9) + floor(game.sector / 2)

    while #rooms < numRooms and attempts < 200 do
        attempts = attempts + 1
        local rw = rand(3, 7)
        local rh = rand(3, 5)
        local rx = rand(2, MW - rw - 1)
        local ry = rand(2, MH - rh - 1)

        local ok = true
        for _, r in ipairs(rooms) do
            if rx < r.x + r.w + 1 and rx + rw + 1 > r.x and
               ry < r.y + r.h + 1 and ry + rh + 1 > r.y then
                ok = false; break
            end
        end

        if ok then
            local room = carveRoom(rx, ry, rw, rh)
            if #rooms > 0 then
                local prev = rooms[#rooms]
                if rand() < 0.5 then
                    carveCorridor(prev.cx, prev.cy, room.cx, prev.cy)
                    carveCorridor(room.cx, prev.cy, room.cx, room.cy)
                else
                    carveCorridor(prev.cx, prev.cy, prev.cx, room.cy)
                    carveCorridor(prev.cx, room.cy, room.cx, room.cy)
                end
            end
            rooms[#rooms+1] = room
        end
    end

    for i = 1, floor(#rooms / 3) do
        local a = rooms[rand(1, #rooms)]
        local b = rooms[rand(1, #rooms)]
        if a ~= b then carveCorridor(a.cx, a.cy, b.cx, b.cy) end
    end

    return rooms
end

-- Infected templates
local function infectedTemplate(sector)
    local templates = {
        {name="Scientist",    glyph="S", hp=7,  str=30, def=15, dmgMin=1, dmgMax=3, xp=5,  color={180,100,120}},
        {name="Technician",   glyph="T", hp=10, str=40, def=20, dmgMin=2, dmgMax=4, xp=8,  color={160,80,100}},
        {name="Security",     glyph="G", hp=14, str=50, def=25, dmgMin=2, dmgMax=5, xp=12, color={200,70,90}},
        {name="Commander",    glyph="C", hp=20, str=55, def=30, dmgMin=3, dmgMax=7, xp=20, color={220,50,70}},
        {name="MarsSpawn",    glyph="M", hp=16, str=60, def=45, dmgMin=3, dmgMax=6, xp=25, color={200,40,60}},
        {name="Hivemind",     glyph="H", hp=35, str=65, def=30, dmgMin=5, dmgMax=10,xp=40, color={180,30,80}},
        {name="MINDMARR",     glyph="@", hp=50, str=75, def=40, dmgMin=6, dmgMax=12,xp=60, color={255,20,50}},
    }

    local maxIdx = min(#templates, 2 + floor(sector / 2))
    local minIdx = max(1, maxIdx - 3)
    local t = templates[rand(minIdx, maxIdx)]

    local scale = 1.0 + (sector - 1) * 0.12
    return {
        name = t.name,
        glyph = t.glyph,
        hp = floor(t.hp * scale),
        maxHp = floor(t.hp * scale),
        str = min(90, floor(t.str + sector * 2)),
        def = min(80, floor(t.def + sector)),
        dmgMin = t.dmgMin + floor(sector / 3),
        dmgMax = t.dmgMax + floor(sector / 3),
        xp = floor(t.xp * scale),
        color = t.color,
        alive = true,
        sayTimer = 0,
        lastSaid = "",
    }
end

local function populateFloor(rooms)
    enemies = {}
    items = {}

    player.x = rooms[1].cx
    player.y = rooms[1].cy

    -- Shuttle/airlock in last room (only on final sector it's the shuttle)
    shuttle.x = rooms[#rooms].cx
    shuttle.y = rooms[#rooms].cy

    -- Enemies
    local numEnemies = 3 + game.sector * 2 + rand(0, 2)
    for i = 1, numEnemies do
        local room = rooms[rand(2, #rooms)]
        local ex = rand(room.x, room.x + room.w - 1)
        local ey = rand(room.y, room.y + room.h - 1)
        if not (ex == player.x and ey == player.y) and tileAt(ex, ey) == 0 then
            local e = infectedTemplate(game.sector)
            e.x = ex
            e.y = ey
            enemies[#enemies+1] = e
        end
    end

    -- Items
    for i = 2, #rooms do
        local room = rooms[i]
        if rand() < 0.35 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "supply",
                amount = rand(2, 6) + game.sector,
            }
        end
        if rand() < 0.2 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "medkit",
            }
        end
        -- Power cells are rare
        if rand() < 0.15 and player.cells < player.cellsNeeded then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "cell",
            }
        end
        -- Oxygen canister
        if rand() < 0.2 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "oxygen",
            }
        end
    end
end

-- FOV
local function computeFOV()
    local radius = 6
    for a = 0, 359, 2 do
        local rad = a * math.pi / 180
        local dx = cos(rad)
        local dy = sin(rad)
        local fx, fy = player.x + 0.5, player.y + 0.5
        for d = 0, radius do
            local tx, ty = floor(fx), floor(fy)
            if tx < 1 or tx > MW or ty < 1 or ty > MH then break end
            player.seen[ty * 1000 + tx] = 2
            if tileAt(tx, ty) == 1 then break end
            fx = fx + dx * 0.5
            fy = fy + dy * 0.5
        end
    end
end

local function dimFOV()
    for k, v in pairs(player.seen) do
        if v == 2 then player.seen[k] = 1 end
    end
end

local function isVisible(x, y)
    return (player.seen[y * 1000 + x] or 0) == 2
end

local function isSeen(x, y)
    return (player.seen[y * 1000 + x] or 0) >= 1
end

local function enemyAt(x, y)
    for _, e in ipairs(enemies) do
        if e.alive and e.x == x and e.y == y then return e end
    end
    return nil
end

-- Mars whisper — sanity drain events
local marsWhispers = {
    "The ground pulses beneath you...",
    "You hear your name spoken from below...",
    "The walls are breathing...",
    "Something remembers you were born...",
    "Mars knows your mother's name...",
    "The red dust rearranges into a face...",
    "You feel the planet thinking...",
    "Your shadow moved on its own...",
    "The air tastes like someone else's memory...",
    "mind...marr... NO. Focus.",
    "A voice in the static: 'Join us.'",
    "Your reflection blinked before you did...",
}

local function marsWhisper()
    if player.sanity > 0 then
        local drain = rand(1, 3)
        player.sanity = max(0, player.sanity - drain)
        local w = marsWhispers[rand(1, #marsWhispers)]
        addMessage(w, C.whisper[1], C.whisper[2], C.whisper[3])
        if player.sanity <= 0 then
            -- sanity gone = you say the word
            game.state = "mindmarr"
            addMessage("Your lips move on their own...", 255, 40, 60)
            addMessage("You whisper: \"mindmarr\"", 255, 20, 40)
            addMessage("It's the last word you ever say.", 255, 0, 0)
            screenShake(10, 0.6)
            spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 50, 200, 30, 60, 150, 1.2)
        end
    end
end

-- Combat
local function resolveMelee(attacker, defender, atkName, defName, atkStr, defDef, dmgMin, dmgMax, onDone)
    local roll = d100()
    local hit = roll <= atkStr
    local crit = false
    if attacker == player then crit = roll <= player.critBonus end

    if not hit then
        addMessage(atkName .. " > " .. defName .. ": d100=" .. roll .. " vs " .. atkStr .. " MISS", C.miss[1], C.miss[2], C.miss[3])
        spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 3, 100, 80, 80, 30, 0.3)
    else
        local dRoll = d100()
        local dodged = dRoll <= defDef

        if dodged then
            addMessage(defName .. " evades! d100=" .. dRoll .. " vs " .. defDef, C.miss[1], C.miss[2], C.miss[3])
            spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 4, 150, 150, 255, 40, 0.3)
        else
            local dmg = rand(dmgMin, dmgMax)
            if crit then
                dmg = dmg * 2
                addMessage(atkName .. " CRITS " .. defName .. "! d100=" .. roll .. " DMG:" .. dmg, C.crit[1], C.crit[2], C.crit[3])
                screenShake(5, 0.2)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 15, 255, 200, 60, 80, 0.5)
            else
                addMessage(atkName .. " hits " .. defName .. " d100=" .. roll .. " DMG:" .. dmg, C.hit[1], C.hit[2], C.hit[3])
                screenShake(3, 0.1)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 8, 255, 80, 60, 60, 0.4)
            end

            if defender == player and player.armor > 0 then
                local reduced = max(1, dmg - player.armor)
                if reduced < dmg then
                    addMessage("  Suit absorbs " .. (dmg - reduced), 160, 160, 180)
                end
                dmg = reduced
            end

            defender.hp = defender.hp - dmg

            -- Enemy hit drains sanity
            if defender == player and rand() < 0.3 then
                player.sanity = max(0, player.sanity - rand(1, 2))
                addMessage("  Your mind fractures...", C.whisper[1], C.whisper[2], C.whisper[3])
            end
        end
    end

    -- Infected scream mindmarr on attack
    if attacker ~= player then
        local say = MINDMARR_SAYS[rand(1, #MINDMARR_SAYS)]
        addMessage("  " .. atkName .. ": \"" .. say .. "\"", C.infected[1], C.infected[2], C.infected[3])
    end

    if onDone then onDone() end
end

local function checkEnemyDeath(e)
    if e.hp <= 0 then
        e.alive = false
        -- Death cry
        addMessage(e.name .. " collapses: \"mind...marr...\" (+" .. e.xp .. " XP)", C.xp[1], C.xp[2], C.xp[3])
        spawnParticles(e.x * TS + TS/2, e.y * TS + TS/2, 20, e.color[1], e.color[2], e.color[3], 100, 0.6)
        screenShake(4, 0.15)
        player.xp = player.xp + e.xp
        player.kills = player.kills + 1

        if rand() < 0.4 then
            items[#items+1] = {x = e.x, y = e.y, type = "supply", amount = rand(1, 4) + game.sector}
        end

        if player.xp >= player.xpNext then
            game.state = "levelup"
            player.level = player.level + 1
            player.xpNext = floor(player.xpNext * 1.6)
            addMessage("*** ADAPT — Level " .. player.level .. " ***", 255, 255, 100)
            spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 25, 60, 200, 255, 120, 0.8)
            screenShake(3, 0.2)
        end
    end
end

local function checkPlayerDeath()
    if player.hp <= 0 then
        player.hp = 0
        game.state = "dead"
        addMessage("Your body joins the Mindmarr.", 255, 50, 50)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 40, 200, 30, 50, 150, 1.0)
        screenShake(8, 0.4)
    end
end

local function checkSanityDeath()
    if player.sanity <= 0 and game.state == "playing" then
        game.state = "mindmarr"
        addMessage("Your lips move: \"mindmarr\"", 255, 20, 40)
        addMessage("The last word you ever say.", 255, 0, 0)
        screenShake(10, 0.6)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 50, 200, 30, 60, 150, 1.2)
    end
end

-- Enemy AI
local function moveEnemies()
    for _, e in ipairs(enemies) do
        if not e.alive then goto continue end

        local dx = player.x - e.x
        local dy = player.y - e.y
        local adist = abs(dx) + abs(dy)

        if adist > 10 then goto continue end

        -- Nearby enemies mumble
        if adist <= 6 and rand() < 0.08 then
            local say = MINDMARR_SAYS[rand(1, #MINDMARR_SAYS)]
            addMessage(e.name .. ": \"" .. say .. "\"", C.infected[1], C.infected[2], C.infected[3])
            if rand() < 0.3 then
                player.sanity = max(0, player.sanity - 1)
            end
        end

        if adist == 1 then
            resolveMelee(e, player, e.name, "You", e.str, player.def, e.dmgMin, e.dmgMax)
            checkPlayerDeath()
            checkSanityDeath()
            goto continue
        end

        local mx, my = 0, 0
        if abs(dx) >= abs(dy) then
            mx = dx > 0 and 1 or -1
        else
            my = dy > 0 and 1 or -1
        end

        local nx, ny = e.x + mx, e.y + my
        if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
            e.x = nx; e.y = ny
        else
            if mx ~= 0 then
                my = dy > 0 and 1 or (dy < 0 and -1 or 0); mx = 0
            else
                mx = dx > 0 and 1 or (dx < 0 and -1 or 0); my = 0
            end
            nx, ny = e.x + mx, e.y + my
            if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
                e.x = nx; e.y = ny
            end
        end

        ::continue::
    end
end

local function newFloor()
    player.seen = {}
    local rooms = generateMap()
    populateFloor(rooms)
    dimFOV()
    computeFOV()

    -- O2 cost per sector transition
    if game.sector > 1 then
        local o2cost = rand(5, 12)
        player.oxygen = max(0, player.oxygen - o2cost)
        addMessage("Airlock transit: -" .. o2cost .. " O2", C.oxygen[1], C.oxygen[2], C.oxygen[3])
        if player.oxygen <= 0 then
            game.state = "dead"
            addMessage("Suffocated between sectors.", 255, 50, 50)
            screenShake(6, 0.3)
            return
        end
    end

    if game.sector == game.maxSectors then
        addMessage("== SECTOR " .. game.sector .. ": SHUTTLE BAY ==", 255, 220, 80)
        addMessage("The shuttle is HERE. Reach it!", 255, 255, 150)
    else
        addMessage("-- Sector " .. game.sector .. " / " .. game.maxSectors .. " --", 255, 180, 100)
    end

    -- Mars whispers more in deeper sectors
    if rand(1, 100) <= game.sector * 12 then
        marsWhisper()
    end
end

-- Level up
local levelChoices = {
    {name = "+5 Max HP & heal",      apply = function() player.maxHp = player.maxHp + 5; player.hp = player.maxHp end},
    {name = "+8 STR (hit chance)",    apply = function() player.str = min(95, player.str + 8) end},
    {name = "+8 DEF (dodge)",         apply = function() player.def = min(85, player.def + 8) end},
    {name = "+2 Max Damage",          apply = function() player.dmgMax = player.dmgMax + 2 end},
    {name = "+1 Suit Armor",          apply = function() player.armor = player.armor + 1 end},
    {name = "+15 Sanity restored",    apply = function() player.sanity = min(100, player.sanity + 15) end},
    {name = "+3 Crit Range",          apply = function() player.critBonus = min(25, player.critBonus + 3) end},
}

local function resetGame()
    game.state = "playing"
    game.sector = 1
    game.turn = 0
    game.messages = {}
    game.particles = {}
    game.marsWhisperTimer = 0
    game.won = false

    player.hp = 30; player.maxHp = 30
    player.str = 55; player.def = 40
    player.dmgMin = 2; player.dmgMax = 5
    player.armor = 0
    player.xp = 0; player.xpNext = 20
    player.level = 1
    player.sanity = 100; player.oxygen = 100
    player.medkits = 1; player.cells = 0
    player.cellsNeeded = 3
    player.kills = 0; player.critBonus = 5
    player.seen = {}

    addMessage("Arrows: move/attack. M: medkit. Escape Mars alive.", 180, 180, 220)
    addMessage("Don't lose your mind. Don't say the word.", 200, 60, 80)
    newFloor()
end

-- Player action
local function tryMove(dx, dy)
    if game.state ~= "playing" then return end

    local nx, ny = player.x + dx, player.y + dy

    local e = enemyAt(nx, ny)
    if e then
        resolveMelee(player, e, "You", e.name, player.str, e.def, player.dmgMin, player.dmgMax)
        checkEnemyDeath(e)
        if game.state ~= "dead" and game.state ~= "mindmarr" then
            game.turn = game.turn + 1
            moveEnemies()
            -- Mars whispers every N turns
            game.marsWhisperTimer = game.marsWhisperTimer + 1
            if game.marsWhisperTimer >= (8 - min(5, game.sector)) then
                game.marsWhisperTimer = 0
                marsWhisper()
            end
        end
        dimFOV(); computeFOV()
        checkSanityDeath()
        return
    end

    if tileAt(nx, ny) == 0 then
        player.x = nx; player.y = ny

        -- Items
        for i = #items, 1, -1 do
            local it = items[i]
            if it.x == nx and it.y == ny then
                if it.type == "supply" then
                    player.xp = player.xp + it.amount
                    addMessage("Scavenged supplies (+" .. it.amount .. " XP)", C.supply[1], C.supply[2], C.supply[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 100, 220, 140, 40, 0.3)
                    if player.xp >= player.xpNext then
                        game.state = "levelup"
                        player.level = player.level + 1
                        player.xpNext = floor(player.xpNext * 1.6)
                        addMessage("*** ADAPT — Level " .. player.level .. " ***", 255, 255, 100)
                        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 25, 60, 200, 255, 120, 0.8)
                    end
                elseif it.type == "medkit" then
                    player.medkits = player.medkits + 1
                    addMessage("Found a medkit!", 100, 255, 150)
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 100, 255, 150, 40, 0.3)
                elseif it.type == "cell" then
                    player.cells = player.cells + 1
                    addMessage("POWER CELL acquired! (" .. player.cells .. "/" .. player.cellsNeeded .. ")", C.cell[1], C.cell[2], C.cell[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 12, 180, 60, 200, 60, 0.5)
                    screenShake(2, 0.1)
                elseif it.type == "oxygen" then
                    local o2 = rand(10, 20)
                    player.oxygen = min(100, player.oxygen + o2)
                    addMessage("O2 canister: +" .. o2 .. " oxygen", C.oxygen[1], C.oxygen[2], C.oxygen[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 80, 200, 220, 40, 0.3)
                end
                table.remove(items, i)
            end
        end

        -- Shuttle/airlock
        if nx == shuttle.x and ny == shuttle.y then
            if game.sector == game.maxSectors then
                -- Final escape
                if player.cells >= player.cellsNeeded then
                    game.state = "won"
                    game.won = true
                    addMessage("You ignite the shuttle engines!", 255, 255, 100)
                    addMessage("ESCAPED! Mars screams behind you.", 80, 255, 120)
                    spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 50, 255, 220, 80, 200, 1.5)
                    screenShake(6, 0.5)
                    return
                else
                    addMessage("Shuttle needs " .. (player.cellsNeeded - player.cells) .. " more power cells!", 255, 100, 100)
                end
            else
                game.sector = game.sector + 1
                newFloor()
                return
            end
        end

        game.turn = game.turn + 1
        moveEnemies()

        game.marsWhisperTimer = game.marsWhisperTimer + 1
        if game.marsWhisperTimer >= (8 - min(5, game.sector)) then
            game.marsWhisperTimer = 0
            marsWhisper()
        end

        dimFOV(); computeFOV()
        checkSanityDeath()
    end
end

local function useMedkit()
    if player.medkits > 0 and player.hp < player.maxHp then
        player.medkits = player.medkits - 1
        local heal = floor(player.maxHp * 0.4) + rand(1, 5)
        player.hp = min(player.maxHp, player.hp + heal)
        addMessage("Used medkit: +" .. heal .. " HP", 100, 255, 150)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 10, 100, 255, 150, 50, 0.4)
        game.turn = game.turn + 1
        moveEnemies()
        dimFOV(); computeFOV()
    end
end

-- Input
local function keyPressed(key)
    if not bridge.getKeyState then return false end
    local down = bridge.getKeyState(key) == 1
    local was = game.keyWasDown[key] or false
    game.keyWasDown[key] = down
    return down and not was
end

-- Drawing
local function drawTile(sx, sy, tx, ty)
    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local px = camOX + tx * TS + sx
    local py = camOY + ty * TS + sy
    local mapAreaH = floor(H * 0.65)

    if px < -TS or px > W + TS or py < -TS or py > mapAreaH + TS then return end

    local vis = isVisible(tx, ty)
    local seen = isSeen(tx, ty)
    local tile = tileAt(tx, ty)

    if not seen then
        bridge.drawRect(px, py, TS, TS, C.void[1], C.void[2], C.void[3], 255)
        return
    end

    local dim = vis and 1.0 or 0.3

    -- Mars pulse — faint red flicker on walls when deep
    local marsPulse = 0
    if vis and game.sector > 2 then
        marsPulse = sin(game.pulseTimer * 2 + tx * 0.3 + ty * 0.5) * 8 * (game.sector / game.maxSectors)
    end

    if tile == 1 then
        local cr, cg, cb = C.wall[1], C.wall[2], C.wall[3]
        if (tx + ty) % 3 == 0 then cr, cg, cb = C.wallHi[1], C.wallHi[2], C.wallHi[3] end
        cr = min(255, cr + marsPulse)
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        if vis and ty > 1 and tileAt(tx, ty-1) == 0 then
            bridge.drawRect(px, py, TS, 2, floor(100*dim), floor(50*dim), floor(40*dim), 255)
        end
    else
        local cr, cg, cb = C.floor[1], C.floor[2], C.floor[3]
        if vis then cr, cg, cb = C.floorLit[1], C.floorLit[2], C.floorLit[3] end
        cr = min(255, cr + marsPulse * 0.5)
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        if (tx * 7 + ty * 13) % 11 == 0 then
            bridge.drawRect(px + 4, py + 4, 2, 2, floor(cr*dim*0.6), floor(cg*dim*0.6), floor(cb*dim*0.6), 255)
        end
        -- Mars dust particles on floors in deeper sectors
        if vis and game.sector >= 3 and (tx * 3 + ty * 7) % 17 == 0 then
            bridge.drawRect(px + rand(2, TS-4), py + rand(2, TS-4), 1, 1, 140, 50, 30, 60)
        end
    end
end

function DrawGame()
    local sx, sy = 0, 0
    if game.shakeTimer > 0 then
        sx = floor((rand() - 0.5) * game.shakeIntensity * 2)
        sy = floor((rand() - 0.5) * game.shakeIntensity * 2)
    end

    bridge.drawRect(0, 0, W, H, C.void[1], C.void[2], C.void[3], 255)

    -- TITLE
    if game.state == "title" then
        bridge.drawRect(0, 0, W, H, 8, 3, 6, 255)
        -- Mars surface line
        for x = 0, W, 4 do
            local yy = H * 0.55 + sin(x * 0.02 + game.pulseTimer) * 8
            bridge.drawRect(x, yy, 4, H - yy, 50, 15, 10, 80)
        end

        bridge.drawText("M I N D M A R R", W/2 - 70, H/4 - 10, 255, 40, 50, 255)
        bridge.drawText("Mars is alive. Mars remembers.", W/2 - 105, H/4 + 18, 180, 60, 70, 255)

        bridge.drawText("You are a survivor. The colony is lost.", W/2 - 130, H/2 - 20, 160, 140, 150, 255)
        bridge.drawText("Everyone speaks only one word now.", W/2 - 120, H/2, 160, 140, 150, 255)
        bridge.drawText("If you say it, you join them.", W/2 - 100, H/2 + 20, 200, 60, 70, 255)

        bridge.drawText("Arrow Keys: Move & Fight", W/2 - 85, H/2 + 55, 140, 140, 160, 255)
        bridge.drawText("M: Medkit    Reach the shuttle.", W/2 - 100, H/2 + 75, 140, 140, 160, 255)

        local flicker = sin(game.pulseTimer * 3) > 0 and 255 or 180
        bridge.drawText("PRESS SPACE", W/2 - 40, H * 0.82, flicker, flicker, min(255, flicker + 20), 255)
        return
    end

    -- WON
    if game.state == "won" then
        bridge.drawRect(0, 0, W, H, 4, 8, 15, 255)
        -- Stars
        for i = 1, 60 do
            local sx2 = (i * 137 + floor(game.pulseTimer * 10)) % W
            local sy2 = (i * 211) % H
            bridge.drawRect(sx2, sy2, 1, 1, 255, 255, 255, rand(100, 255))
        end

        bridge.drawText("E S C A P E D", W/2 - 55, H/4, 80, 255, 120, 255)
        bridge.drawText("Mars screams behind you, but you don't look back.", W/2 - 170, H/4 + 30, 160, 200, 180, 255)

        bridge.drawText("Level: " .. player.level .. "  Kills: " .. player.kills, W/2 - 70, H/2, 200, 200, 220, 255)
        bridge.drawText("Sanity: " .. player.sanity .. "%  O2: " .. player.oxygen .. "%", W/2 - 80, H/2 + 20, C.sanity[1], C.sanity[2], C.sanity[3], 255)
        bridge.drawText("Cells: " .. player.cells .. "  Sectors cleared: " .. game.maxSectors, W/2 - 100, H/2 + 40, C.cell[1], C.cell[2], C.cell[3], 255)

        local score = player.kills * 10 + player.sanity * 5 + player.oxygen * 2 + game.maxSectors * 100
        bridge.drawText("Score: " .. score, W/2 - 35, H/2 + 70, 255, 220, 80, 255)

        bridge.drawText("PRESS SPACE TO PLAY AGAIN", W/2 - 90, H * 0.8, 180, 180, 200, 255)
        return
    end

    -- MINDMARR (sanity death)
    if game.state == "mindmarr" then
        local pulse = sin(game.pulseTimer * 4) * 0.3 + 0.7
        bridge.drawRect(0, 0, W, H, floor(30 * pulse), floor(5 * pulse), floor(8 * pulse), 255)

        bridge.drawText("m i n d m a r r", W/2 - 60, H/4, 255, floor(40 * pulse), floor(50 * pulse), 255)
        bridge.drawText("You are one of them now.", W/2 - 80, H/4 + 30, 200, 60, 70, 255)
        bridge.drawText("Your mouth only forms one word.", W/2 - 110, H/4 + 55, 180, 50, 60, 255)

        -- Scrolling mindmarr text
        for i = 0, 12 do
            local yy = H/2 + 10 + i * 16
            local off = floor(game.pulseTimer * 40 + i * 50) % W
            local alpha = max(40, 200 - i * 15)
            bridge.drawText("mindmarr mindmarr mindmarr mindmarr mindmarr", -off + W/2, yy,
                floor(200 * pulse), 30, 40, alpha)
        end

        bridge.drawText("Floor: " .. game.sector .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4, H * 0.82, 200, 200, 200, 200)
        bridge.drawText("PRESS SPACE", W/2 - 40, H * 0.9, 180, 100, 110, 255)
        return
    end

    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local mapAreaH = floor(H * 0.65)

    -- Map tiles
    local startTX = max(1, floor(-camOX / TS) - 1)
    local endTX = min(MW, floor((-camOX + W) / TS) + 2)
    local startTY = max(1, floor(-camOY / TS) - 1)
    local endTY = min(MH, floor((-camOY + mapAreaH) / TS) + 2)

    for ty = startTY, endTY do
        for tx = startTX, endTX do
            drawTile(sx, sy, tx, ty)
        end
    end

    -- Shuttle/airlock
    if isVisible(shuttle.x, shuttle.y) then
        local stX = camOX + shuttle.x * TS + sx
        local stY = camOY + shuttle.y * TS + sy
        if game.sector == game.maxSectors then
            -- Shuttle glow
            local glow = sin(game.pulseTimer * 3) * 20 + 220
            bridge.drawRect(stX + 2, stY + 2, TS - 4, TS - 4, floor(glow), floor(glow * 0.85), 40, 255)
            bridge.drawRect(stX + 5, stY + 5, TS - 10, TS - 10, 200, 180, 60, 255)
            bridge.drawText("^", stX + 8, stY + 4, 255, 255, 200, 255)
        else
            bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, C.shuttle[1], C.shuttle[2], C.shuttle[3], 255)
            bridge.drawText(">", stX + 8, stY + 5, 255, 240, 180, 255)
        end
    elseif isSeen(shuttle.x, shuttle.y) then
        local stX = camOX + shuttle.x * TS + sx
        local stY = camOY + shuttle.y * TS + sy
        bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, 60, 50, 25, 255)
    end

    -- Items
    for _, it in ipairs(items) do
        if isVisible(it.x, it.y) then
            local ix = camOX + it.x * TS + sx
            local iy = camOY + it.y * TS + sy
            if it.type == "supply" then
                bridge.drawRect(ix + 7, iy + 7, 10, 10, C.supply[1], C.supply[2], C.supply[3], 255)
                bridge.drawRect(ix + 9, iy + 9, 5, 5, 140, 255, 180, 255)
            elseif it.type == "medkit" then
                bridge.drawRect(ix + 6, iy + 6, 12, 12, 255, 80, 80, 255)
                bridge.drawRect(ix + 10, iy + 7, 4, 10, 255, 255, 255, 255)
                bridge.drawRect(ix + 7, iy + 10, 10, 4, 255, 255, 255, 255)
            elseif it.type == "cell" then
                local cg = sin(game.pulseTimer * 4) * 40 + 180
                bridge.drawRect(ix + 5, iy + 4, 14, 16, floor(cg), 50, floor(cg * 1.1), 255)
                bridge.drawRect(ix + 8, iy + 7, 8, 10, 220, 80, 240, 255)
            elseif it.type == "oxygen" then
                bridge.drawRect(ix + 7, iy + 5, 10, 14, C.oxygen[1], C.oxygen[2], C.oxygen[3], 255)
                bridge.drawRect(ix + 9, iy + 3, 6, 4, 60, 160, 180, 255)
            end
        end
    end

    -- Enemies
    for _, e in ipairs(enemies) do
        if e.alive and isVisible(e.x, e.y) then
            local ex = camOX + e.x * TS + sx
            local ey = camOY + e.y * TS + sy
            -- Red pulsing aura
            local aura = sin(game.pulseTimer * 5 + e.x) * 15
            bridge.drawRect(ex + 2, ey + 2, TS - 4, TS - 4,
                min(255, e.color[1] + floor(aura)), min(255, e.color[2]), min(255, e.color[3]), 255)
            bridge.drawRect(ex + 5, ey + 5, TS - 10, TS - 10,
                min(255, e.color[1]+30), min(255, e.color[2]+20), min(255, e.color[3]+20), 255)
            -- HP bar
            if e.hp < e.maxHp then
                local barW = TS - 4
                local hpFrac = e.hp / e.maxHp
                bridge.drawRect(ex + 2, ey - 3, barW, 3, 40, 10, 15, 200)
                bridge.drawRect(ex + 2, ey - 3, floor(barW * hpFrac), 3, 255, 40, 50, 255)
            end
        end
    end

    -- Player
    if game.state ~= "dead" then
        local px_draw = camOX + player.x * TS + sx
        local py_draw = camOY + player.y * TS + sy
        -- Suit
        bridge.drawRect(px_draw + 2, py_draw + 2, TS - 4, TS - 4, C.player[1], C.player[2], C.player[3], 255)
        bridge.drawRect(px_draw + 5, py_draw + 5, TS - 10, TS - 10, 100, 220, 255, 255)
        -- Visor
        bridge.drawRect(px_draw + 7, py_draw + 6, 10, 5, 20, 60, 80, 255)
        bridge.drawRect(px_draw + 8, py_draw + 7, 8, 3, 40, 140, 180, 255)
    end

    -- Particles
    for _, p in ipairs(game.particles) do
        local alpha = floor(255 * (p.life / p.maxLife))
        if alpha > 0 then
            local ppx = camOX + p.x + sx
            local ppy = camOY + p.y + sy
            if ppx > -10 and ppx < W + 10 and ppy > -10 and ppy < mapAreaH + 10 then
                bridge.drawRect(ppx - p.size/2, ppy - p.size/2, p.size, p.size, p.r, p.g, p.b, alpha)
            end
        end
    end

    -- HUD
    local hudY = mapAreaH + 2
    local hudH = H - hudY
    bridge.drawRect(0, hudY, W, hudH, C.hud_bg[1], C.hud_bg[2], C.hud_bg[3], 255)
    bridge.drawRect(0, hudY, W, 2, C.hud_border[1], C.hud_border[2], C.hud_border[3], 255)

    local col1 = 10
    local ly = hudY + 6

    -- Row 1: Level, Sector
    bridge.drawText("LVL:" .. player.level, col1, ly, 255, 255, 150, 255)
    bridge.drawText("SECTOR:" .. game.sector .. "/" .. game.maxSectors, col1 + 55, ly, 255, 180, 100, 255)

    ly = ly + 14

    -- Row 2: HP bar
    bridge.drawText("HP:", col1, ly, 200, 200, 200, 255)
    local barX = col1 + 28
    local barW = 80
    local barH = 10
    bridge.drawRect(barX, ly, barW, barH, 40, 10, 15, 255)
    local hpW = floor(barW * (player.hp / player.maxHp))
    local hpR = player.hp <= player.maxHp * 0.3 and 255 or 50
    local hpG = player.hp <= player.maxHp * 0.3 and 50 or 200
    bridge.drawRect(barX, ly, hpW, barH, hpR, hpG, 50, 255)
    bridge.drawText(player.hp .. "/" .. player.maxHp, barX + barW + 4, ly, 200, 200, 200, 255)

    -- Sanity bar
    local sanX = barX + barW + 55
    bridge.drawText("SAN:", sanX, ly, C.sanity[1], C.sanity[2], C.sanity[3], 255)
    local sanBarX = sanX + 32
    bridge.drawRect(sanBarX, ly, 60, barH, 20, 20, 40, 255)
    local sanW = floor(60 * (player.sanity / 100))
    local sanR = player.sanity <= 25 and 200 or C.sanity[1]
    local sanG = player.sanity <= 25 and 50 or C.sanity[2]
    bridge.drawRect(sanBarX, ly, sanW, barH, sanR, sanG, C.sanity[3], 255)
    bridge.drawText(player.sanity .. "%", sanBarX + 63, ly, C.sanity[1], C.sanity[2], C.sanity[3], 255)

    ly = ly + 14

    -- Row 3: Stats
    bridge.drawText("STR:" .. player.str .. " DEF:" .. player.def .. " DMG:" .. player.dmgMin .. "-" .. player.dmgMax, col1, ly, 180, 160, 170, 255)

    -- O2
    local o2X = 260
    bridge.drawText("O2:", o2X, ly, C.oxygen[1], C.oxygen[2], C.oxygen[3], 255)
    bridge.drawText(player.oxygen .. "%", o2X + 24, ly, C.oxygen[1], C.oxygen[2], C.oxygen[3], 255)

    ly = ly + 14

    -- Row 4: Items
    bridge.drawText("ARM:" .. player.armor .. " CRIT:<=" .. player.critBonus, col1, ly, 160, 150, 170, 255)
    bridge.drawText("XP:" .. player.xp .. "/" .. player.xpNext, col1 + 160, ly, C.xp[1], C.xp[2], C.xp[3], 255)

    ly = ly + 14

    -- Row 5
    bridge.drawText("Medkits:" .. player.medkits, col1, ly, 255, 100, 100, 255)
    bridge.drawText("Cells:" .. player.cells .. "/" .. player.cellsNeeded, col1 + 90, ly, C.cell[1], C.cell[2], C.cell[3], 255)
    bridge.drawText("Kills:" .. player.kills, col1 + 210, ly, 200, 140, 140, 255)

    -- Message log
    local msgX = W/2 + 20
    local msgY = hudY + 8
    bridge.drawText("-- Transmission Log --", msgX, msgY, 100, 70, 90, 255)
    for i, msg in ipairs(game.messages) do
        local alpha = max(80, 255 - i * 25)
        bridge.drawText(msg.text, msgX, msgY + i * 13, msg.r, msg.g, msg.b, alpha)
        if msgY + i * 13 > H - 5 then break end
    end

    -- Level up overlay
    if game.state == "levelup" then
        bridge.drawRect(W/4, H/4, W/2, H/2, 10, 8, 20, 240)
        bridge.drawRect(W/4, H/4, W/2, 2, 60, 200, 255, 255)
        bridge.drawText("ADAPT — Choose an upgrade:", W/4 + 20, H/4 + 12, 100, 230, 255, 255)
        for i, choice in ipairs(levelChoices) do
            local y = H/4 + 30 + (i-1) * 22
            bridge.drawRect(W/4 + 15, y, W/2 - 30, 18, 25, 18, 40, 200)
            bridge.drawText(i .. ") " .. choice.name, W/4 + 22, y + 2, 200, 220, 240, 255)
        end
    end

    -- Death overlay
    if game.state == "dead" then
        bridge.drawRect(W/4, H/3, W/2, H/4, 25, 5, 8, 230)
        bridge.drawRect(W/4, H/3, W/2, 2, 255, 40, 50, 255)
        bridge.drawText("SIGNAL LOST", W/4 + 55, H/3 + 15, 255, 50, 60, 255)
        bridge.drawText("Sector: " .. game.sector .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4 + 15, H/3 + 35, 200, 200, 200, 255)
        local score = player.kills * 10 + game.sector * 50
        bridge.drawText("Score: " .. score, W/4 + 60, H/3 + 52, 255, 200, 80, 255)
        bridge.drawText("PRESS SPACE TO TRY AGAIN", W/4 + 25, H/3 + 75, 180, 180, 180, 255)
    end
end

-- Main update
function UpdateUI(mx, my, down, w, h)
    W, H = w, h
    root.width = w
    root.height = h
    local dt = 0.016

    game.pulseTimer = game.pulseTimer + dt

    if game.shakeTimer > 0 then
        game.shakeTimer = game.shakeTimer - dt
    end

    -- Particles
    for i = #game.particles, 1, -1 do
        local p = game.particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.life = p.life - dt
        p.vx = p.vx * 0.95
        p.vy = p.vy * 0.95
        if p.life <= 0 then table.remove(game.particles, i) end
    end

    for _, msg in ipairs(game.messages) do
        msg.age = msg.age + dt
    end

    -- Title
    if game.state == "title" then
        if keyPressed("space") then resetGame() end
        return
    end

    -- Dead / mindmarr / won
    if game.state == "dead" or game.state == "mindmarr" or game.state == "won" then
        if keyPressed("space") then resetGame() end
        return
    end

    -- Level up
    if game.state == "levelup" then
        for i = 1, #levelChoices do
            if keyPressed(tostring(i)) then
                levelChoices[i].apply()
                addMessage("Adapted: " .. levelChoices[i].name, 100, 230, 255)
                game.state = "playing"
                break
            end
        end
        return
    end

    -- Playing
    game.inputCooldown = max(0, game.inputCooldown - dt)

    if game.state == "playing" then
        if keyPressed("up") or keyPressed("w") then tryMove(0, -1)
        elseif keyPressed("down") or keyPressed("s") then tryMove(0, 1)
        elseif keyPressed("left") or keyPressed("a") then tryMove(-1, 0)
        elseif keyPressed("right") or keyPressed("d") then tryMove(1, 0)
        elseif keyPressed("m") then useMedkit()
        end
    end
end

function DrawUI()
    DrawGame()
end-- demo.lua
-- Comprehensive demonstration of all UI primitives

local root = UIElement:new({width=800, height=600})

-- ===================================================
-- Main container with VBox layout
-- ===================================================
local mainPanel = Panel:new({
    x = 50, y = 20, 
    width = 700, height = 550,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
mainPanel:setPadding(15)
root:addChild(mainPanel)

-- Title
local title = Label:new({
    text = "Project Bridge UI - Complete Primitives Demo",
    width = 670, 
    height = 30,
    alignment = "center",
    textColor = {255, 200, 100, 255}
})
mainPanel:addChild(title)

-- ===================================================
-- Section 1: Buttons & Labels
-- ===================================================
local buttonSection = Panel:new({
    x = 15, y = 45,
    width = 670, height = 120,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 1
})
buttonSection:setPadding(10)
mainPanel:addChild(buttonSection)

local sectionLabel1 = Label:new({
    text = "Buttons & Events",
    width = 650, height = 20,
    alignment = "left",
    textColor = {200, 200, 255, 255}
})
buttonSection:addChild(sectionLabel1)

-- Status label
local statusLabel = Label:new({
    x = 10, y = 30,
    text = "Status: Ready",
    width = 650, height = 20,
    alignment = "left"
})
buttonSection:addChild(statusLabel)

-- HBox for buttons
local btnRow = HBox:new({
    x = 10, y = 55,
    width = 650, height = 45,
    spacing = 10
})

for i = 1, 4 do
    local btn = Button:new({width = 155, height = 45})
    btn.onHover = function()
        statusLabel.text = "Hovered: Button " .. i
    end
    btn.onClick = function()
        statusLabel.text = "Clicked: Button " .. i
    end
    
    local lbl = Label:new({
        text = "Button " .. i,
        width = 155, height = 45,
        alignment = "center"
    })
    btn:addChild(lbl)
    btnRow:addChild(btn)
end

buttonSection:addChild(btnRow)

-- ===================================================
-- Section 2: Layout Systems
-- ===================================================
local layoutSection = Panel:new({
    x = 15, y = 175,
    width = 670, height = 160,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 1
})
layoutSection:setPadding(10)
mainPanel:addChild(layoutSection)

local sectionLabel2 = Label:new({
    text = "Layout Groups: VBox, HBox, GridLayout",
    width = 650, height = 20,
    alignment = "left",
    textColor = {100, 255, 150, 255}
})
layoutSection:addChild(sectionLabel2)

-- VBox example
local vbox = VBox:new({
    x = 10, y = 30,
    width = 100, height = 120,
    spacing = 5,
    expandChildren = true
})
for i = 1, 3 do
    local btn = Button:new({height = 30})
    local lbl = Label:new({text = "V" .. i, height = 30, alignment = "center"})
    btn:addChild(lbl)
    vbox:addChild(btn)
end
layoutSection:addChild(vbox)

-- HBox example
local hbox = HBox:new({
    x = 120, y = 30,
    width = 250, height = 35,
    spacing = 5
})
for i = 1, 4 do
    local btn = Button:new({width = 55, height = 35})
    local lbl = Label:new({text = "H" .. i, width = 55, height = 35, alignment = "center"})
    btn:addChild(lbl)
    hbox:addChild(btn)
end
layoutSection:addChild(hbox)

-- GridLayout example
local grid = GridLayout:new({
    x = 120, y = 75,
    width = 250, height = 75,
    columns = 4,
    spacing = 5,
    expandChildren = true
})
for i = 1, 8 do
    local btn = Button:new({})
    local lbl = Label:new({text = tostring(i), alignment = "center"})
    btn:addChild(lbl)
    grid:addChild(btn)
end
layoutSection:addChild(grid)

-- Label alignment showcase
local alignBox = VBox:new({
    x = 380, y = 30,
    width = 260, height = 120,
    spacing = 2
})

local alignments = {
    {text = "Left Align", align = "left"},
    {text = "Center", align = "center"},
    {text = "Right", align = "right"}
}

for _, cfg in ipairs(alignments) do
    local bg = Panel:new({
        width = 260, height = 25,
        bgColor = {50, 50, 50, 255},
        borderColor = {70, 70, 70, 255},
        borderThickness = 1
    })
    local lbl = Label:new({
        text = cfg.text,
        width = 260, height = 25,
        alignment = cfg.align,
        textColor = {200, 255, 255, 255}
    })
    bg:addChild(lbl)
    alignBox:addChild(bg)
end
layoutSection:addChild(alignBox)

-- ===================================================
-- Section 3: Sliders & Progress Bars
-- ===================================================
local controlSection = Panel:new({
    x = 15, y = 345,
    width = 670, height = 120,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 1
})
controlSection:setPadding(10)
mainPanel:addChild(controlSection)

local sectionLabel3 = Label:new({
    text = "Sliders & Progress Bars",
    width = 650, height = 20,
    alignment = "left",
    textColor = {255, 150, 100, 255}
})
controlSection:addChild(sectionLabel3)

-- Progress bar 1
local progressBar1 = ProgressBar:new({
    x = 10, y = 30,
    width = 300, height = 25
})
progressBar1:setValue(0.5)
controlSection:addChild(progressBar1)

-- Value label (define BEFORE slider callback uses it)
local progressValueLabel = Label:new({
    x = 10, y = 85,
    text = "Value: 50%",
    width = 300, height = 20
})
controlSection:addChild(progressValueLabel)

-- Slider 1
local slider1 = Slider:new({
    x = 10, y = 60,
    width = 300
})
slider1.value = 0.5
slider1.onValueChanged = function(val)
    progressBar1:setValue(val)
    progressValueLabel.text = string.format("Value: %d%%", math.floor(val * 100))
end
controlSection:addChild(slider1)

-- Health bar styled
local healthBar = ProgressBar:new({
    x = 320, y = 30,
    width = 330, height = 25,
    fillColor = {200, 60, 60, 255},
    emptyColor = {60, 30, 30, 255}
})
healthBar:setValue(0.75)
controlSection:addChild(healthBar)

local healthLabel = Label:new({
    x = 320, y = 60,
    text = "Health: 75/100",
    width = 330, height = 20,
    textColor = {255, 100, 100, 255},
})
controlSection:addChild(healthLabel)

-- ===================================================
-- Section 4: Toggles & Indicators
-- ===================================================
local toggleSection = Panel:new({
    x = 15, y = 475,
    width = 320, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 1
})
toggleSection:setPadding(10)
mainPanel:addChild(toggleSection)

local sectionLabel4 = Label:new({
    text = "Toggles & Indicators",
    width = 300, height = 20,
    alignment = "left",
    textColor = {200, 255, 200, 255}
})
toggleSection:addChild(sectionLabel4)

-- Toggle row
local toggleRow = HBox:new({
    x = 10, y = 30,
    width = 300, height = 24,
    spacing = 10
})

for i = 1, 3 do
    local toggle = Toggle:new({size = 24})
    toggleRow:addChild(toggle)
    
    local label = Label:new({
        text = "Option " .. i,
        width = 70, height = 24,
        alignment = "left"
    })
    toggleRow:addChild(label)
end

toggleSection:addChild(toggleRow)

-- Color indicators
local indicatorSection = Panel:new({
    x = 345, y = 475,
    width = 340, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 1
})
indicatorSection:setPadding(10)
mainPanel:addChild(indicatorSection)

local sectionLabel5 = Label:new({
    text = "Status Indicators",
    width = 320, height = 20,
    alignment = "left",
    textColor = {255, 255, 100, 255}
})
indicatorSection:addChild(sectionLabel5)

local indicatorRow = HBox:new({
    x = 10, y = 30,
    width = 320, height = 24,
    spacing = 10
})

local greenInd = ColorIndicator:new({
    width = 80, height = 24,
    baseColor = {60, 180, 60, 255}
})
indicatorRow:addChild(greenInd)

local yellowInd = ColorIndicator:new({
    width = 80, height = 24,
    baseColor = {200, 180, 60, 255},
    pulsing = true
})
indicatorRow:addChild(yellowInd)

local redInd = ColorIndicator:new({
    width = 80, height = 24,
    baseColor = {200, 60, 60, 255},
    pulsing = true
})
indicatorRow:addChild(redInd)

indicatorSection:addChild(indicatorRow)

-- ===================================================
-- Global Functions called by C Host
-- ===================================================
function UpdateUI(mx, my, down, w, h)
    root.width = w
    root.height = h
    root:update(mx, my, down, w, h)
end

function DrawUI()
    root:draw()
end-- demo_complete.lua
-- Comprehensive demonstration of ALL UI widgets

local root = UIElement:new({width=1200, height=800})

-- ===================================================
-- DEMO 1: Buttons & Labels with Full Event System
-- ===================================================
local buttonDemo = Panel:new({
    x = 20, y = 20,
    width = 280, height = 200,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
buttonDemo:setPadding(10)
root:addChild(buttonDemo)

local buttonTitle = Label:new({
    text = "Button Events Demo",
    width = 260, height = 25,
    alignment = "center",
    textColor = {200, 200, 255, 255}
})
buttonDemo:addChild(buttonTitle)

-- Status label to show events
local statusLabel = Label:new({
    x = 10, y = 35,
    text = "Status: Ready",
    width = 260, height = 20,
    alignment = "left"
})
buttonDemo:addChild(statusLabel)

-- Button with ALL events
local interactiveBtn = Button:new({
    x = 10, y = 60,
    width = 260, height = 40,
    normalColor = {60, 100, 140, 255},
    hoverColor = {80, 120, 160, 255},
    pressedColor = {40, 80, 120, 255}
})
interactiveBtn.onHover = function()
    statusLabel.text = "Status: Hovered!"
end
interactiveBtn.onPress = function()
    statusLabel.text = "Status: Pressed!"
end
interactiveBtn.onClick = function()
    statusLabel.text = "Status: Clicked!"
end
interactiveBtn.onRelease = function()
    statusLabel.text = "Status: Released!"
end
buttonDemo:addChild(interactiveBtn)

local btnLabel = Label:new({
    text = "Interactive Button", 
    width = 260, height = 40,
    alignment = "center"
})
interactiveBtn:addChild(btnLabel)

-- Disabled button demo
local disabledBtn = Button:new({
    x = 10, y = 110,
    width = 260, height = 40
})
disabledBtn.isEnabled = false
buttonDemo:addChild(disabledBtn)

local disabledLabel = Label:new({
    text = "Disabled Button",
    width = 260, height = 40,
    alignment = "center",
    textColor = {150, 150, 150, 255}
})
disabledBtn:addChild(disabledLabel)

-- Toggle disabled state
local enableToggle = Toggle:new({
    x = 10, y = 160,
    size = 24,
    isToggled = false
})
enableToggle.onToggleChanged = function(state)
    disabledBtn.isEnabled = state
    if state then
        disabledLabel.text = "Enabled Button"
        disabledLabel.textColor = {255, 255, 255, 255}
    else
        disabledLabel.text = "Disabled Button"
        disabledLabel.textColor = {150, 150, 150, 255}
    end
end
buttonDemo:addChild(enableToggle)

local toggleLabel = Label:new({
    x = 40, y = 160,
    text = "Enable button above",
    width = 220, height = 24,
    alignment = "left"
})
buttonDemo:addChild(toggleLabel)

-- ===================================================
-- DEMO 2: Layout Systems (VBox, HBox, GridLayout)
-- ===================================================
local layoutDemo = Panel:new({
    x = 320, y = 20,
    width = 400, height = 300,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
layoutDemo:setPadding(10)
root:addChild(layoutDemo)

local layoutTitle = Label:new({
    text = "Layout Systems",
    width = 380, height = 25,
    alignment = "center",
    textColor = {255, 200, 100, 255}
})
layoutDemo:addChild(layoutTitle)

-- HBox Demo
local hbox = HBox:new({
    x = 10, y = 35,
    width = 380, height = 40,
    spacing = 10,
    alignment = "center"
})
for i = 1, 4 do
    local btn = Button:new({width = 80, height = 40})
    local lbl = Label:new({text = "Btn " .. i, width = 80, height = 40, alignment = "center"})
    btn:addChild(lbl)
    hbox:addChild(btn)
end
layoutDemo:addChild(hbox)

-- VBox Demo
local vbox = VBox:new({
    x = 10, y = 85,
    width = 180, height = 200,
    spacing = 5,
    expandChildren = true
})
for i = 1, 4 do
    local btn = Button:new({height = 35})
    local lbl = Label:new({text = "Item " .. i, height = 35, alignment = "center"})
    btn:addChild(lbl)
    vbox:addChild(btn)
end
layoutDemo:addChild(vbox)

-- GridLayout Demo
local grid = GridLayout:new({
    x = 200, y = 85,
    width = 180, height = 200,
    columns = 3,
    spacing = 5,
    expandChildren = true
})
for i = 1, 9 do
    local btn = Button:new({})
    local lbl = Label:new({text = tostring(i), alignment = "center"})
    btn:addChild(lbl)
    grid:addChild(btn)
end
layoutDemo:addChild(grid)

-- ===================================================
-- DEMO 3: ProgressBar & Sliders
-- ===================================================
local progressDemo = Panel:new({
    x = 740, y = 20,
    width = 300, height = 200,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
progressDemo:setPadding(10)
root:addChild(progressDemo)

local progressTitle = Label:new({
    text = "Progress & Sliders",
    width = 280, height = 25,
    alignment = "center",
    textColor = {100, 255, 150, 255}
})
progressDemo:addChild(progressTitle)

-- Progress bar
local progressBar = ProgressBar:new({
    x = 10, y = 40,
    width = 280, height = 30
})
progressBar:setValue(0.5)
progressDemo:addChild(progressBar)

-- Slider to control progress
local progressSlider = Slider:new({
    x = 10, y = 80,
    width = 280
})
progressSlider.value = 0.5
progressSlider.onValueChanged = function(val)
    progressBar:setValue(val)
    progressValueLabel.text = string.format("Progress: %d%%", math.floor(val * 100))
end
progressDemo:addChild(progressSlider)

local progressValueLabel = Label:new({
    x = 10, y = 110,
    text = "Progress: 50%",
    width = 280, height = 20
})
progressDemo:addChild(progressValueLabel)

-- Another styled progress bar
local healthBar = ProgressBar:new({
    x = 10, y = 140,
    width = 280, height = 25,
    fillColor = {200, 60, 60, 255},
    emptyColor = {60, 30, 30, 255}
})
healthBar:setValue(0.75)
progressDemo:addChild(healthBar)

local healthLabel = Label:new({
    x = 10, y = 170,
    text = "Health: 75%",
    width = 280, height = 20,
    textColor = {255, 100, 100, 255}
})
progressDemo:addChild(healthLabel)

-- ===================================================
-- DEMO 4: Toggles & ColorIndicators
-- ===================================================
local indicatorDemo = Panel:new({
    x = 20, y = 240,
    width = 280, height = 250,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
indicatorDemo:setPadding(10)
root:addChild(indicatorDemo)

local indicatorTitle = Label:new({
    text = "Toggles & Indicators",
    width = 260, height = 25,
    alignment = "center",
    textColor = {255, 150, 200, 255}
})
indicatorDemo:addChild(indicatorTitle)

-- Toggle switches
local toggleGroup = VBox:new({
    x = 10, y = 35,
    width = 260, height = 100,
    spacing = 8
})

for i = 1, 3 do
    local toggleRow = HBox:new({
        width = 260, height = 24,
        spacing = 10
    })
    
    local toggle = Toggle:new({size = 24})
    toggleRow:addChild(toggle)
    
    local label = Label:new({
        text = "Option " .. i,
        width = 200, height = 24,
        alignment = "left"
    })
    toggleRow:addChild(label)
    
    toggleGroup:addChild(toggleRow)
end
indicatorDemo:addChild(toggleGroup)

-- Color indicators
local indicatorLabel = Label:new({
    x = 10, y = 145,
    text = "Status Indicators:",
    width = 260, height = 20
})
indicatorDemo:addChild(indicatorLabel)

local statusRow = HBox:new({
    x = 10, y = 170,
    width = 260, height = 30,
    spacing = 10
})

local greenIndicator = ColorIndicator:new({
    width = 60, height = 30,
    baseColor = {60, 180, 60, 255},
    pulsing = false
})
statusRow:addChild(greenIndicator)

local yellowIndicator = ColorIndicator:new({
    width = 60, height = 30,
    baseColor = {200, 180, 60, 255},
    pulsing = true
})
statusRow:addChild(yellowIndicator)

local redIndicator = ColorIndicator:new({
    width = 60, height = 30,
    baseColor = {200, 60, 60, 255},
    pulsing = true
})
statusRow:addChild(redIndicator)

indicatorDemo:addChild(statusRow)

local pulseToggle = Toggle:new({
    x = 10, y = 210,
    size = 24,
    isToggled = true
})
pulseToggle.onToggleChanged = function(state)
    yellowIndicator.pulsing = state
    redIndicator.pulsing = state
end
indicatorDemo:addChild(pulseToggle)

local pulseLabel = Label:new({
    x = 40, y = 210,
    text = "Enable pulsing",
    width = 220, height = 24
})
indicatorDemo:addChild(pulseLabel)

-- ===================================================
-- DEMO 5: Draggable Window
-- ===================================================
local window = Window:new({
    x = 320, y = 340,
    width = 400, height = 300
})
root:addChild(window)

-- Window title label (on title bar)
local windowTitleLabel = Label:new({
    x = 10, y = 5,
    text = "Draggable Window (Drag Me!)",
    width = 380, height = 20,
    textColor = {255, 255, 255, 255}
})
window:addChild(windowTitleLabel)

-- Content in window
local windowContent = VBox:new({
    x = 10, y = 40,
    width = 380, height = 250,
    spacing = 10
})

local welcomeLabel = Label:new({
    text = "This is a draggable window!",
    width = 380, height = 25,
    alignment = "center",
    textColor = {200, 255, 200, 255}
})
windowContent:addChild(welcomeLabel)

local infoLabel = Label:new({
    text = "Click and drag the title bar to move",
    width = 380, height = 20,
    alignment = "center"
})
windowContent:addChild(infoLabel)

-- Add some buttons to window
for i = 1, 3 do
    local btn = Button:new({height = 35})
    local lbl = Label:new({
        text = "Window Action " .. i,
        height = 35,
        alignment = "center"
    })
    btn:addChild(lbl)
    windowContent:addChild(btn)
end

window:addContent(windowContent)

-- ===================================================
-- DEMO 6: Label Alignment Showcase
-- ===================================================
local alignmentDemo = Panel:new({
    x = 740, y = 240,
    width = 300, height = 250,
    bgColor = {45, 45, 48, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
alignmentDemo:setPadding(10)
root:addChild(alignmentDemo)

local alignTitle = Label:new({
    text = "Label Alignments",
    width = 280, height = 25,
    alignment = "center",
    textColor = {255, 255, 100, 255}
})
alignmentDemo:addChild(alignTitle)

-- Left aligned
local leftBox = Panel:new({
    x = 10, y = 35,
    width = 280, height = 30,
    bgColor = {60, 60, 60, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 1
})
local leftLabel = Label:new({
    text = "Left Aligned",
    width = 280, height = 30,
    alignment = "left",
    textColor = {255, 200, 200, 255}
})
leftBox:addChild(leftLabel)
alignmentDemo:addChild(leftBox)

-- Center aligned
local centerBox = Panel:new({
    x = 10, y = 75,
    width = 280, height = 30,
    bgColor = {60, 60, 60, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 1
})
local centerLabel = Label:new({
    text = "Center Aligned",
    width = 280, height = 30,
    alignment = "center",
    textColor = {200, 255, 200, 255}
})
centerBox:addChild(centerLabel)
alignmentDemo:addChild(centerBox)

-- Right aligned
local rightBox = Panel:new({
    x = 10, y = 115,
    width = 280, height = 30,
    bgColor = {60, 60, 60, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 1
})
local rightLabel = Label:new({
    text = "Right Aligned",
    width = 280, height = 30,
    alignment = "right",
    textColor = {200, 200, 255, 255}
})
rightBox:addChild(rightLabel)
alignmentDemo:addChild(rightBox)

-- Top-left aligned
local topleftBox = Panel:new({
    x = 10, y = 155,
    width = 280, height = 80,
    bgColor = {60, 60, 60, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 1
})
local topleftLabel = Label:new({
    text = "Top-Left\nMulti-line\nText",
    width = 280, height = 80,
    alignment = "topleft",
    textColor = {255, 255, 200, 255}
})
topleftBox:addChild(topleftLabel)
alignmentDemo:addChild(topleftBox)

-- ===================================================
-- Global Functions called by C Host
-- ===================================================
function UpdateUI(mx, my, down, w, h)
    root.width = w
    root.height = h
    root:update(mx, my, down, w, h)
end

function DrawUI()
    root:draw()
end-- dungeon_crawl.lua
-- D100 Roll-Under Roguelike Dungeon Crawler
-- Arrow keys move, bump-to-attack, collect loot, descend floors
-- All checks are d100 roll-under: roll <= stat = success

local root = UIElement:new({width=800, height=600})

local W, H = 800, 600
local sin, cos, rand, floor = math.sin, math.cos, math.random, math.floor
local abs, sqrt, max, min = math.abs, math.sqrt, math.max, math.min

-- Tile size and map dimensions
local TS = 24
local MW, MH = 30, 22

-- Colors
local C = {
    void     = {8, 6, 16},
    wall     = {45, 38, 55},
    wallHi   = {65, 55, 78},
    floor    = {22, 20, 30},
    floorLit = {32, 28, 42},
    player   = {80, 255, 120},
    enemy    = {255, 70, 70},
    gold     = {255, 220, 50},
    potion   = {100, 200, 255},
    stairs   = {255, 180, 50},
    fog      = {12, 10, 20},
    blood    = {120, 20, 20},
    xp       = {180, 130, 255},
    crit     = {255, 255, 80},
    miss     = {120, 120, 120},
    hit      = {255, 100, 80},
    hud_bg   = {15, 12, 25},
    hud_border = {60, 50, 80},
}

-- Game state
local game = {
    state = "title", -- title, playing, dead, levelup, rolling
    floor_num = 1,
    turn = 0,
    messages = {},
    maxMessages = 6,
    shakeTimer = 0,
    shakeIntensity = 0,
    rollAnim = nil,     -- active roll animation
    particles = {},
    camX = 0, camY = 0,
    inputCooldown = 0,
    keyWasDown = {},
}

-- Player
local player = {
    x = 0, y = 0,
    hp = 30, maxHp = 30,
    str = 55,    -- melee hit chance
    def = 40,    -- dodge chance
    dmgMin = 2, dmgMax = 6,
    armor = 0,
    xp = 0,
    xpNext = 20,
    level = 1,
    gold = 0,
    potions = 1,
    kills = 0,
    critBonus = 5,  -- roll under this = crit
    seen = {},      -- fog of war
}

-- Map
local map = {}
local enemies = {}
local items = {}
local stairs = {x = 0, y = 0}

-- Particles
local function spawnParticles(x, y, count, r, g, b, speed, life)
    for i = 1, count do
        local a = rand() * math.pi * 2
        local s = rand() * speed + speed * 0.2
        game.particles[#game.particles+1] = {
            x = x, y = y,
            vx = cos(a) * s, vy = sin(a) * s,
            life = life * (0.4 + rand() * 0.6),
            maxLife = life,
            r = r, g = g, b = b,
            size = rand() < 0.3 and 3 or 2,
        }
    end
end

local function screenShake(intensity, duration)
    game.shakeTimer = duration
    game.shakeIntensity = intensity
end

local function addMessage(text, r, g, b)
    table.insert(game.messages, 1, {text = text, r = r or 200, g = g or 200, b = b or 200, age = 0})
    if #game.messages > game.maxMessages then
        table.remove(game.messages)
    end
end

-- Roll a d100 (1-100)
local function d100()
    return rand(1, 100)
end

-- Roll with animation
local function rollD100(callback, label)
    game.rollAnim = {
        timer = 0,
        duration = 0.45,
        currentFace = rand(1, 100),
        finalRoll = d100(),
        callback = callback,
        label = label or "d100",
        flickerRate = 0.03,
        flickerTimer = 0,
        done = false,
    }
end

-- Map generation - BSP-ish rooms + corridors
local function tileAt(x, y)
    if x < 1 or x > MW or y < 1 or y > MH then return 1 end
    return map[y][x]
end

local function setTile(x, y, v)
    if x >= 1 and x <= MW and y >= 1 and y <= MH then
        map[y][x] = v
    end
end

local function carveRoom(rx, ry, rw, rh)
    for y = ry, ry + rh - 1 do
        for x = rx, rx + rw - 1 do
            setTile(x, y, 0)
        end
    end
    return {x = rx, y = ry, w = rw, h = rh,
            cx = floor(rx + rw/2), cy = floor(ry + rh/2)}
end

local function carveCorridor(x1, y1, x2, y2)
    local x, y = x1, y1
    while x ~= x2 do
        setTile(x, y, 0)
        x = x + (x2 > x and 1 or -1)
    end
    while y ~= y2 do
        setTile(x, y, 0)
        y = y + (y2 > y and 1 or -1)
    end
end

local function generateMap()
    -- Init walls
    map = {}
    for y = 1, MH do
        map[y] = {}
        for x = 1, MW do
            map[y][x] = 1
        end
    end

    local rooms = {}
    local attempts = 0
    local numRooms = rand(6, 9) + floor(game.floor_num / 2)

    while #rooms < numRooms and attempts < 200 do
        attempts = attempts + 1
        local rw = rand(3, 7)
        local rh = rand(3, 5)
        local rx = rand(2, MW - rw - 1)
        local ry = rand(2, MH - rh - 1)

        -- Check overlap
        local ok = true
        for _, r in ipairs(rooms) do
            if rx < r.x + r.w + 1 and rx + rw + 1 > r.x and
               ry < r.y + r.h + 1 and ry + rh + 1 > r.y then
                ok = false
                break
            end
        end

        if ok then
            local room = carveRoom(rx, ry, rw, rh)
            if #rooms > 0 then
                local prev = rooms[#rooms]
                if rand() < 0.5 then
                    carveCorridor(prev.cx, prev.cy, room.cx, prev.cy)
                    carveCorridor(room.cx, prev.cy, room.cx, room.cy)
                else
                    carveCorridor(prev.cx, prev.cy, prev.cx, room.cy)
                    carveCorridor(prev.cx, room.cy, room.cx, room.cy)
                end
            end
            rooms[#rooms+1] = room
        end
    end

    -- Extra corridors for loops
    for i = 1, floor(#rooms / 3) do
        local a = rooms[rand(1, #rooms)]
        local b = rooms[rand(1, #rooms)]
        if a ~= b then
            carveCorridor(a.cx, a.cy, b.cx, b.cy)
        end
    end

    return rooms
end

-- Enemy templates scaled by floor
local function enemyTemplate(floor_n)
    local templates = {
        {name="Rat",       glyph="r", hp=6,  str=30, def=15, dmgMin=1, dmgMax=3, xp=5,  color={180,140,100}},
        {name="Skeleton",  glyph="s", hp=10, str=40, def=25, dmgMin=2, dmgMax=5, xp=10, color={220,220,200}},
        {name="Goblin",    glyph="g", hp=8,  str=45, def=30, dmgMin=2, dmgMax=4, xp=8,  color={80,180,60}},
        {name="Orc",       glyph="o", hp=18, str=55, def=20, dmgMin=3, dmgMax=7, xp=18, color={100,160,60}},
        {name="Wraith",    glyph="w", hp=14, str=60, def=50, dmgMin=3, dmgMax=6, xp=22, color={150,120,220}},
        {name="Troll",     glyph="T", hp=30, str=50, def=15, dmgMin=5, dmgMax=10,xp=35, color={80,120,60}},
        {name="Demon",     glyph="D", hp=25, str=70, def=40, dmgMin=4, dmgMax=9, xp=40, color={255,50,80}},
    }

    -- Pick from templates available at this floor depth
    local maxIdx = min(#templates, 2 + floor(floor_n / 2))
    local minIdx = max(1, maxIdx - 3)
    local t = templates[rand(minIdx, maxIdx)]

    -- Scale slightly with floor
    local scale = 1.0 + (floor_n - 1) * 0.12
    return {
        name = t.name,
        glyph = t.glyph,
        hp = floor(t.hp * scale),
        maxHp = floor(t.hp * scale),
        str = min(90, floor(t.str + floor_n * 2)),
        def = min(80, floor(t.def + floor_n)),
        dmgMin = t.dmgMin + floor(floor_n / 3),
        dmgMax = t.dmgMax + floor(floor_n / 3),
        xp = floor(t.xp * scale),
        color = t.color,
        alive = true,
    }
end

local function populateFloor(rooms)
    enemies = {}
    items = {}

    -- Player in first room
    player.x = rooms[1].cx
    player.y = rooms[1].cy

    -- Stairs in last room
    stairs.x = rooms[#rooms].cx
    stairs.y = rooms[#rooms].cy

    -- Enemies in other rooms
    local numEnemies = 4 + game.floor_num * 2 + rand(0, 2)
    for i = 1, numEnemies do
        local room = rooms[rand(2, #rooms)]
        local ex = rand(room.x, room.x + room.w - 1)
        local ey = rand(room.y, room.y + room.h - 1)
        if not (ex == player.x and ey == player.y) and tileAt(ex, ey) == 0 then
            local e = enemyTemplate(game.floor_num)
            e.x = ex
            e.y = ey
            enemies[#enemies+1] = e
        end
    end

    -- Items
    for i = 2, #rooms do
        local room = rooms[i]
        if rand() < 0.4 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "gold",
                amount = rand(3, 8) + game.floor_num * 2,
            }
        end
        if rand() < 0.25 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "potion",
            }
        end
    end
end

-- FOV - simple raycasting
local function computeFOV()
    local radius = 6
    for a = 0, 359, 2 do
        local rad = a * math.pi / 180
        local dx = cos(rad)
        local dy = sin(rad)
        local fx, fy = player.x + 0.5, player.y + 0.5
        for d = 0, radius do
            local tx, ty = floor(fx), floor(fy)
            if tx < 1 or tx > MW or ty < 1 or ty > MH then break end
            local key = ty * 1000 + tx
            player.seen[key] = 2 -- 2 = visible now
            if tileAt(tx, ty) == 1 then break end
            fx = fx + dx * 0.5
            fy = fy + dy * 0.5
        end
    end
end

local function dimFOV()
    for k, v in pairs(player.seen) do
        if v == 2 then player.seen[k] = 1 end -- 1 = remembered
    end
end

local function isVisible(x, y)
    return (player.seen[y * 1000 + x] or 0) == 2
end

local function isSeen(x, y)
    return (player.seen[y * 1000 + x] or 0) >= 1
end

-- Enemy at position
local function enemyAt(x, y)
    for _, e in ipairs(enemies) do
        if e.alive and e.x == x and e.y == y then return e end
    end
    return nil
end

-- Combat
local function resolveMelee(attacker, defender, atkName, defName, atkStr, defDef, dmgMin, dmgMax, onDone)
    -- Attack roll
    local roll = d100()
    local hit = roll <= atkStr
    local crit = roll <= player.critBonus

    if attacker == player then crit = roll <= player.critBonus end

    if not hit then
        addMessage(atkName .. " attacks " .. defName .. ": d100=" .. roll .. " vs " .. atkStr .. " MISS!", C.miss[1], C.miss[2], C.miss[3])
        spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 3, 120, 120, 120, 30, 0.3)
    else
        -- Defense roll
        local dRoll = d100()
        local dodged = dRoll <= defDef

        if dodged then
            addMessage(defName .. " dodges! d100=" .. dRoll .. " vs " .. defDef .. " DEF", C.miss[1], C.miss[2], C.miss[3])
            spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 4, 150, 150, 255, 40, 0.3)
        else
            local dmg = rand(dmgMin, dmgMax)
            if crit then
                dmg = dmg * 2
                addMessage(atkName .. " CRITS " .. defName .. "! d100=" .. roll .. " DMG:" .. dmg, C.crit[1], C.crit[2], C.crit[3])
                screenShake(5, 0.2)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 15, 255, 255, 80, 80, 0.5)
            else
                addMessage(atkName .. " hits " .. defName .. " d100=" .. roll .. " DMG:" .. dmg, C.hit[1], C.hit[2], C.hit[3])
                screenShake(3, 0.1)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 8, 255, 80, 60, 60, 0.4)
            end

            -- Apply armor
            if defender == player and player.armor > 0 then
                local reduced = max(1, dmg - player.armor)
                if reduced < dmg then
                    addMessage("  Armor absorbs " .. (dmg - reduced) .. " damage", 160, 160, 180)
                end
                dmg = reduced
            end

            defender.hp = defender.hp - dmg
        end
    end

    if onDone then onDone() end
end

local function checkEnemyDeath(e)
    if e.hp <= 0 then
        e.alive = false
        addMessage(e.name .. " defeated! (+" .. e.xp .. " XP)", C.xp[1], C.xp[2], C.xp[3])
        spawnParticles(e.x * TS + TS/2, e.y * TS + TS/2, 20, e.color[1], e.color[2], e.color[3], 100, 0.6)
        screenShake(4, 0.15)
        player.xp = player.xp + e.xp
        player.kills = player.kills + 1

        -- Drop gold
        if rand() < 0.5 then
            items[#items+1] = {x = e.x, y = e.y, type = "gold", amount = rand(1, 5) + game.floor_num}
        end

        -- Level up check
        if player.xp >= player.xpNext then
            game.state = "levelup"
            player.level = player.level + 1
            player.xpNext = floor(player.xpNext * 1.6)
            addMessage("*** LEVEL UP! Level " .. player.level .. " ***", 255, 255, 100)
            spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 25, 255, 255, 100, 120, 0.8)
            screenShake(3, 0.2)
        end
    end
end

local function checkPlayerDeath()
    if player.hp <= 0 then
        player.hp = 0
        game.state = "dead"
        addMessage("You have perished on floor " .. game.floor_num .. "!", 255, 50, 50)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 40, 200, 50, 50, 150, 1.0)
        screenShake(8, 0.4)
    end
end

-- Enemy AI (simple: move toward player if visible)
local function moveEnemies()
    for _, e in ipairs(enemies) do
        if not e.alive then goto continue end

        local dx = player.x - e.x
        local dy = player.y - e.y
        local adist = abs(dx) + abs(dy)

        -- Only act if somewhat close
        if adist > 10 then goto continue end

        -- If adjacent, attack
        if adist == 1 then
            resolveMelee(e, player, e.name, "You", e.str, player.def, e.dmgMin, e.dmgMax)
            checkPlayerDeath()
            goto continue
        end

        -- Move toward player
        local mx, my = 0, 0
        if abs(dx) >= abs(dy) then
            mx = dx > 0 and 1 or -1
        else
            my = dy > 0 and 1 or -1
        end

        local nx, ny = e.x + mx, e.y + my
        if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
            e.x = nx
            e.y = ny
        else
            -- Try other axis
            if mx ~= 0 then
                my = dy > 0 and 1 or (dy < 0 and -1 or 0)
                mx = 0
            else
                mx = dx > 0 and 1 or (dx < 0 and -1 or 0)
                my = 0
            end
            nx, ny = e.x + mx, e.y + my
            if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
                e.x = nx
                e.y = ny
            end
        end

        ::continue::
    end
end

-- Generate a new floor
local function newFloor()
    player.seen = {}
    local rooms = generateMap()
    populateFloor(rooms)
    dimFOV()
    computeFOV()
    addMessage("-- Floor " .. game.floor_num .. " --", 255, 220, 100)
end

-- Level up choices
local levelChoices = {
    {name = "+5 Max HP & heal",   apply = function() player.maxHp = player.maxHp + 5; player.hp = player.maxHp end},
    {name = "+8 STR (hit chance)", apply = function() player.str = min(95, player.str + 8) end},
    {name = "+8 DEF (dodge)",      apply = function() player.def = min(85, player.def + 8) end},
    {name = "+2 Max Damage",       apply = function() player.dmgMax = player.dmgMax + 2 end},
    {name = "+1 Armor",            apply = function() player.armor = player.armor + 1 end},
    {name = "+3 Crit Range",       apply = function() player.critBonus = min(25, player.critBonus + 3) end},
}

local function resetGame()
    game.state = "playing"
    game.floor_num = 1
    game.turn = 0
    game.messages = {}
    game.particles = {}

    player.hp = 30
    player.maxHp = 30
    player.str = 55
    player.def = 40
    player.dmgMin = 2
    player.dmgMax = 6
    player.armor = 0
    player.xp = 0
    player.xpNext = 20
    player.level = 1
    player.gold = 0
    player.potions = 1
    player.kills = 0
    player.critBonus = 5
    player.seen = {}

    addMessage("Arrow keys: move/attack. P: potion. Descend the dungeon!", 180, 180, 220)
    newFloor()
end

-- Player action
local function tryMove(dx, dy)
    if game.state ~= "playing" then return end

    local nx, ny = player.x + dx, player.y + dy

    -- Attack enemy?
    local e = enemyAt(nx, ny)
    if e then
        resolveMelee(player, e, "You", e.name, player.str, e.def, player.dmgMin, player.dmgMax)
        checkEnemyDeath(e)
        if game.state ~= "dead" then
            game.turn = game.turn + 1
            moveEnemies()
        end
        dimFOV()
        computeFOV()
        return
    end

    -- Move
    if tileAt(nx, ny) == 0 then
        player.x = nx
        player.y = ny

        -- Pick up items
        for i = #items, 1, -1 do
            local it = items[i]
            if it.x == nx and it.y == ny then
                if it.type == "gold" then
                    player.gold = player.gold + it.amount
                    addMessage("Picked up " .. it.amount .. " gold!", C.gold[1], C.gold[2], C.gold[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 255, 220, 50, 40, 0.3)
                elseif it.type == "potion" then
                    player.potions = player.potions + 1
                    addMessage("Found a health potion!", C.potion[1], C.potion[2], C.potion[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 100, 200, 255, 40, 0.3)
                end
                table.remove(items, i)
            end
        end

        -- Stairs?
        if nx == stairs.x and ny == stairs.y then
            game.floor_num = game.floor_num + 1
            addMessage("Descending to floor " .. game.floor_num .. "...", 255, 200, 100)
            newFloor()
            return
        end

        game.turn = game.turn + 1
        moveEnemies()
        dimFOV()
        computeFOV()
    end
end

local function usePotion()
    if player.potions > 0 and player.hp < player.maxHp then
        player.potions = player.potions - 1
        local heal = floor(player.maxHp * 0.4) + rand(1, 5)
        player.hp = min(player.maxHp, player.hp + heal)
        addMessage("Drank potion! Healed " .. heal .. " HP", 100, 255, 150)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 10, 100, 255, 150, 50, 0.4)
        game.turn = game.turn + 1
        moveEnemies()
        dimFOV()
        computeFOV()
    end
end

-- Input handling with edge detection
local function keyPressed(key)
    if not bridge.getKeyState then return false end
    local down = bridge.getKeyState(key) == 1
    local was = game.keyWasDown[key] or false
    game.keyWasDown[key] = down
    return down and not was
end

-- Drawing
local function drawTile(sx, sy, tx, ty)
    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local px = camOX + tx * TS + sx
    local py = camOY + ty * TS + sy

    -- Off screen cull
    if px < -TS or px > W + TS or py < -TS or py > H * 0.65 + TS then return end

    local vis = isVisible(tx, ty)
    local seen = isSeen(tx, ty)
    local tile = tileAt(tx, ty)

    if not seen then
        bridge.drawRect(px, py, TS, TS, C.void[1], C.void[2], C.void[3], 255)
        return
    end

    local dim = vis and 1.0 or 0.35

    if tile == 1 then
        local cr, cg, cb = C.wall[1], C.wall[2], C.wall[3]
        -- Slight variation
        if (tx + ty) % 3 == 0 then cr, cg, cb = C.wallHi[1], C.wallHi[2], C.wallHi[3] end
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        -- Wall top highlight
        if vis and ty > 1 and tileAt(tx, ty-1) == 0 then
            bridge.drawRect(px, py, TS, 2, floor(80*dim), floor(70*dim), floor(100*dim), 255)
        end
    else
        local cr, cg, cb = C.floor[1], C.floor[2], C.floor[3]
        if vis then cr, cg, cb = C.floorLit[1], C.floorLit[2], C.floorLit[3] end
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        -- Floor detail
        if (tx * 7 + ty * 13) % 11 == 0 then
            bridge.drawRect(px + 4, py + 4, 2, 2, floor(cr*dim*0.7), floor(cg*dim*0.7), floor(cb*dim*0.7), 255)
        end
    end
end

function DrawGame()
    local sx, sy = 0, 0
    if game.shakeTimer > 0 then
        sx = floor((rand() - 0.5) * game.shakeIntensity * 2)
        sy = floor((rand() - 0.5) * game.shakeIntensity * 2)
    end

    -- Clear
    bridge.drawRect(0, 0, W, H, C.void[1], C.void[2], C.void[3], 255)

    if game.state == "title" then
        bridge.drawRect(0, 0, W, H, 8, 6, 16, 255)
        bridge.drawText("DUNGEON OF THE D100", W/2 - 80, H/3 - 20, 255, 220, 100, 255)
        bridge.drawText("A Roll-Under Roguelike", W/2 - 75, H/3 + 5, 180, 160, 200, 255)
        bridge.drawText("Arrow Keys: Move & Attack", W/2 - 85, H/2, 160, 160, 180, 255)
        bridge.drawText("P: Drink Potion", W/2 - 50, H/2 + 20, 160, 160, 180, 255)
        bridge.drawText("Bump enemies to fight", W/2 - 70, H/2 + 40, 160, 160, 180, 255)
        bridge.drawText("Roll d100 <= your stat to succeed", W/2 - 105, H/2 + 60, 140, 140, 160, 255)
        bridge.drawText("PRESS SPACE TO BEGIN", W/2 - 70, H * 0.75, 255, 255, 150, 255)
        return
    end

    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local mapAreaH = floor(H * 0.65)

    -- Draw map tiles
    local startTX = max(1, floor(-camOX / TS) - 1)
    local endTX = min(MW, floor((-camOX + W) / TS) + 2)
    local startTY = max(1, floor(-camOY / TS) - 1)
    local endTY = min(MH, floor((-camOY + mapAreaH) / TS) + 2)

    for ty = startTY, endTY do
        for tx = startTX, endTX do
            drawTile(sx, sy, tx, ty)
        end
    end

    -- Draw stairs (if visible)
    if isVisible(stairs.x, stairs.y) then
        local stX = camOX + stairs.x * TS + sx
        local stY = camOY + stairs.y * TS + sy
        bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, C.stairs[1], C.stairs[2], C.stairs[3], 255)
        bridge.drawRect(stX + 7, stY + 7, TS - 14, TS - 14, 180, 120, 30, 255)
        bridge.drawText(">", stX + 8, stY + 5, 255, 240, 180, 255)
    elseif isSeen(stairs.x, stairs.y) then
        local stX = camOX + stairs.x * TS + sx
        local stY = camOY + stairs.y * TS + sy
        bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, 80, 60, 30, 255)
    end

    -- Draw items
    for _, it in ipairs(items) do
        if isVisible(it.x, it.y) then
            local ix = camOX + it.x * TS + sx
            local iy = camOY + it.y * TS + sy
            if it.type == "gold" then
                bridge.drawRect(ix + 8, iy + 8, 8, 8, C.gold[1], C.gold[2], C.gold[3], 255)
                bridge.drawRect(ix + 9, iy + 9, 4, 4, 255, 250, 150, 255)
            elseif it.type == "potion" then
                bridge.drawRect(ix + 7, iy + 5, 10, 14, C.potion[1], C.potion[2], C.potion[3], 255)
                bridge.drawRect(ix + 9, iy + 3, 6, 4, 80, 160, 220, 255)
            end
        end
    end

    -- Draw enemies
    for _, e in ipairs(enemies) do
        if e.alive and isVisible(e.x, e.y) then
            local ex = camOX + e.x * TS + sx
            local ey = camOY + e.y * TS + sy
            -- Body
            bridge.drawRect(ex + 3, ey + 3, TS - 6, TS - 6, e.color[1], e.color[2], e.color[3], 255)
            bridge.drawRect(ex + 5, ey + 5, TS - 10, TS - 10,
                min(255, e.color[1]+30), min(255, e.color[2]+30), min(255, e.color[3]+30), 255)
            -- HP bar if damaged
            if e.hp < e.maxHp then
                local barW = TS - 4
                local hpFrac = e.hp / e.maxHp
                bridge.drawRect(ex + 2, ey - 3, barW, 3, 60, 20, 20, 200)
                bridge.drawRect(ex + 2, ey - 3, floor(barW * hpFrac), 3, 255, 50, 50, 255)
            end
        end
    end

    -- Draw player
    if game.state ~= "dead" then
        local px_draw = camOX + player.x * TS + sx
        local py_draw = camOY + player.y * TS + sy
        bridge.drawRect(px_draw + 2, py_draw + 2, TS - 4, TS - 4, C.player[1], C.player[2], C.player[3], 255)
        bridge.drawRect(px_draw + 5, py_draw + 5, TS - 10, TS - 10, 120, 255, 160, 255)
        -- Eyes
        bridge.drawRect(px_draw + 7, py_draw + 7, 3, 3, 20, 40, 20, 255)
        bridge.drawRect(px_draw + 14, py_draw + 7, 3, 3, 20, 40, 20, 255)
    end

    -- Particles (in map space)
    for _, p in ipairs(game.particles) do
        local alpha = floor(255 * (p.life / p.maxLife))
        if alpha > 0 then
            local ppx = camOX + p.x + sx
            local ppy = camOY + p.y + sy
            if ppx > -10 and ppx < W + 10 and ppy > -10 and ppy < mapAreaH + 10 then
                bridge.drawRect(ppx - p.size/2, ppy - p.size/2, p.size, p.size, p.r, p.g, p.b, alpha)
            end
        end
    end

    -- HUD panel at bottom
    local hudY = mapAreaH + 2
    local hudH = H - hudY
    bridge.drawRect(0, hudY, W, hudH, C.hud_bg[1], C.hud_bg[2], C.hud_bg[3], 255)
    bridge.drawRect(0, hudY, W, 2, C.hud_border[1], C.hud_border[2], C.hud_border[3], 255)

    -- Stats (left column)
    local col1 = 10
    local ly = hudY + 6
    bridge.drawText("LVL:" .. player.level, col1, ly, 255, 255, 150, 255)
    bridge.drawText("FL:" .. game.floor_num, col1 + 55, ly, 255, 200, 100, 255)

    ly = ly + 14
    -- HP bar
    bridge.drawText("HP:", col1, ly, 200, 200, 200, 255)
    local barX = col1 + 28
    local barW = 90
    local barH = 10
    bridge.drawRect(barX, ly, barW, barH, 40, 15, 15, 255)
    local hpW = floor(barW * (player.hp / player.maxHp))
    local hpR = player.hp <= player.maxHp * 0.3 and 255 or 50
    local hpG = player.hp <= player.maxHp * 0.3 and 50 or 220
    bridge.drawRect(barX, ly, hpW, barH, hpR, hpG, 50, 255)
    bridge.drawText(player.hp .. "/" .. player.maxHp, barX + barW + 5, ly, 200, 200, 200, 255)

    ly = ly + 14
    bridge.drawText("STR:" .. player.str .. " DEF:" .. player.def .. " DMG:" .. player.dmgMin .. "-" .. player.dmgMax, col1, ly, 180, 180, 200, 255)

    ly = ly + 14
    bridge.drawText("ARM:" .. player.armor .. " CRIT:<=" .. player.critBonus, col1, ly, 180, 180, 200, 255)
    bridge.drawText("XP:" .. player.xp .. "/" .. player.xpNext, col1 + 160, ly, C.xp[1], C.xp[2], C.xp[3], 255)

    ly = ly + 14
    bridge.drawText("Gold:" .. player.gold .. "  Potions:" .. player.potions, col1, ly, C.gold[1], C.gold[2], C.gold[3], 255)
    bridge.drawText("Kills:" .. player.kills, col1 + 200, ly, 200, 160, 160, 255)

    -- Message log (right side)
    local msgX = W/2 + 20
    local msgY = hudY + 8
    bridge.drawText("-- Combat Log --", msgX, msgY, 120, 110, 140, 255)
    for i, msg in ipairs(game.messages) do
        local alpha = max(80, 255 - i * 25)
        bridge.drawText(msg.text, msgX, msgY + i * 13, msg.r, msg.g, msg.b, alpha)
        if msgY + i * 13 > H - 5 then break end
    end

    -- Level up overlay
    if game.state == "levelup" then
        bridge.drawRect(W/4, H/4, W/2, H/2, 15, 12, 30, 240)
        bridge.drawRect(W/4, H/4, W/2, 2, 255, 220, 100, 255)
        bridge.drawText("LEVEL UP! Choose a bonus:", W/4 + 20, H/4 + 12, 255, 255, 150, 255)
        for i, choice in ipairs(levelChoices) do
            local y = H/4 + 30 + (i-1) * 22
            local hover = false -- could add mouse later
            bridge.drawRect(W/4 + 15, y, W/2 - 30, 18, 30, 25, 50, 200)
            bridge.drawText(i .. ") " .. choice.name, W/4 + 22, y + 2, 220, 220, 240, 255)
        end
    end

    -- Death overlay
    if game.state == "dead" then
        bridge.drawRect(W/4, H/3, W/2, H/4, 20, 5, 5, 230)
        bridge.drawRect(W/4, H/3, W/2, 2, 255, 50, 50, 255)
        bridge.drawText("YOU HAVE PERISHED", W/4 + 40, H/3 + 15, 255, 60, 60, 255)
        bridge.drawText("Floor: " .. game.floor_num .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4 + 15, H/3 + 35, 200, 200, 200, 255)
        bridge.drawText("Gold: " .. player.gold .. "  Score: " .. (player.kills * 10 + player.gold + game.floor_num * 50), W/4 + 15, H/3 + 52, 255, 220, 100, 255)
        bridge.drawText("PRESS SPACE TO TRY AGAIN", W/4 + 25, H/3 + 75, 180, 180, 180, 255)
    end
end

-- Main update
function UpdateUI(mx, my, down, w, h)
    W, H = w, h
    root.width = w
    root.height = h
    local dt = 0.016

    -- Shake decay
    if game.shakeTimer > 0 then
        game.shakeTimer = game.shakeTimer - dt
    end

    -- Particles
    for i = #game.particles, 1, -1 do
        local p = game.particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.life = p.life - dt
        p.vx = p.vx * 0.95
        p.vy = p.vy * 0.95
        if p.life <= 0 then table.remove(game.particles, i) end
    end

    -- Age messages
    for _, msg in ipairs(game.messages) do
        msg.age = msg.age + dt
    end

    -- Input
    if game.state == "title" then
        if keyPressed("space") then
            resetGame()
        end
        return
    end

    if game.state == "dead" then
        if keyPressed("space") then
            resetGame()
        end
        return
    end

    if game.state == "levelup" then
        for i = 1, #levelChoices do
            if keyPressed(tostring(i)) then
                levelChoices[i].apply()
                addMessage("Chose: " .. levelChoices[i].name, 255, 255, 150)
                game.state = "playing"
                break
            end
        end
        return
    end

    -- Movement (turn-based with input cooldown for held keys)
    game.inputCooldown = max(0, game.inputCooldown - dt)

    if game.state == "playing" then
        if keyPressed("up") or keyPressed("w") then tryMove(0, -1)
        elseif keyPressed("down") or keyPressed("s") then tryMove(0, 1)
        elseif keyPressed("left") or keyPressed("a") then tryMove(-1, 0)
        elseif keyPressed("right") or keyPressed("d") then tryMove(1, 0)
        elseif keyPressed("p") then usePotion()
        end
    end
end

function DrawUI()
    DrawGame()
end-- dungeon_crawl.lua
-- D100 Roll-Under Roguelike Dungeon Crawler
-- Arrow keys move, bump-to-attack, collect loot, descend floors
-- All checks are d100 roll-under: roll <= stat = success

local root = UIElement:new({width=800, height=600})

local W, H = 800, 600
local sin, cos, rand, floor = math.sin, math.cos, math.random, math.floor
local abs, sqrt, max, min = math.abs, math.sqrt, math.max, math.min

-- Tile size and map dimensions
local TS = 24
local MW, MH = 30, 22

-- Colors
local C = {
    void     = {8, 6, 16},
    wall     = {45, 38, 55},
    wallHi   = {65, 55, 78},
    floor    = {22, 20, 30},
    floorLit = {32, 28, 42},
    player   = {80, 255, 120},
    enemy    = {255, 70, 70},
    gold     = {255, 220, 50},
    potion   = {100, 200, 255},
    stairs   = {255, 180, 50},
    fog      = {12, 10, 20},
    blood    = {120, 20, 20},
    xp       = {180, 130, 255},
    crit     = {255, 255, 80},
    miss     = {120, 120, 120},
    hit      = {255, 100, 80},
    hud_bg   = {15, 12, 25},
    hud_border = {60, 50, 80},
}

-- Game state
local game = {
    state = "title", -- title, playing, dead, levelup, rolling
    floor_num = 1,
    turn = 0,
    messages = {},
    maxMessages = 6,
    shakeTimer = 0,
    shakeIntensity = 0,
    rollAnim = nil,     -- active roll animation
    particles = {},
    camX = 0, camY = 0,
    inputCooldown = 0,
    keyWasDown = {},
}

-- Player
local player = {
    x = 0, y = 0,
    hp = 30, maxHp = 30,
    str = 55,    -- melee hit chance
    def = 40,    -- dodge chance
    dmgMin = 2, dmgMax = 6,
    armor = 0,
    xp = 0,
    xpNext = 20,
    level = 1,
    gold = 0,
    potions = 1,
    kills = 0,
    critBonus = 5,  -- roll under this = crit
    seen = {},      -- fog of war
}

-- Map
local map = {}
local enemies = {}
local items = {}
local stairs = {x = 0, y = 0}

-- Particles
local function spawnParticles(x, y, count, r, g, b, speed, life)
    for i = 1, count do
        local a = rand() * math.pi * 2
        local s = rand() * speed + speed * 0.2
        game.particles[#game.particles+1] = {
            x = x, y = y,
            vx = cos(a) * s, vy = sin(a) * s,
            life = life * (0.4 + rand() * 0.6),
            maxLife = life,
            r = r, g = g, b = b,
            size = rand() < 0.3 and 3 or 2,
        }
    end
end

local function screenShake(intensity, duration)
    game.shakeTimer = duration
    game.shakeIntensity = intensity
end

local function addMessage(text, r, g, b)
    table.insert(game.messages, 1, {text = text, r = r or 200, g = g or 200, b = b or 200, age = 0})
    if #game.messages > game.maxMessages then
        table.remove(game.messages)
    end
end

-- Roll a d100 (1-100)
local function d100()
    return rand(1, 100)
end

-- Roll with animation
local function rollD100(callback, label)
    game.rollAnim = {
        timer = 0,
        duration = 0.45,
        currentFace = rand(1, 100),
        finalRoll = d100(),
        callback = callback,
        label = label or "d100",
        flickerRate = 0.03,
        flickerTimer = 0,
        done = false,
    }
end

-- Map generation - BSP-ish rooms + corridors
local function tileAt(x, y)
    if x < 1 or x > MW or y < 1 or y > MH then return 1 end
    return map[y][x]
end

local function setTile(x, y, v)
    if x >= 1 and x <= MW and y >= 1 and y <= MH then
        map[y][x] = v
    end
end

local function carveRoom(rx, ry, rw, rh)
    for y = ry, ry + rh - 1 do
        for x = rx, rx + rw - 1 do
            setTile(x, y, 0)
        end
    end
    return {x = rx, y = ry, w = rw, h = rh,
            cx = floor(rx + rw/2), cy = floor(ry + rh/2)}
end

local function carveCorridor(x1, y1, x2, y2)
    local x, y = x1, y1
    while x ~= x2 do
        setTile(x, y, 0)
        x = x + (x2 > x and 1 or -1)
    end
    while y ~= y2 do
        setTile(x, y, 0)
        y = y + (y2 > y and 1 or -1)
    end
end

local function generateMap()
    -- Init walls
    map = {}
    for y = 1, MH do
        map[y] = {}
        for x = 1, MW do
            map[y][x] = 1
        end
    end

    local rooms = {}
    local attempts = 0
    local numRooms = rand(6, 9) + floor(game.floor_num / 2)

    while #rooms < numRooms and attempts < 200 do
        attempts = attempts + 1
        local rw = rand(3, 7)
        local rh = rand(3, 5)
        local rx = rand(2, MW - rw - 1)
        local ry = rand(2, MH - rh - 1)

        -- Check overlap
        local ok = true
        for _, r in ipairs(rooms) do
            if rx < r.x + r.w + 1 and rx + rw + 1 > r.x and
               ry < r.y + r.h + 1 and ry + rh + 1 > r.y then
                ok = false
                break
            end
        end

        if ok then
            local room = carveRoom(rx, ry, rw, rh)
            if #rooms > 0 then
                local prev = rooms[#rooms]
                if rand() < 0.5 then
                    carveCorridor(prev.cx, prev.cy, room.cx, prev.cy)
                    carveCorridor(room.cx, prev.cy, room.cx, room.cy)
                else
                    carveCorridor(prev.cx, prev.cy, prev.cx, room.cy)
                    carveCorridor(prev.cx, room.cy, room.cx, room.cy)
                end
            end
            rooms[#rooms+1] = room
        end
    end

    -- Extra corridors for loops
    for i = 1, floor(#rooms / 3) do
        local a = rooms[rand(1, #rooms)]
        local b = rooms[rand(1, #rooms)]
        if a ~= b then
            carveCorridor(a.cx, a.cy, b.cx, b.cy)
        end
    end

    return rooms
end

-- Enemy templates scaled by floor
local function enemyTemplate(floor_n)
    local templates = {
        {name="Rat",       glyph="r", hp=6,  str=30, def=15, dmgMin=1, dmgMax=3, xp=5,  color={180,140,100}},
        {name="Skeleton",  glyph="s", hp=10, str=40, def=25, dmgMin=2, dmgMax=5, xp=10, color={220,220,200}},
        {name="Goblin",    glyph="g", hp=8,  str=45, def=30, dmgMin=2, dmgMax=4, xp=8,  color={80,180,60}},
        {name="Orc",       glyph="o", hp=18, str=55, def=20, dmgMin=3, dmgMax=7, xp=18, color={100,160,60}},
        {name="Wraith",    glyph="w", hp=14, str=60, def=50, dmgMin=3, dmgMax=6, xp=22, color={150,120,220}},
        {name="Troll",     glyph="T", hp=30, str=50, def=15, dmgMin=5, dmgMax=10,xp=35, color={80,120,60}},
        {name="Demon",     glyph="D", hp=25, str=70, def=40, dmgMin=4, dmgMax=9, xp=40, color={255,50,80}},
    }

    -- Pick from templates available at this floor depth
    local maxIdx = min(#templates, 2 + floor(floor_n / 2))
    local minIdx = max(1, maxIdx - 3)
    local t = templates[rand(minIdx, maxIdx)]

    -- Scale slightly with floor
    local scale = 1.0 + (floor_n - 1) * 0.12
    return {
        name = t.name,
        glyph = t.glyph,
        hp = floor(t.hp * scale),
        maxHp = floor(t.hp * scale),
        str = min(90, floor(t.str + floor_n * 2)),
        def = min(80, floor(t.def + floor_n)),
        dmgMin = t.dmgMin + floor(floor_n / 3),
        dmgMax = t.dmgMax + floor(floor_n / 3),
        xp = floor(t.xp * scale),
        color = t.color,
        alive = true,
    }
end

local function populateFloor(rooms)
    enemies = {}
    items = {}

    -- Player in first room
    player.x = rooms[1].cx
    player.y = rooms[1].cy

    -- Stairs in last room
    stairs.x = rooms[#rooms].cx
    stairs.y = rooms[#rooms].cy

    -- Enemies in other rooms
    local numEnemies = 4 + game.floor_num * 2 + rand(0, 2)
    for i = 1, numEnemies do
        local room = rooms[rand(2, #rooms)]
        local ex = rand(room.x, room.x + room.w - 1)
        local ey = rand(room.y, room.y + room.h - 1)
        if not (ex == player.x and ey == player.y) and tileAt(ex, ey) == 0 then
            local e = enemyTemplate(game.floor_num)
            e.x = ex
            e.y = ey
            enemies[#enemies+1] = e
        end
    end

    -- Items
    for i = 2, #rooms do
        local room = rooms[i]
        if rand() < 0.4 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "gold",
                amount = rand(3, 8) + game.floor_num * 2,
            }
        end
        if rand() < 0.25 then
            items[#items+1] = {
                x = rand(room.x, room.x + room.w - 1),
                y = rand(room.y, room.y + room.h - 1),
                type = "potion",
            }
        end
    end
end

-- FOV - simple raycasting
local function computeFOV()
    local radius = 6
    for a = 0, 359, 2 do
        local rad = a * math.pi / 180
        local dx = cos(rad)
        local dy = sin(rad)
        local fx, fy = player.x + 0.5, player.y + 0.5
        for d = 0, radius do
            local tx, ty = floor(fx), floor(fy)
            if tx < 1 or tx > MW or ty < 1 or ty > MH then break end
            local key = ty * 1000 + tx
            player.seen[key] = 2 -- 2 = visible now
            if tileAt(tx, ty) == 1 then break end
            fx = fx + dx * 0.5
            fy = fy + dy * 0.5
        end
    end
end

local function dimFOV()
    for k, v in pairs(player.seen) do
        if v == 2 then player.seen[k] = 1 end -- 1 = remembered
    end
end

local function isVisible(x, y)
    return (player.seen[y * 1000 + x] or 0) == 2
end

local function isSeen(x, y)
    return (player.seen[y * 1000 + x] or 0) >= 1
end

-- Enemy at position
local function enemyAt(x, y)
    for _, e in ipairs(enemies) do
        if e.alive and e.x == x and e.y == y then return e end
    end
    return nil
end

-- Combat
local function resolveMelee(attacker, defender, atkName, defName, atkStr, defDef, dmgMin, dmgMax, onDone)
    -- Attack roll
    local roll = d100()
    local hit = roll <= atkStr
    local crit = roll <= player.critBonus

    if attacker == player then crit = roll <= player.critBonus end

    if not hit then
        addMessage(atkName .. " attacks " .. defName .. ": d100=" .. roll .. " vs " .. atkStr .. " MISS!", C.miss[1], C.miss[2], C.miss[3])
        spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 3, 120, 120, 120, 30, 0.3)
    else
        -- Defense roll
        local dRoll = d100()
        local dodged = dRoll <= defDef

        if dodged then
            addMessage(defName .. " dodges! d100=" .. dRoll .. " vs " .. defDef .. " DEF", C.miss[1], C.miss[2], C.miss[3])
            spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 4, 150, 150, 255, 40, 0.3)
        else
            local dmg = rand(dmgMin, dmgMax)
            if crit then
                dmg = dmg * 2
                addMessage(atkName .. " CRITS " .. defName .. "! d100=" .. roll .. " DMG:" .. dmg, C.crit[1], C.crit[2], C.crit[3])
                screenShake(5, 0.2)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 15, 255, 255, 80, 80, 0.5)
            else
                addMessage(atkName .. " hits " .. defName .. " d100=" .. roll .. " DMG:" .. dmg, C.hit[1], C.hit[2], C.hit[3])
                screenShake(3, 0.1)
                spawnParticles(defender.x * TS + TS/2, defender.y * TS + TS/2, 8, 255, 80, 60, 60, 0.4)
            end

            -- Apply armor
            if defender == player and player.armor > 0 then
                local reduced = max(1, dmg - player.armor)
                if reduced < dmg then
                    addMessage("  Armor absorbs " .. (dmg - reduced) .. " damage", 160, 160, 180)
                end
                dmg = reduced
            end

            defender.hp = defender.hp - dmg
        end
    end

    if onDone then onDone() end
end

local function checkEnemyDeath(e)
    if e.hp <= 0 then
        e.alive = false
        addMessage(e.name .. " defeated! (+" .. e.xp .. " XP)", C.xp[1], C.xp[2], C.xp[3])
        spawnParticles(e.x * TS + TS/2, e.y * TS + TS/2, 20, e.color[1], e.color[2], e.color[3], 100, 0.6)
        screenShake(4, 0.15)
        player.xp = player.xp + e.xp
        player.kills = player.kills + 1

        -- Drop gold
        if rand() < 0.5 then
            items[#items+1] = {x = e.x, y = e.y, type = "gold", amount = rand(1, 5) + game.floor_num}
        end

        -- Level up check
        if player.xp >= player.xpNext then
            game.state = "levelup"
            player.level = player.level + 1
            player.xpNext = floor(player.xpNext * 1.6)
            addMessage("*** LEVEL UP! Level " .. player.level .. " ***", 255, 255, 100)
            spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 25, 255, 255, 100, 120, 0.8)
            screenShake(3, 0.2)
        end
    end
end

local function checkPlayerDeath()
    if player.hp <= 0 then
        player.hp = 0
        game.state = "dead"
        addMessage("You have perished on floor " .. game.floor_num .. "!", 255, 50, 50)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 40, 200, 50, 50, 150, 1.0)
        screenShake(8, 0.4)
    end
end

-- Enemy AI (simple: move toward player if visible)
local function moveEnemies()
    for _, e in ipairs(enemies) do
        if not e.alive then goto continue end

        local dx = player.x - e.x
        local dy = player.y - e.y
        local adist = abs(dx) + abs(dy)

        -- Only act if somewhat close
        if adist > 10 then goto continue end

        -- If adjacent, attack
        if adist == 1 then
            resolveMelee(e, player, e.name, "You", e.str, player.def, e.dmgMin, e.dmgMax)
            checkPlayerDeath()
            goto continue
        end

        -- Move toward player
        local mx, my = 0, 0
        if abs(dx) >= abs(dy) then
            mx = dx > 0 and 1 or -1
        else
            my = dy > 0 and 1 or -1
        end

        local nx, ny = e.x + mx, e.y + my
        if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
            e.x = nx
            e.y = ny
        else
            -- Try other axis
            if mx ~= 0 then
                my = dy > 0 and 1 or (dy < 0 and -1 or 0)
                mx = 0
            else
                mx = dx > 0 and 1 or (dx < 0 and -1 or 0)
                my = 0
            end
            nx, ny = e.x + mx, e.y + my
            if tileAt(nx, ny) == 0 and not enemyAt(nx, ny) and not (nx == player.x and ny == player.y) then
                e.x = nx
                e.y = ny
            end
        end

        ::continue::
    end
end

-- Generate a new floor
local function newFloor()
    player.seen = {}
    local rooms = generateMap()
    populateFloor(rooms)
    dimFOV()
    computeFOV()
    addMessage("-- Floor " .. game.floor_num .. " --", 255, 220, 100)
end

-- Level up choices
local levelChoices = {
    {name = "+5 Max HP & heal",   apply = function() player.maxHp = player.maxHp + 5; player.hp = player.maxHp end},
    {name = "+8 STR (hit chance)", apply = function() player.str = min(95, player.str + 8) end},
    {name = "+8 DEF (dodge)",      apply = function() player.def = min(85, player.def + 8) end},
    {name = "+2 Max Damage",       apply = function() player.dmgMax = player.dmgMax + 2 end},
    {name = "+1 Armor",            apply = function() player.armor = player.armor + 1 end},
    {name = "+3 Crit Range",       apply = function() player.critBonus = min(25, player.critBonus + 3) end},
}

local function resetGame()
    game.state = "playing"
    game.floor_num = 1
    game.turn = 0
    game.messages = {}
    game.particles = {}

    player.hp = 30
    player.maxHp = 30
    player.str = 55
    player.def = 40
    player.dmgMin = 2
    player.dmgMax = 6
    player.armor = 0
    player.xp = 0
    player.xpNext = 20
    player.level = 1
    player.gold = 0
    player.potions = 1
    player.kills = 0
    player.critBonus = 5
    player.seen = {}

    addMessage("Arrow keys: move/attack. P: potion. Descend the dungeon!", 180, 180, 220)
    newFloor()
end

-- Player action
local function tryMove(dx, dy)
    if game.state ~= "playing" then return end

    local nx, ny = player.x + dx, player.y + dy

    -- Attack enemy?
    local e = enemyAt(nx, ny)
    if e then
        resolveMelee(player, e, "You", e.name, player.str, e.def, player.dmgMin, player.dmgMax)
        checkEnemyDeath(e)
        if game.state ~= "dead" then
            game.turn = game.turn + 1
            moveEnemies()
        end
        dimFOV()
        computeFOV()
        return
    end

    -- Move
    if tileAt(nx, ny) == 0 then
        player.x = nx
        player.y = ny

        -- Pick up items
        for i = #items, 1, -1 do
            local it = items[i]
            if it.x == nx and it.y == ny then
                if it.type == "gold" then
                    player.gold = player.gold + it.amount
                    addMessage("Picked up " .. it.amount .. " gold!", C.gold[1], C.gold[2], C.gold[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 255, 220, 50, 40, 0.3)
                elseif it.type == "potion" then
                    player.potions = player.potions + 1
                    addMessage("Found a health potion!", C.potion[1], C.potion[2], C.potion[3])
                    spawnParticles(nx * TS + TS/2, ny * TS + TS/2, 6, 100, 200, 255, 40, 0.3)
                end
                table.remove(items, i)
            end
        end

        -- Stairs?
        if nx == stairs.x and ny == stairs.y then
            game.floor_num = game.floor_num + 1
            addMessage("Descending to floor " .. game.floor_num .. "...", 255, 200, 100)
            newFloor()
            return
        end

        game.turn = game.turn + 1
        moveEnemies()
        dimFOV()
        computeFOV()
    end
end

local function usePotion()
    if player.potions > 0 and player.hp < player.maxHp then
        player.potions = player.potions - 1
        local heal = floor(player.maxHp * 0.4) + rand(1, 5)
        player.hp = min(player.maxHp, player.hp + heal)
        addMessage("Drank potion! Healed " .. heal .. " HP", 100, 255, 150)
        spawnParticles(player.x * TS + TS/2, player.y * TS + TS/2, 10, 100, 255, 150, 50, 0.4)
        game.turn = game.turn + 1
        moveEnemies()
        dimFOV()
        computeFOV()
    end
end

-- Input handling with edge detection
local function keyPressed(key)
    if not bridge.getKeyState then return false end
    local down = bridge.getKeyState(key) == 1
    local was = game.keyWasDown[key] or false
    game.keyWasDown[key] = down
    return down and not was
end

-- Drawing
local function drawTile(sx, sy, tx, ty)
    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local px = camOX + tx * TS + sx
    local py = camOY + ty * TS + sy

    -- Off screen cull
    if px < -TS or px > W + TS or py < -TS or py > H * 0.65 + TS then return end

    local vis = isVisible(tx, ty)
    local seen = isSeen(tx, ty)
    local tile = tileAt(tx, ty)

    if not seen then
        bridge.drawRect(px, py, TS, TS, C.void[1], C.void[2], C.void[3], 255)
        return
    end

    local dim = vis and 1.0 or 0.35

    if tile == 1 then
        local cr, cg, cb = C.wall[1], C.wall[2], C.wall[3]
        -- Slight variation
        if (tx + ty) % 3 == 0 then cr, cg, cb = C.wallHi[1], C.wallHi[2], C.wallHi[3] end
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        -- Wall top highlight
        if vis and ty > 1 and tileAt(tx, ty-1) == 0 then
            bridge.drawRect(px, py, TS, 2, floor(80*dim), floor(70*dim), floor(100*dim), 255)
        end
    else
        local cr, cg, cb = C.floor[1], C.floor[2], C.floor[3]
        if vis then cr, cg, cb = C.floorLit[1], C.floorLit[2], C.floorLit[3] end
        bridge.drawRect(px, py, TS, TS, floor(cr*dim), floor(cg*dim), floor(cb*dim), 255)
        -- Floor detail
        if (tx * 7 + ty * 13) % 11 == 0 then
            bridge.drawRect(px + 4, py + 4, 2, 2, floor(cr*dim*0.7), floor(cg*dim*0.7), floor(cb*dim*0.7), 255)
        end
    end
end

function DrawGame()
    local sx, sy = 0, 0
    if game.shakeTimer > 0 then
        sx = floor((rand() - 0.5) * game.shakeIntensity * 2)
        sy = floor((rand() - 0.5) * game.shakeIntensity * 2)
    end

    -- Clear
    bridge.drawRect(0, 0, W, H, C.void[1], C.void[2], C.void[3], 255)

    if game.state == "title" then
        bridge.drawRect(0, 0, W, H, 8, 6, 16, 255)
        bridge.drawText("DUNGEON OF THE D100", W/2 - 80, H/3 - 20, 255, 220, 100, 255)
        bridge.drawText("A Roll-Under Roguelike", W/2 - 75, H/3 + 5, 180, 160, 200, 255)
        bridge.drawText("Arrow Keys: Move & Attack", W/2 - 85, H/2, 160, 160, 180, 255)
        bridge.drawText("P: Drink Potion", W/2 - 50, H/2 + 20, 160, 160, 180, 255)
        bridge.drawText("Bump enemies to fight", W/2 - 70, H/2 + 40, 160, 160, 180, 255)
        bridge.drawText("Roll d100 <= your stat to succeed", W/2 - 105, H/2 + 60, 140, 140, 160, 255)
        bridge.drawText("PRESS SPACE TO BEGIN", W/2 - 70, H * 0.75, 255, 255, 150, 255)
        return
    end

    local camOX = floor(W/2 - player.x * TS - TS/2)
    local camOY = floor(H * 0.4 - player.y * TS - TS/2)
    local mapAreaH = floor(H * 0.65)

    -- Draw map tiles
    local startTX = max(1, floor(-camOX / TS) - 1)
    local endTX = min(MW, floor((-camOX + W) / TS) + 2)
    local startTY = max(1, floor(-camOY / TS) - 1)
    local endTY = min(MH, floor((-camOY + mapAreaH) / TS) + 2)

    for ty = startTY, endTY do
        for tx = startTX, endTX do
            drawTile(sx, sy, tx, ty)
        end
    end

    -- Draw stairs (if visible)
    if isVisible(stairs.x, stairs.y) then
        local stX = camOX + stairs.x * TS + sx
        local stY = camOY + stairs.y * TS + sy
        bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, C.stairs[1], C.stairs[2], C.stairs[3], 255)
        bridge.drawRect(stX + 7, stY + 7, TS - 14, TS - 14, 180, 120, 30, 255)
        bridge.drawText(">", stX + 8, stY + 5, 255, 240, 180, 255)
    elseif isSeen(stairs.x, stairs.y) then
        local stX = camOX + stairs.x * TS + sx
        local stY = camOY + stairs.y * TS + sy
        bridge.drawRect(stX + 4, stY + 4, TS - 8, TS - 8, 80, 60, 30, 255)
    end

    -- Draw items
    for _, it in ipairs(items) do
        if isVisible(it.x, it.y) then
            local ix = camOX + it.x * TS + sx
            local iy = camOY + it.y * TS + sy
            if it.type == "gold" then
                bridge.drawRect(ix + 8, iy + 8, 8, 8, C.gold[1], C.gold[2], C.gold[3], 255)
                bridge.drawRect(ix + 9, iy + 9, 4, 4, 255, 250, 150, 255)
            elseif it.type == "potion" then
                bridge.drawRect(ix + 7, iy + 5, 10, 14, C.potion[1], C.potion[2], C.potion[3], 255)
                bridge.drawRect(ix + 9, iy + 3, 6, 4, 80, 160, 220, 255)
            end
        end
    end

    -- Draw enemies
    for _, e in ipairs(enemies) do
        if e.alive and isVisible(e.x, e.y) then
            local ex = camOX + e.x * TS + sx
            local ey = camOY + e.y * TS + sy
            -- Body
            bridge.drawRect(ex + 3, ey + 3, TS - 6, TS - 6, e.color[1], e.color[2], e.color[3], 255)
            bridge.drawRect(ex + 5, ey + 5, TS - 10, TS - 10,
                min(255, e.color[1]+30), min(255, e.color[2]+30), min(255, e.color[3]+30), 255)
            -- HP bar if damaged
            if e.hp < e.maxHp then
                local barW = TS - 4
                local hpFrac = e.hp / e.maxHp
                bridge.drawRect(ex + 2, ey - 3, barW, 3, 60, 20, 20, 200)
                bridge.drawRect(ex + 2, ey - 3, floor(barW * hpFrac), 3, 255, 50, 50, 255)
            end
        end
    end

    -- Draw player
    if game.state ~= "dead" then
        local px_draw = camOX + player.x * TS + sx
        local py_draw = camOY + player.y * TS + sy
        bridge.drawRect(px_draw + 2, py_draw + 2, TS - 4, TS - 4, C.player[1], C.player[2], C.player[3], 255)
        bridge.drawRect(px_draw + 5, py_draw + 5, TS - 10, TS - 10, 120, 255, 160, 255)
        -- Eyes
        bridge.drawRect(px_draw + 7, py_draw + 7, 3, 3, 20, 40, 20, 255)
        bridge.drawRect(px_draw + 14, py_draw + 7, 3, 3, 20, 40, 20, 255)
    end

    -- Particles (in map space)
    for _, p in ipairs(game.particles) do
        local alpha = floor(255 * (p.life / p.maxLife))
        if alpha > 0 then
            local ppx = camOX + p.x + sx
            local ppy = camOY + p.y + sy
            if ppx > -10 and ppx < W + 10 and ppy > -10 and ppy < mapAreaH + 10 then
                bridge.drawRect(ppx - p.size/2, ppy - p.size/2, p.size, p.size, p.r, p.g, p.b, alpha)
            end
        end
    end

    -- HUD panel at bottom
    local hudY = mapAreaH + 2
    local hudH = H - hudY
    bridge.drawRect(0, hudY, W, hudH, C.hud_bg[1], C.hud_bg[2], C.hud_bg[3], 255)
    bridge.drawRect(0, hudY, W, 2, C.hud_border[1], C.hud_border[2], C.hud_border[3], 255)

    -- Stats (left column)
    local col1 = 10
    local ly = hudY + 6
    bridge.drawText("LVL:" .. player.level, col1, ly, 255, 255, 150, 255)
    bridge.drawText("FL:" .. game.floor_num, col1 + 55, ly, 255, 200, 100, 255)

    ly = ly + 14
    -- HP bar
    bridge.drawText("HP:", col1, ly, 200, 200, 200, 255)
    local barX = col1 + 28
    local barW = 90
    local barH = 10
    bridge.drawRect(barX, ly, barW, barH, 40, 15, 15, 255)
    local hpW = floor(barW * (player.hp / player.maxHp))
    local hpR = player.hp <= player.maxHp * 0.3 and 255 or 50
    local hpG = player.hp <= player.maxHp * 0.3 and 50 or 220
    bridge.drawRect(barX, ly, hpW, barH, hpR, hpG, 50, 255)
    bridge.drawText(player.hp .. "/" .. player.maxHp, barX + barW + 5, ly, 200, 200, 200, 255)

    ly = ly + 14
    bridge.drawText("STR:" .. player.str .. " DEF:" .. player.def .. " DMG:" .. player.dmgMin .. "-" .. player.dmgMax, col1, ly, 180, 180, 200, 255)

    ly = ly + 14
    bridge.drawText("ARM:" .. player.armor .. " CRIT:<=" .. player.critBonus, col1, ly, 180, 180, 200, 255)
    bridge.drawText("XP:" .. player.xp .. "/" .. player.xpNext, col1 + 160, ly, C.xp[1], C.xp[2], C.xp[3], 255)

    ly = ly + 14
    bridge.drawText("Gold:" .. player.gold .. "  Potions:" .. player.potions, col1, ly, C.gold[1], C.gold[2], C.gold[3], 255)
    bridge.drawText("Kills:" .. player.kills, col1 + 200, ly, 200, 160, 160, 255)

    -- Message log (right side)
    local msgX = W/2 + 20
    local msgY = hudY + 8
    bridge.drawText("-- Combat Log --", msgX, msgY, 120, 110, 140, 255)
    for i, msg in ipairs(game.messages) do
        local alpha = max(80, 255 - i * 25)
        bridge.drawText(msg.text, msgX, msgY + i * 13, msg.r, msg.g, msg.b, alpha)
        if msgY + i * 13 > H - 5 then break end
    end

    -- Level up overlay
    if game.state == "levelup" then
        bridge.drawRect(W/4, H/4, W/2, H/2, 15, 12, 30, 240)
        bridge.drawRect(W/4, H/4, W/2, 2, 255, 220, 100, 255)
        bridge.drawText("LEVEL UP! Choose a bonus:", W/4 + 20, H/4 + 12, 255, 255, 150, 255)
        for i, choice in ipairs(levelChoices) do
            local y = H/4 + 30 + (i-1) * 22
            local hover = false -- could add mouse later
            bridge.drawRect(W/4 + 15, y, W/2 - 30, 18, 30, 25, 50, 200)
            bridge.drawText(i .. ") " .. choice.name, W/4 + 22, y + 2, 220, 220, 240, 255)
        end
    end

    -- Death overlay
    if game.state == "dead" then
        bridge.drawRect(W/4, H/3, W/2, H/4, 20, 5, 5, 230)
        bridge.drawRect(W/4, H/3, W/2, 2, 255, 50, 50, 255)
        bridge.drawText("YOU HAVE PERISHED", W/4 + 40, H/3 + 15, 255, 60, 60, 255)
        bridge.drawText("Floor: " .. game.floor_num .. "  Level: " .. player.level .. "  Kills: " .. player.kills, W/4 + 15, H/3 + 35, 200, 200, 200, 255)
        bridge.drawText("Gold: " .. player.gold .. "  Score: " .. (player.kills * 10 + player.gold + game.floor_num * 50), W/4 + 15, H/3 + 52, 255, 220, 100, 255)
        bridge.drawText("PRESS SPACE TO TRY AGAIN", W/4 + 25, H/3 + 75, 180, 180, 180, 255)
    end
end

-- Main update
function UpdateUI(mx, my, down, w, h)
    W, H = w, h
    root.width = w
    root.height = h
    local dt = 0.016

    -- Shake decay
    if game.shakeTimer > 0 then
        game.shakeTimer = game.shakeTimer - dt
    end

    -- Particles
    for i = #game.particles, 1, -1 do
        local p = game.particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.life = p.life - dt
        p.vx = p.vx * 0.95
        p.vy = p.vy * 0.95
        if p.life <= 0 then table.remove(game.particles, i) end
    end

    -- Age messages
    for _, msg in ipairs(game.messages) do
        msg.age = msg.age + dt
    end

    -- Input
    if game.state == "title" then
        if keyPressed("space") then
            resetGame()
        end
        return
    end

    if game.state == "dead" then
        if keyPressed("space") then
            resetGame()
        end
        return
    end

    if game.state == "levelup" then
        for i = 1, #levelChoices do
            if keyPressed(tostring(i)) then
                levelChoices[i].apply()
                addMessage("Chose: " .. levelChoices[i].name, 255, 255, 150)
                game.state = "playing"
                break
            end
        end
        return
    end

    -- Movement (turn-based with input cooldown for held keys)
    game.inputCooldown = max(0, game.inputCooldown - dt)

    if game.state == "playing" then
        if keyPressed("up") or keyPressed("w") then tryMove(0, -1)
        elseif keyPressed("down") or keyPressed("s") then tryMove(0, 1)
        elseif keyPressed("left") or keyPressed("a") then tryMove(-1, 0)
        elseif keyPressed("right") or keyPressed("d") then tryMove(1, 0)
        elseif keyPressed("p") then usePotion()
        end
    end
end

function DrawUI()
    DrawGame()
end-- sprite_font_editor.lua
-- THE ULTIMATE NERD FLEX: Build custom sprite fonts interactively!
-- Load an atlas, arrow-key navigate, press any key to assign that character

local root = UIElement:new({width=1024, height=768})

-- ===================================================
-- State
-- ===================================================
local state = {
    atlasPath = "Content/mbf_big_00.png",
    atlasTexId = nil,
    atlasWidth = 256,
    atlasHeight = 128,
    
    -- Grid navigation
    cellWidth = 10,
    cellHeight = 12,
    cursorX = 0,
    cursorY = 0,
    
    -- Character mapping
    charMap = {}, -- [ascii_code] = {x, y, width, height, xoffset, yoffset, xadvance}
    
    -- Input state
    captureMode = false,
    lastKeyPressed = nil,
    
    -- Preview
    previewText = "The quick brown fox jumps over the lazy dog! 0123456789",
}

-- Load the atlas texture (will be loaded after bridge is available)
function loadAtlasTexture()
    -- In a real implementation, you'd call bridge.loadTexture(state.atlasPath)
    -- For now, we'll just note that this would happen at init
    -- The texture would be bound before drawing the atlas display
    print("[System] Atlas texture would be loaded from: " .. state.atlasPath)
end

-- Load the atlas texture
local texId, texW, texH = bridge.loadTexture(state.atlasPath)
if texId then
    state.atlasTexId = texId
    state.atlasWidth = texW
    state.atlasHeight = texH
    print(string.format("[Font Editor] Loaded atlas: %s (%dx%d)", state.atlasPath, texW, texH))
else
    print("[Font Editor] WARNING: Could not load atlas texture: " .. state.atlasPath)
end

-- ===================================================
-- Main Container
-- ===================================================
local mainPanel = Panel:new({
    x = 0, y = 0,
    width = 1024, height = 768,
    bgColor = {25, 25, 28, 255}
})
root:addChild(mainPanel)

-- ===================================================
-- Top Bar - Controls
-- ===================================================
local topBar = Panel:new({
    x = 0, y = 0,
    width = 1024, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {80, 80, 80, 255},
    borderThickness = 2
})
topBar:setPadding(10)
mainPanel:addChild(topBar)

local titleLabel = Label:new({
    text = "SPRITE FONT EDITOR",
    width = 1000, height = 20,
    alignment = "center",
    textColor = {255, 200, 100, 255}
})
topBar:addChild(titleLabel)

local instructionLabel = Label:new({
    x = 10, y = 30,
    text = "Arrow Keys: Navigate | Any Key: Assign Character | Space: Clear Assignment | S: Save .fnt File",
    width = 1000, height = 20,
    alignment = "left",
    textColor = {200, 200, 200, 255}
})
topBar:addChild(instructionLabel)

-- ===================================================
-- Left Panel - Atlas Viewer with Grid Overlay
-- ===================================================
local atlasPanel = Panel:new({
    x = 10, y = 70,
    width = 600, height = 500,
    bgColor = {40, 40, 45, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
atlasPanel:setPadding(10)
mainPanel:addChild(atlasPanel)

local atlasTitle = Label:new({
    text = "Font Atlas (Navigate with Arrow Keys)",
    width = 580, height = 20,
    alignment = "left",
    textColor = {150, 255, 150, 255}
})
atlasPanel:addChild(atlasTitle)

-- Atlas display area (custom rendering with texture + grid + cursor)
local atlasDisplay = Panel:new({
    x = 10, y = 30,
    width = 580, height = 450,
    bgColor = {20, 20, 25, 255},
    borderColor = {60, 60, 60, 255},
    borderThickness = 1
})

-- Override drawSelf to render atlas texture, grid, and cursor
atlasDisplay.drawSelf = function(self)
    -- Draw background panel
    local gx, gy = self:getGlobalBounds()
    
    -- Draw background
    bridge.drawRect(gx, gy, self.width, self.height, 
        self.bgColor[1], self.bgColor[2], self.bgColor[3], self.bgColor[4])
    
    -- Draw border
    if self.borderThickness > 0 then
        bridge.drawBorder(gx, gy, self.width, self.height,
            self.borderColor[1], self.borderColor[2], self.borderColor[3], self.borderColor[4],
            self.borderThickness)
    end
    
    if not state.atlasTexId then return end
    
    -- Calculate scale to fit atlas in display area
    local scaleX = self.width / state.atlasWidth
    local scaleY = self.height / state.atlasHeight
    local scale = math.min(scaleX, scaleY) * 0.95  -- 95% to leave padding
    
    local displayW = state.atlasWidth * scale
    local displayH = state.atlasHeight * scale
    
    -- Center the atlas
    local offsetX = (self.width - displayW) / 2
    local offsetY = (self.height - displayH) / 2
    
    local atlasX = gx + offsetX
    local atlasY = gy + offsetY
    
    -- Draw the atlas texture
    bridge.drawTexture(state.atlasTexId, atlasX, atlasY, displayW, displayH)
    
    -- Draw grid overlay
    local gridCols = math.floor(state.atlasWidth / state.cellWidth)
    local gridRows = math.floor(state.atlasHeight / state.cellHeight)
    
    local cellDisplayW = (state.cellWidth / state.atlasWidth) * displayW
    local cellDisplayH = (state.cellHeight / state.atlasHeight) * displayH
    
    -- Draw vertical grid lines
    for col = 0, gridCols do
        local x = atlasX + col * cellDisplayW
        bridge.drawRect(x, atlasY, 1, displayH, 80, 80, 80, 100)
    end
    
    -- Draw horizontal grid lines
    for row = 0, gridRows do
        local y = atlasY + row * cellDisplayH
        bridge.drawRect(atlasX, y, displayW, 1, 80, 80, 80, 100)
    end
    
    -- Draw cursor highlight (green box)
    local cursorDisplayX = atlasX + state.cursorX * cellDisplayW
    local cursorDisplayY = atlasY + state.cursorY * cellDisplayH
    
    -- Green outline (4px thick)
    bridge.drawBorder(cursorDisplayX, cursorDisplayY, cellDisplayW, cellDisplayH, 
        100, 255, 100, 255, 2)
end

atlasPanel:addChild(atlasDisplay)

-- Cursor info
local cursorInfo = Label:new({
    x = 10, y = 485,
    text = "Cursor: (0, 0) | Cell: 8x8",
    width = 580, height = 20,
    textColor = {255, 255, 100, 255}
})
atlasPanel:addChild(cursorInfo)

-- ===================================================
-- Right Panel - Character Assignments
-- ===================================================
local assignmentPanel = Panel:new({
    x = 620, y = 70,
    width = 394, height = 500,
    bgColor = {40, 40, 45, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
assignmentPanel:setPadding(10)
mainPanel:addChild(assignmentPanel)

local assignmentTitle = Label:new({
    text = "Character Assignments",
    width = 374, height = 20,
    alignment = "left",
    textColor = {150, 150, 255, 255}
})
assignmentPanel:addChild(assignmentTitle)

-- Scrollable list of assignments (simplified for demo)
local assignmentList = VBox:new({
    x = 10, y = 30,
    width = 374, height = 420,
    spacing = 2
})
assignmentPanel:addChild(assignmentList)

-- Current selection indicator
local currentSelection = Label:new({
    x = 10, y = 455,
    text = "Press any key to assign to current cell...",
    width = 374, height = 20,
    textColor = {100, 255, 100, 255}
})
assignmentPanel:addChild(currentSelection)

-- Clear button
local clearBtn = Button:new({
    x = 10, y = 475,
    width = 180, height = 35,
    normalColor = {100, 60, 60, 255},
    hoverColor = {120, 70, 70, 255},
    pressedColor = {80, 50, 50, 255}
})
clearBtn.onClick = function()
    local gridX = state.cursorX
    local gridY = state.cursorY
    
    -- Find and remove any character assigned to this cell
    for ascii, data in pairs(state.charMap) do
        if data.gridX == gridX and data.gridY == gridY then
            state.charMap[ascii] = nil
            print("Cleared assignment for character: " .. string.char(ascii))
            break
        end
    end
    
    updateAssignmentList()
end
local clearLabel = Label:new({
    text = "Clear Assignment",
    width = 180, height = 35,
    alignment = "center"
})
clearBtn:addChild(clearLabel)
assignmentPanel:addChild(clearBtn)

-- Save button
local saveBtn = Button:new({
    x = 200, y = 475,
    width = 180, height = 35,
    normalColor = {60, 100, 60, 255},
    hoverColor = {70, 120, 70, 255},
    pressedColor = {50, 80, 50, 255}
})
saveBtn.onClick = function()
    saveFontFile()
end
local saveLabel = Label:new({
    text = "Save .fnt File",
    width = 180, height = 35,
    alignment = "center"
})
saveBtn:addChild(saveLabel)
assignmentPanel:addChild(saveBtn)

-- ===================================================
-- Bottom Panel - Preview
-- ===================================================
local previewPanel = Panel:new({
    x = 10, y = 580,
    width = 1004, height = 178,
    bgColor = {40, 40, 45, 255},
    borderColor = {100, 100, 100, 255},
    borderThickness = 2
})
previewPanel:setPadding(10)
mainPanel:addChild(previewPanel)

local previewTitle = Label:new({
    text = "Live Preview (renders with your custom font)",
    width = 984, height = 20,
    alignment = "left",
    textColor = {255, 150, 255, 255}
})
previewPanel:addChild(previewTitle)

local previewDisplay = Panel:new({
    x = 10, y = 30,
    width = 984, height = 80,
    bgColor = {20, 20, 25, 255},
    borderColor = {60, 60, 60, 255},
    borderThickness = 1
})
previewPanel:addChild(previewDisplay)

-- Preview text would render here using the custom font

local statsLabel = Label:new({
    x = 10, y = 120,
    text = "Characters Defined: 0 | Atlas: 256x128 | Cell Size: 8x8",
    width = 984, height = 20,
    textColor = {200, 200, 200, 255}
})
previewPanel:addChild(statsLabel)

local exportStatus = Label:new({
    x = 10, y = 145,
    text = "Status: Ready to assign characters",
    width = 984, height = 20,
    textColor = {100, 255, 100, 255}
})
previewPanel:addChild(exportStatus)

-- ===================================================
-- Settings Panel (Grid Size Controls)
-- ===================================================
local settingsRow = HBox:new({
    x = 10, y = 510,
    width = 600, height = 60,
    spacing = 10
})
mainPanel:addChild(settingsRow)

-- Cell width control
local cellWidthPanel = Panel:new({
    width = 190, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {70, 70, 70, 255},
    borderThickness = 1
})
cellWidthPanel:setPadding(5)
local cellWidthLabel = Label:new({
    text = "Cell Width: 8",
    width = 180, height = 20,
    alignment = "center"
})
cellWidthPanel:addChild(cellWidthLabel)

local cellWidthSlider = Slider:new({
    x = 5, y = 25,
    width = 180
})
cellWidthSlider.value = 0.5  -- Maps to 8 pixels (range 4-16)
cellWidthSlider.onValueChanged = function(val)
    state.cellWidth = math.floor(4 + val * 28)  -- 4 to 32 pixels
    cellWidthLabel.text = "Cell Width: " .. state.cellWidth
    updateCursorInfo()
end
cellWidthPanel:addChild(cellWidthSlider)
settingsRow:addChild(cellWidthPanel)

-- Cell height control
local cellHeightPanel = Panel:new({
    width = 190, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {70, 70, 70, 255},
    borderThickness = 1
})
cellHeightPanel:setPadding(5)
local cellHeightLabel = Label:new({
    text = "Cell Height: 8",
    width = 180, height = 20,
    alignment = "center"
})
cellHeightPanel:addChild(cellHeightLabel)

local cellHeightSlider = Slider:new({
    x = 5, y = 25,
    width = 180
})
cellHeightSlider.value = 0.5  -- Maps to 8 pixels
cellHeightSlider.onValueChanged = function(val)
    state.cellHeight = math.floor(4 + val * 28)  -- 4 to 32 pixels
    cellHeightLabel.text = "Cell Height: " .. state.cellHeight
    updateCursorInfo()
end
cellHeightPanel:addChild(cellHeightSlider)
settingsRow:addChild(cellHeightPanel)

-- Atlas dimensions info
local atlasDimPanel = Panel:new({
    width = 190, height = 60,
    bgColor = {35, 35, 38, 255},
    borderColor = {70, 70, 70, 255},
    borderThickness = 1
})
atlasDimPanel:setPadding(5)
local atlasDimLabel = Label:new({
    text = string.format("Atlas: %dx%d", state.atlasWidth, state.atlasHeight),
    width = 180, height = 20,
    alignment = "center",
    textColor = {255, 200, 100, 255}
})
atlasDimPanel:addChild(atlasDimLabel)

local gridInfoLabel = Label:new({
    x = 5, y = 25,
    text = string.format("Grid: %dx%d cells", 
        math.floor(state.atlasWidth / state.cellWidth),
        math.floor(state.atlasHeight / state.cellHeight)),
    width = 180, height = 20,
    alignment = "center",
    textColor = {200, 200, 200, 255}
})
atlasDimPanel:addChild(gridInfoLabel)
settingsRow:addChild(atlasDimPanel)

-- ===================================================
-- Helper Functions
-- ===================================================

function updateCursorInfo()
    local gridCols = math.floor(state.atlasWidth / state.cellWidth)
    local gridRows = math.floor(state.atlasHeight / state.cellHeight)
    
    cursorInfo.text = string.format("Cursor: (%d, %d) | Cell: %dx%d | Pixel: (%d, %d)", 
        state.cursorX, state.cursorY, 
        state.cellWidth, state.cellHeight,
        state.cursorX * state.cellWidth,
        state.cursorY * state.cellHeight)
    
    gridInfoLabel.text = string.format("Grid: %dx%d cells", gridCols, gridRows)
    
    -- Check if current cell has an assignment
    local assigned = nil
    for ascii, data in pairs(state.charMap) do
        if data.gridX == state.cursorX and data.gridY == state.cursorY then
            assigned = string.char(ascii)
            break
        end
    end
    
    if assigned then
        currentSelection.text = "Current cell assigned to: '" .. assigned .. "' (ASCII " .. string.byte(assigned) .. ")"
        currentSelection.textColor = {255, 255, 100, 255}
    else
        currentSelection.text = "Press any key to assign to current cell..."
        currentSelection.textColor = {100, 255, 100, 255}
    end
end

function updateAssignmentList()
    assignmentList:clearChildren()
    
    local count = 0
    local sortedChars = {}
    
    -- Sort by ASCII value
    for ascii, _ in pairs(state.charMap) do
        table.insert(sortedChars, ascii)
    end
    table.sort(sortedChars)
    
    for _, ascii in ipairs(sortedChars) do
        local data = state.charMap[ascii]
        local char = string.char(ascii)
        if ascii < 32 or ascii > 126 then
            char = "?"  -- Non-printable
        end
        
        local row = Panel:new({
            width = 374, height = 25,
            bgColor = {50, 50, 55, 255},
            borderColor = {70, 70, 75, 255},
            borderThickness = 1
        })
        
        local charLabel = Label:new({
            x = 5, y = 2,
            text = string.format("'%s' (ASCII %d) at grid (%d,%d)", 
                char, ascii, data.gridX, data.gridY),
            width = 364, height = 21,
            alignment = "left"
        })
        row:addChild(charLabel)
        
        assignmentList:addChild(row)
        count = count + 1
        
        if count >= 15 then break end  -- Limit display
    end
    
    -- Update stats
    local totalChars = 0
    for _ in pairs(state.charMap) do totalChars = totalChars + 1 end
    
    statsLabel.text = string.format("Characters Defined: %d | Atlas: %dx%d | Cell Size: %dx%d",
        totalChars, state.atlasWidth, state.atlasHeight, state.cellWidth, state.cellHeight)
end

function saveFontFile()
    -- Generate BMFont format .fnt file
    local output = {}
    
    -- Header
    table.insert(output, string.format('info face="CustomFont" size=%d bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1',
        state.cellHeight))
    table.insert(output, string.format('common lineHeight=%d base=%d scaleW=%d scaleH=%d pages=1 packed=0',
        state.cellHeight, state.cellHeight, state.atlasWidth, state.atlasHeight))
    table.insert(output, 'page id=0 file="' .. state.atlasPath .. '"')
    
    -- Count chars
    local charCount = 0
    for _ in pairs(state.charMap) do charCount = charCount + 1 end
    table.insert(output, 'chars count=' .. charCount)
    
    -- Character definitions
    for ascii, data in pairs(state.charMap) do
        local x = data.gridX * state.cellWidth
        local y = data.gridY * state.cellHeight
        
        table.insert(output, string.format(
            'char id=%d   x=%d     y=%d     width=%d     height=%d     xoffset=0     yoffset=0    xadvance=%d     page=0  chnl=0',
            ascii, x, y, state.cellWidth, state.cellHeight, state.cellWidth))
    end
    
    table.insert(output, 'kernings count=0')
    
    -- Write to file (in real implementation)
    local fontData = table.concat(output, "\n")
    print("=== GENERATED .FNT FILE ===")
    print(fontData)
    print("===========================")
    
    exportStatus.text = "SUCCESS! Font saved to custom_font.fnt (check console for output)"
    exportStatus.textColor = {100, 255, 100, 255}
    
    -- In a real implementation, you'd call a C function to write this to disk
    -- bridge.writeFile("custom_font.fnt", fontData)
end

-- ===================================================
-- Input Handling (Keyboard)
-- ===================================================

-- This would be called from C when a key is pressed
function HandleKeyPress(key)
    local gridCols = math.floor(state.atlasWidth / state.cellWidth)
    local gridRows = math.floor(state.atlasHeight / state.cellHeight)
    
    if key == "up" then
        state.cursorY = math.max(0, state.cursorY - 1)
        updateCursorInfo()
    elseif key == "down" then
        state.cursorY = math.min(gridRows - 1, state.cursorY + 1)
        updateCursorInfo()
    elseif key == "left" then
        state.cursorX = math.max(0, state.cursorX - 1)
        updateCursorInfo()
    elseif key == "right" then
        state.cursorX = math.min(gridCols - 1, state.cursorX + 1)
        updateCursorInfo()
    elseif key == "space" then
        -- Clear assignment (handled by button)
    elseif key == "s" or key == "S" then
        saveFontFile()
    else
        -- Assign this key to current cursor position
        local ascii = string.byte(key)
        if ascii then
            state.charMap[ascii] = {
                gridX = state.cursorX,
                gridY = state.cursorY,
                width = state.cellWidth,
                height = state.cellHeight
            }
            print(string.format("Assigned '%s' (ASCII %d) to grid (%d,%d)", 
                key, ascii, state.cursorX, state.cursorY))
            updateAssignmentList()
            updateCursorInfo()
            
            -- Auto-advance cursor
            state.cursorX = state.cursorX + 1
            if state.cursorX >= gridCols then
                state.cursorX = 0
                state.cursorY = state.cursorY + 1
                if state.cursorY >= gridRows then
                    state.cursorY = 0
                end
            end
            updateCursorInfo()
        end
    end
end

-- ===================================================
-- Initialize
-- ===================================================

-- Load atlas texture
local texId, w, h = bridge.loadTexture(state.atlasPath)
if texId then
    state.atlasTexId = texId
    state.atlasWidth = w
    state.atlasHeight = h
    print(string.format("[System] Loaded atlas: %s (%dx%d)", state.atlasPath, w, h))
    atlasDimLabel.text = string.format("Atlas: %dx%d", w, h)
else
    print("[Warning] Could not load atlas texture: " .. state.atlasPath)
    print("[Info] Place your font atlas PNG in Content/ folder")
end

updateCursorInfo()
updateAssignmentList()

-- ===================================================
-- Global Functions
-- ===================================================
function UpdateUI(mx, my, down, w, h)
    root.width = w
    root.height = h
    root:update(mx, my, down, w, h)
end

function DrawUI()
    root:draw()
    
    -- In a real implementation, you'd also draw:
    -- 1. The atlas texture
    -- 2. Grid overlay
    -- 3. Green cursor highlight
    -- 4. Preview text using the custom font
end